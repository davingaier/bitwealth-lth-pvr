create table public.std_dca_customer_transactions (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  customer_id bigint not null,
  transaction_date date not null,
  btc_date_closing date not null,
  btc_closing_price_usd numeric not null,
  signal_type text null,
  daily_dca_usd numeric not null default '0'::numeric,
  buy_usd numeric not null default '0'::numeric,
  buy_btc numeric not null default '0'::numeric,
  opening_balance_usd numeric not null,
  closing_balance_usd numeric not null,
  opening_balance_btc numeric not null,
  closing_balance_btc numeric not null,
  total_dca_invested_usd numeric not null default 0,
  portfolio_value_usd numeric GENERATED ALWAYS as (
    round(
      (
        (
          COALESCE(btc_closing_price_usd, (0)::numeric) * COALESCE(closing_balance_btc, (0)::numeric)
        ) + COALESCE(closing_balance_usd, (0)::numeric)
      ),
      2
    )
  ) STORED (18, 2) null,
  total_roi_percent numeric GENERATED ALWAYS as (
    case
      when (
        COALESCE(total_dca_invested_usd, (0)::numeric) = (0)::numeric
      ) then 0.0
      else round(
        (
          (
            100.0 * (
              (
                (
                  COALESCE(btc_closing_price_usd, (0)::numeric) * COALESCE(closing_balance_btc, (0)::numeric)
                ) + COALESCE(closing_balance_usd, (0)::numeric)
              ) - COALESCE(total_dca_invested_usd, (0)::numeric)
            )
          ) / total_dca_invested_usd
        ),
        1
      )
    end
  ) STORED (18, 1) null,
  trading_year integer null,
  cagr_percent numeric GENERATED ALWAYS as (
    case
      when (
        (
          COALESCE(total_dca_invested_usd, (0)::numeric) = (0)::numeric
        )
        or (COALESCE(trading_year, 0) <= 0)
      ) then 0.0
      else round(
        (
          100.0 * (
            power(
              (
                (
                  (
                    COALESCE(btc_closing_price_usd, (0)::numeric) * COALESCE(closing_balance_btc, (0)::numeric)
                  ) + COALESCE(closing_balance_usd, (0)::numeric)
                ) / NULLIF(total_dca_invested_usd, (0)::numeric)
              ),
              (1.0 / (NULLIF(trading_year, 0))::numeric)
            ) - 1.0
          )
        ),
        1
      )
    end
  ) STORED (18, 1) null,
  constraint std_btc_dca_customer_transactions_pkey primary key (id),
  constraint std_btc_dca_customer_transactions_id_key unique (id),
  constraint std_dca_cust_date_unique unique (customer_id, transaction_date),
  constraint std_dca_customer_transactions_cust_date_unique unique (customer_id, transaction_date),
  constraint std_btc_dca_customer_transactions_customer_id_fkey foreign KEY (customer_id) references customer_details (customer_id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists std_cust_txdate_idx on public.std_dca_customer_transactions using btree (customer_id, transaction_date) TABLESPACE pg_default;

create unique INDEX IF not exists std_upsert_uniq on public.std_dca_customer_transactions using btree (customer_id, transaction_date, btc_date_closing) TABLESPACE pg_default;

create index IF not exists idx_std_txn_by_cust_trading_year_date on public.std_dca_customer_transactions using btree (customer_id, trading_year, transaction_date desc) TABLESPACE pg_default;

create trigger std_trading_year_after
after INSERT
or
update OF transaction_date,
customer_id on std_dca_customer_transactions for EACH row
execute FUNCTION recalc_trading_years_std ();

create trigger std_trading_year_biu BEFORE INSERT
or
update OF transaction_date,
customer_id on std_dca_customer_transactions for EACH row
execute FUNCTION set_trading_year_std ();