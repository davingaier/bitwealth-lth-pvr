<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BitWealth</title>

  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css"/>

  <style>
    :root{
      --border:#e7e7e7; --ink:#111827; --muted:#6b7280; --grid:#F2F2F2;
      --control-height:44px; --control-radius:8px; --control-pad-x:12px; --control-caret-offset:12px; --control-width:340px;

      --series-btc-price:#ff8c00;
      --series-invested:#000000;
      --series-adv-value:#22c55e;
      --series-usd-balance:#60a5fa;
      --series-btc-balance:#ef4444;
      --series-comp-adv:#032C48;
      --series-comp-std:#BEBEBE;
    }

    body{font-family:'Aptos',system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:0;color:var(--ink);background:#fff}
    header{display:flex;align-items:center;padding:1em 2em;border-bottom:1px solid var(--border);background:#fff}
    header img{height:60px}

    nav{padding:.5em 2em;background:#f8f8f8;border-bottom:1px solid var(--border);white-space:nowrap;overflow-x:auto;position:relative;z-index:5}
    nav a{display:inline-block;text-decoration:none;color:inherit;padding:.5em 1em;margin-right:1em;border-radius:6px}
    nav a:hover{background:#efefef}

    /* Org / portfolio context bar
       - Only visible for strategy-sensitive modules
       - Hidden for Import, Finance, Administration, etc.
    */
    .context-bar{
      display:none;
      flex-wrap:wrap;
      gap:1.5rem;
      align-items:flex-end;
      padding:.25rem 2rem .75rem;
      background:#f8f8f8;
      border-bottom:1px solid var(--border);
    }
    /* Show the context bar only when a strategy module is active */
    body:has(#strategy-maintenance-module:target) .context-bar,
    body:has(#balance-maintenance-module:target) .context-bar,
    body:has(#transactions-module:target) .context-bar,
    body:has(#reports-module:target) .context-bar{
      display:flex;
    }

    /* Customer Transactions and Strategy Maintenance are multi-customer: hide the customer selector */
    body:has(#transactions-module:target) #ctxCustomerGroup,
    body:has(#strategy-maintenance-module:target) #ctxCustomerGroup{
      display:none;
    }
    .context-group{
      display:flex;
      flex-direction:column;
      gap:.25rem;
      min-width:220px;
    }
    .context-label{
      font-size:.75rem;
      text-transform:uppercase;
      letter-spacing:.05em;
      color:var(--muted);
    }
    .context-select{
      height:var(--control-height);
      border-radius:var(--control-radius);
      border:1px solid var(--border);
      padding:0 var(--control-pad-x);
      background:#fff;
      font:inherit;
      min-width:220px;
    }
    .context-select:disabled{
      background:#f3f4f6;
      color:var(--muted);
      cursor:not-allowed;
    }

    /* Global context bar: Customer Transactions is multi-customer */
    body:has(#transactions-module:target) #ctxCustomerGroup{
      display:none;
    }

    /* Generic helper for strategy-specific cards */
    .strategy-hidden{
      display:none !important;
    }

    /* Active tab strictly matches visible :target (uniform style for all modules) */
    body:not(:has(.module:target)) nav a[href="#import-module"],
    body:has(#management-module:target) nav a[href="#management-module"],
    body:has(#strategy-maintenance-module:target) nav a[href="#strategy-maintenance-module"],
    body:has(#import-module:target) nav a[href="#import-module"],
    body:has(#balance-maintenance-module:target) nav a[href="#balance-maintenance-module"],
    body:has(#transactions-module:target) nav a[href="#transactions-module"],
    body:has(#reports-module:target) nav a[href="#reports-module"],
    body:has(#backtest-module:target) nav a[href="#backtest-module"],
    body:has(#finance-module:target) nav a[href="#finance-module"],
    body:has(#admin-module:target) nav a[href="#admin-module"]{
      border-bottom:2px solid var(--series-btc-price);
      color:var(--series-btc-price);
    }

    main{padding:2em}

    .executed-collapsible summary { cursor:pointer; user-select:none }
    .executed-list .row { display:flex; gap:.5rem; padding:.25rem 0; border-bottom:1px solid #eee; font:12px system-ui }
    .executed-list .row:last-child { border-bottom:none }
    .executed-list .side-buy { color:#15803d }  /* green */
    .executed-list .side-sell { color:#b91c1c } /* red */

    .bmBadge {
      display:inline-block; margin-right:.5rem;
      padding:2px 6px; font-size:11px; border-radius:10px;
      color:#155724; background:#d4edda; border:1px solid #c3e6cb;
      vertical-align:middle;
    }

    .bmBadge--muted{ color:#374151; background:#f3f4f6; border:1px solid #e5e7eb; }

    /* --- Status pill badges (orders) --- */
    .status-pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #e5e7eb;    /* light gray border */
      font-size:12px;
      line-height:1.2;
      vertical-align:middle;
      white-space:nowrap;
      user-select:none;
    }

    /* queued/created but not yet active */
    .status-pill.submitted{
      background:#fff7ed;          /* amber-50 */
      color:#9a3412;               /* amber-800 */
      border-color:#fed7aa;        /* amber-200 */
    }

    /* actively working / polling */
    .status-pill.executing{
      background:#f3f4f6;          /* gray-100 */
      color:#374151;               /* gray-700 */
      border-color:#e5e7eb;        /* gray-200 */
    }

    /* exchange shows partial fill */
    .status-pill.partially_filled{
      background:#e0f2fe;          /* sky-100 */
      color:#075985;               /* sky-800 */
      border-color:#bae6fd;        /* sky-200 */
    }

    /* terminal: filled */
    .status-pill.filled{
      background:#d1fae5;          /* emerald-100 */
      color:#065f46;               /* emerald-900 */
      border-color:#a7f3d0;        /* emerald-200 */
    }

    /* terminal: cancelled */
    .status-pill.cancelled{
      background:#fee2e2;          /* rose-100 */
      color:#991b1b;               /* rose-900 */
      border-color:#fecaca;        /* rose-200 */
    }

    /* terminal: error */
    .status-pill.error{
      background:#fee2e2;          /* rose-100 */
      color:#991b1b;               /* rose-900 */
      border-color:#fecaca;        /* rose-200 */
    }

    /* Alerts severities */
    .status-pill.info{
      background:#dbeafe;          /* blue-100 */
      color:#1e3a8a;               /* blue-900 */
      border-color:#bfdbfe;        /* blue-200 */
    }
    .status-pill.warn{
      background:#fef3c7;          /* amber-100 */
      color:#92400e;               /* amber-900 */
      border-color:#fde68a;        /* amber-200 */
    }
    .status-pill.critical{
      background:#fee2e2;          /* red-100 */
      color:#7f1d1d;               /* red-900 */
      border-color:#fecaca;        /* red-200 */
    }

    /* non-actioned / below min etc. */
    .status-pill.skipped{
      background:#e5e7eb;          /* gray-200 */
      color:#374151;               /* gray-700 */
      border-color:#e5e7eb;        /* gray-200 */
    }

    /* optional: “preview” badge styling if you show it */
    .status-pill.preview{
      background:#eef2ff;          /* indigo-50 */
      color:#3730a3;               /* indigo-800 */
      border-color:#c7d2fe;        /* indigo-200 */
    }

    @keyframes pillPulse { 0%{opacity:.85} 50%{opacity:1} 100%{opacity:.85} }
    .status-pill.executing{ animation:pillPulse 1.2s ease-in-out infinite; }
    
    @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }

    /* Router: show current :target; default to Import */
    .module{display:none}
    .module:target{display:block}
    body:not(:has(.module:target)) #import-module{display:block}

    #inlineError,#reportsError,#balancesError{color:#b91c1c;background:#fee2e2;padding:.75em 1em;border:1px solid #fecaca;border-radius:10px;display:none;margin-bottom:1em}

    table{border-collapse:collapse;width:100%;margin-top:1em}
    th,td{border:1px solid #ccc;padding:.5em;text-align:center}
    th{background:#f0f0f0}
    #importBtn{margin-top:1em}
    .status-duplicate{color:#d97706}.status-ready{color:#16a34a}

    /* ===== CENTER the dropdown row (outer flex + inner grid) ===== */
    .reports-controls-outer{
      display:flex;
      justify-content:center;
      align-items:center;
      width:100%;
    }
    .reports-controls{
      display:grid;
      grid-template-columns:max-content var(--control-width) max-content var(--control-width);
      align-items:center;
      gap:0.75rem 1rem;
      width:auto;
    }
    .reports-controls label{justify-self:end;}

    /* Native select base (report type before Choices attaches) */
    .reports-controls select{
      font-family:inherit;font-size:1rem;color:var(--ink);
      width:var(--control-width);min-width:var(--control-width);height:var(--control-height);
      background:#fff;border:1px solid var(--border)!important;border-radius:var(--control-radius);
      padding:0 calc(2.2rem) 0 var(--control-pad-x);line-height:1.25;
      appearance:none;-webkit-appearance:none;-moz-appearance:none;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 6'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%236b7280' stroke-width='1.5' fill='none' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
      background-repeat:no-repeat;background-size:10px 6px;background-position:right var(--control-caret-offset) center;box-shadow:none;outline:0;
      text-align:left;
    }

    /* Choices.js size normalization & left text */
    .choices__list--dropdown{z-index:9999}
    .reports-controls .choices{
      width:var(--control-width);min-width:var(--control-width);
      font-family:inherit;margin:0 !important;
    }
    .choices[data-type*="select-one"] .choices__inner{
      border:1px solid var(--border);border-radius:var(--control-radius);
      background:#fff;min-height:var(--control-height);height:var(--control-height);
      padding:0;display:flex;align-items:center;text-align:left
    }
    .choices__list--single{
      padding:0 calc(2.2rem) 0 var(--control-pad-x);
      width:100%;display:flex;align-items:center;justify-content:flex-start;text-align:left
    }
    .choices__list--dropdown,.choices__list[aria-expanded]{border:1px solid var(--border);border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,.08)}
    .choices__list--dropdown .choices__item--selectable{padding:10px 12px}
    .choices__item--selectable.is-highlighted{background:#f8fafc}
    .choices.is-open .choices__inner,.choices.is-focused .choices__inner{border-color:#032C48;box-shadow:0 0 0 3px rgba(3,44,72,.08)}
    .choices__input{padding:8px 10px!important;margin-bottom:6px;border-bottom:1px solid var(--border)!important}

    /* Mobile stack */
    @media (max-width:760px){
      .reports-controls{grid-template-columns:1fr;justify-items:center}
      .reports-controls label{justify-self:center}
    }

    .card{max-width:1200px;margin:1rem auto 0;background:#fff;border:1px solid var(--border);border-radius:16px;box-shadow:0 1px 3px rgba(0,0,0,.05);padding:14px 16px 10px}
    .chart-title{text-align:center;margin:8px 0 6px}
    .chart-notice{display:none;text-align:center;color:var(--muted);margin:.75rem 0}
    .chart-toolbar{display:flex;justify-content:center;gap:.5rem;margin:4px 0 8px}
    .chart-toolbar button{padding:.35rem .7rem;font-size:.9rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
    canvas{max-width:100%}
    .chart-range{display:none;margin-top:6px}
    .chart-range .sliders{display:flex;gap:.5rem;align-items:center}
    .chart-range input[type=range]{width:100%}
    .chart-range .labels{display:flex;justify-content:space-between;font-size:.85rem;color:var(--muted);margin-top:.25rem}
    .chart-footer{display:none;justify-content:center;gap:.5rem;flex-wrap:wrap;margin-top:.5rem}
    .badge{display:flex;align-items:center;gap:.5rem;font-size:.9rem;background:#fafafa;border:1px solid var(--border);border-radius:999px;padding:.25rem .6rem}
    .badge .dot{width:10px;height:10px;border-radius:50%}
    .badge small{color:var(--muted);font-size:.8rem}
    .chart-actions{margin-top:.5rem;text-align:center}
    .chart-actions button{padding:.45rem .8rem;font-size:.95rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
    .chart-actions button:disabled{opacity:.5;cursor:not-allowed}

    /* --- Transactions module buttons --- */
    .tx-toolbar{display:flex;justify-content:center;gap:.5rem;margin:8px 0}
    .tx-toolbar button{padding:.45rem .8rem;font-size:.95rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}

    /* ===== Customer Maintenance styles ===== */
    .cm-tab{padding:.45rem .8rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
    .cm-tab--active{border-color:#032C48;box-shadow:0 0 0 3px rgba(3,44,72,.08)}
    .cm-form label{display:flex;flex-direction:column;gap:.35rem;font-size:.95rem}
    .cm-form input,.cm-form select{
      font:inherit;height:var(--control-height);border:1px solid var(--border);border-radius:var(--control-radius);
      padding:0 var(--control-pad-x);background:#fff;min-width:0;
    }
    .cm-grid{display:grid;grid-template-columns:repeat(2,minmax(260px,1fr));gap:.75rem}
    @media (max-width:760px){.cm-grid{grid-template-columns:1fr}}
    .req{color:#dc2626;margin-left:.25rem}
    .label-line{display:inline-flex;align-items:center;gap:.25rem}

    /* Small sub-section heading + separators inside Transactions */
    .subhead{
      font-size:1.05rem;
      color:var(--muted);
      font-weight:600;
      margin:1rem auto .5rem;
      max-width:1200px;
    }
    .section-sep{
      border:0;
      border-top:1px solid var(--border);
      margin:1rem auto;
      max-width:1200px;
      height:0;
    }

    /* Center the Run Daily Rules controls */
    #transactions-module #daily-rules-runner{max-width:1200px;margin:.25rem auto 1rem;}
    #transactions-module #daily-rules-runner .run-toolbar{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
      gap:.75rem 1rem;
      text-align:center;
    }
    #transactions-module #daily-rules-runner .run-toolbar label{
      display:inline-flex;
      align-items:center;
      gap:.5rem;
      margin:0;
    }
    #transactions-module #daily-rules-runner .run-status{
      display:flex;
      justify-content:center;
      margin-top:.5rem;
      color:var(--muted);
    }
    #transactions-module #daily-rules-runner #rulesStatus{color:var(--muted);}

    /* Alert badge (red number on Administration nav link) */
    .alert-badge {
      display:inline-block;
      margin-left:0.5rem;
      padding:2px 8px;
      font-size:11px;
      font-weight:600;
      color:#fff;
      background:#ef4444;
      border-radius:999px;
      vertical-align:middle;
      line-height:1.4;
    }
    .alert-badge.zero { display:none; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.47.10"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
    if (window.Chart) {
      const css = getComputedStyle(document.documentElement);
      const ink  = css.getPropertyValue('--ink').trim()  || '#111827';
      const grid = css.getPropertyValue('--grid').trim() || '#F2F2F2';
      Chart.defaults.font.family = 'Aptos, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      Chart.defaults.color = ink;
      Chart.defaults.borderColor = grid;
    }
  </script>
</head>
<body>
  <header>
    <img src="assets/logo.png" alt="BitWealth Logo" style="padding: 4px;">
    <img id="pdfLogo" src="assets/logo.png" alt="BitWealth Logo" style="display:none" />
  </header>

  <nav id="topnav">
    <a href="#management-module">Customer Management</a>
    <a href="#strategy-maintenance-module">Strategy Maintenance</a>
    <a href="#import-module">Import Daily Data</a>
    <a id="nav-cbm" class="top-tab" href="#balance-maintenance-module">Customer Balance Maintenance</a>
    <a href="#transactions-module">Customer Transactions</a>
    <a href="#reports-module">Portfolio Performance Reporting</a>
    <a href="#backtest-module">Strategy Back-Testing</a>
    <a href="#finance-module">Finance</a>
    <a href="#admin-module">Administration<span class="alert-badge zero" id="alertBadge">0</span></a>
  </nav>

  <!-- Org / portfolio context (shared across modules) -->
  <section id="contextBar" class="context-bar">
    <div class="context-group">
      <span class="context-label">Organisation</span>
      <select id="orgSelect" class="context-select" disabled>
        <option>Loading…</option>
      </select>
    </div>
    <div class="context-group" id="ctxCustomerGroup">
      <span class="context-label">Customer</span>
      <select id="customerSelect" class="context-select" disabled>
        <option>Loading customers…</option>
      </select>
    </div>
    <div class="context-group">
      <span class="context-label">Active strategy</span>
      <select id="portfolioSelect" class="context-select" disabled>
        <option>Loading…</option>
      </select>
    </div>
  </section>

  <main>

    <!-- ===================== Customer Management ===================== -->
    <div id="management-module" class="module">
      <h2>Customer Management</h2>

      <!-- Dashboard Metrics Card -->
      <div class="card" style="max-width:980px;margin-bottom:1rem;">
        <h3 style="margin:0 0 1rem;">Dashboard Metrics</h3>
        <div id="dashboardMetricsLoading" style="text-align:center;padding:2rem;color:var(--muted);">
          Loading metrics...
        </div>
        <div id="dashboardMetricsContent" style="display:none;">
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-bottom:1rem;">
            <div style="background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
              <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">
                Total Customers
              </div>
              <div id="metricTotalCustomers" style="font-size:1.75rem;font-weight:600;color:var(--ink);">
                —
              </div>
            </div>
            <div style="background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
              <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">
                Active Customers
              </div>
              <div id="metricActiveCustomers" style="font-size:1.75rem;font-weight:600;color:#10b981;">
                —
              </div>
            </div>
            <div style="background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
              <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">
                Total AUM
              </div>
              <div id="metricTotalAUM" style="font-size:1.75rem;font-weight:600;color:var(--ink);">
                —
              </div>
            </div>
            <div style="background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
              <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">
                Avg Portfolio NAV
              </div>
              <div id="metricAvgNAV" style="font-size:1.75rem;font-weight:600;color:var(--ink);">
                —
              </div>
            </div>
          </div>
          <div style="display:flex;gap:1rem;align-items:center;padding-top:.75rem;border-top:1px solid var(--border);">
            <div style="flex:1;">
              <span style="font-size:.85rem;color:var(--muted);">Active Alerts (Last 7 Days):</span>
              <span id="metricAlerts" style="margin-left:.5rem;">—</span>
            </div>
            <div style="font-size:.75rem;color:var(--muted);">
              <span id="metricUpdatedAt">—</span>
            </div>
          </div>
        </div>
        <div id="dashboardMetricsError" style="display:none;text-align:center;padding:2rem;color:#ef4444;">
          Failed to load metrics. Please refresh the page.
        </div>
      </div>

      <div class="card" style="max-width:980px">
        <nav style="display:flex;gap:.5rem;margin-bottom:.75rem;">
          <button id="cmTabNew"  type="button" class="cm-tab cm-tab--active">Create New Client</button>
          <button id="cmTabEdit" type="button" class="cm-tab">Edit Existing Client</button>
        </nav>

        <div id="cmAlert" style="display:none;margin:.5rem 0;padding:.7rem 1rem;border-radius:10px;border:1px solid"></div>

        <!-- ===== New Client ===== -->
        <form id="cmFormNew" class="cm-form">
          <h3 style="margin:.25rem 0 1rem">New Client Details</h3>

          <div class="cm-grid">
            <label>
              <span class="label-line">First names <span class="req">*</span></span>
              <input name="first_names" required />
            </label>
            <label>
              <span class="label-line">Last name <span class="req">*</span></span>
              <input name="last_name" required />
            </label>
            <label>
              <span class="label-line">Email address <span class="req">*</span></span>
              <input name="email_address" type="email" required />
            </label>
            <label>
              <span class="label-line">Cellphone number <span class="req">*</span></span>
              <input name="cellphone_number" required />
            </label>
            <label>
              <span class="label-line">ID number <span class="req">*</span></span>
              <input name="id_number" inputmode="numeric" pattern="\d{13}" title="13-digit SA ID number" required />
            </label>

            <label>
              <span class="label-line">Trade start date</span>
              <input name="trade_start_date" type="date" />
            </label>

            <label>
              <span class="label-line">Recurrence <span class="req">*</span></span>
              <select name="recurring_contribution_frequency" required>
                <option value="None">None</option>
                <option value="Weekly">Weekly</option>
                <option value="Monthly" selected>Monthly</option>
                <option value="Annually">Annually</option>
              </select>
            </label>

            <label>
              <span class="label-line">Recurring contribution (ZAR) <span class="req" data-cm-req="freq">*</span></span>
              <input name="recurring_contribution_zar" type="number" min="0" step="0.01" />
            </label>
            <label>
              <span class="label-line">Upfront contribution (ZAR)</span>
              <input name="upfront_contribution_zar" type="number" min="0" step="0.01" value="0" />
            </label>
            <label>
              <span class="label-line">Upfront contribution (BTC)</span>
              <input name="upfront_contribution_btc" type="number" min="0" step="0.00000001" value="0" />
            </label>

            <label>
              <span class="label-line">Exchange name</span>
              <select name="exchange_api_name">
                <option value="">None</option>
                <option value="VALR">VALR</option>
                <option value="Binance">Binance</option>
                <option value="Luno">Luno</option>
              </select>
            </label>
            <label><span class="label-line">Exchange username</span> <input name="exchange_username" /></label>
            <label><span class="label-line">Exchange password</span> <input name="exchange_password" type="password" /></label>
            <label><span class="label-line">API key</span> <input name="exchange_api_key" /></label>
            <label><span class="label-line">API secret</span> <input name="exchange_api_secret" type="password" /></label>
            <label><span class="label-line">BTC wallet address</span> <input name="exchange_btc_wallet_address" /></label>

            <label>
              <span class="label-line">Status <span class="req">*</span></span>
              <select name="customer_status" required>
                <option value="Active" selected>Active</option>
                <option value="Inactive">Inactive</option>
                <option value="Suspended">Suspended</option>
              </select>
            </label>
          </div>

          <div style="display:flex;gap:.5rem;margin-top:.75rem;">
            <button type="submit">Create Client</button>
            <button type="reset">Reset</button>
          </div>
        </form>

        <!-- ===== Edit Client ===== -->
        <form id="cmFormEdit" class="cm-form" style="display:none;">
          <h3 style="margin:.25rem 0 1rem">Edit Client Details</h3>

          <!-- Search and Filter Controls -->
          <div style="display:grid;grid-template-columns:1fr 200px auto;gap:.75rem;margin-bottom:.75rem;align-items:end;">
            <label>
              <span class="label-line">Search customers</span>
              <input 
                id="cmSearchInput" 
                type="text" 
                placeholder="Search by name, email, or ID..." 
                style="width:100%;" 
              />
            </label>
            <label>
              <span class="label-line">Filter by status</span>
              <select id="cmStatusFilter" style="width:100%;">
                <option value="" selected>All statuses</option>
                <option value="prospect">Prospect</option>
                <option value="kyc">KYC Verification</option>
                <option value="setup">Account Setup</option>
                <option value="deposit">Awaiting Deposit</option>
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
              </select>
            </label>
            <button type="button" id="cmClearFilters" style="height:var(--control-height);white-space:nowrap;">
              Clear Filters
            </button>
          </div>

          <div style="margin-bottom:.75rem;">
            <div id="cmMatchCount" style="font-size:.85rem;color:var(--muted);margin-bottom:.5rem;"></div>
            <label><strong>Select client:</strong>
              <select id="cmEditSelect"><option value="">Loading customers…</option></select>
            </label>
            <div id="cmMatchCount" style="font-size:.85rem;color:var(--muted);margin-top:.25rem;"></div>
          </div>

          <div class="cm-grid">
            <label><span class="label-line">First names <span class="req">*</span></span> <input name="first_names" required /></label>
            <label><span class="label-line">Last name <span class="req">*</span></span> <input name="last_name" required /></label>
            <label><span class="label-line">Email address <span class="req">*</span></span> <input name="email_address" type="email" required /></label>
            <label><span class="label-line">Cellphone number <span class="req">*</span></span> <input name="cellphone_number" required /></label>
            <label>
              <span class="label-line">ID number <span class="req">*</span></span>
              <input name="id_number" inputmode="numeric" pattern="\d{13}" title="13-digit SA ID number" required />
            </label>

            <label><span class="label-line">Trade start date</span> <input name="trade_start_date" type="date" /></label>

            <label>
              <span class="label-line">Recurrence <span class="req">*</span></span>
              <select name="recurring_contribution_frequency" required>
                <option value="None">None</option>
                <option value="Weekly">Weekly</option>
                <option value="Monthly" selected>Monthly</option>
                <option value="Annually">Annually</option>
              </select>
            </label>

            <label>
              <span class="label-line">Recurring contribution (ZAR) <span class="req" data-cm-req="freq">*</span></span>
              <input name="recurring_contribution_zar" type="number" min="0" step="0.01" />
            </label>
            <label><span class="label-line">Upfront contribution (ZAR)</span> <input name="upfront_contribution_zar" type="number" min="0" step="0.01" /></label>
            <label><span class="label-line">Upfront contribution (BTC)</span> <input name="upfront_contribution_btc" type="number" min="0" step="0.00000001" /></label>

            <label>
              <span class="label-line">Exchange name</span>
              <select name="exchange_api_name">
                <option value="">None</option>
                <option value="VALR">VALR</option>
                <option value="Binance">Binance</option>
                <option value="Luno">Luno</option>
              </select>
            </label>
            <label><span class="label-line">Exchange username</span> <input name="exchange_username" /></label>
            <label><span class="label-line">Exchange password</span> <input name="exchange_password" type="password" /></label>
            <label><span class="label-line">API key</span> <input name="exchange_api_key" /></label>
            <label><span class="label-line">API secret</span> <input name="exchange_api_secret" type="password" /></label>
            <label><span class="label-line">BTC wallet address</span> <input name="exchange_btc_wallet_address" /></label>

            <label>
              <span class="label-line">Status <span class="req">*</span></span>
              <select name="customer_status" required>
                <option value="Active">Active</option>
                <option value="Inactive">Inactive</option>
                <option value="Suspended">Suspended</option>
              </select>
            </label>
          </div>

          <div style="display:flex;gap:.5rem;margin-top:.75rem;">
            <button type="submit">Save Changes</button>
            <button type="button" id="cmDeleteBtn" style="margin-left:auto;">Delete Client</button>
          </div>
        </form>
      </div>

      <!-- Customer Onboarding Pipeline (Milestone 2: Strategy Selection) -->
      <div class="card" id="onboardingPipelineCard">
        <h3>Customer Onboarding Pipeline</h3>
        <p class="small-muted">Select strategy for prospects to move them to the next onboarding stage</p>
        <div style="display:flex;align-items:center;gap:.75rem;margin-bottom:.5rem;flex-wrap:wrap;">
          <button id="prospectsRefreshBtn" class="btn btn-secondary-sm" type="button">Refresh</button>
          <input id="prospectsSearchInput" type="text" placeholder="Search by name or email..." style="flex:1;min-width:250px;padding:.5rem;border:1px solid #dee2e6;border-radius:4px;">
          <label style="display:flex;align-items:center;gap:0.5rem;font-size:0.9rem;">
            <input type="checkbox" id="prospectsPendingOnlyCheckbox" checked>
            <span>Prospects Only</span>
          </label>
        </div>
        <div class="table-scroll" id="prospectsTableContainer">
          <table id="prospectsTable">
            <thead>
              <tr>
                <th style="min-width:80px;">ID</th>
                <th style="min-width:150px;">Name</th>
                <th style="min-width:200px;">Email</th>
                <th style="min-width:120px;">Phone</th>
                <th style="min-width:100px;">Status</th>
                <th style="min-width:140px;">Submitted</th>
                <th style="min-width:200px;">Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="7" class="muted">Loading prospects...</td></tr>
            </tbody>
          </table>
        </div>
        <div id="prospectsMessage" style="display:none;margin-top:.75rem;padding:.75rem;border-radius:4px;font-size:.9rem;"></div>
      </div>

      <!-- KYC ID Verification card -->
      <div class="card" id="kycVerificationCard">
        <h3>KYC ID Verification</h3>
        <p class="small-muted">Review and verify customer ID documents uploaded during registration.</p>
        <div style="display:flex;align-items:center;gap:.75rem;margin-bottom:.5rem;flex-wrap:wrap;">
          <button id="kycRefreshBtn" class="btn btn-secondary-sm" type="button">Refresh</button>
          <input id="kycSearchInput" type="text" placeholder="Search by name or email..." style="flex:1;min-width:250px;padding:.5rem;border:1px solid #dee2e6;border-radius:4px;">
        </div>
        <div class="table-scroll" id="kycTableContainer">
          <table id="kycTable">
            <thead>
              <tr>
                <th style="min-width:80px;">ID</th>
                <th style="min-width:150px;">Name</th>
                <th style="min-width:200px;">Email</th>
                <th style="min-width:140px;">Uploaded</th>
                <th style="min-width:150px;">Document</th>
                <th style="min-width:120px;">Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="6" class="muted">Loading KYC verifications...</td></tr>
            </tbody>
          </table>
        </div>
        <div id="kycMessage" style="display:none;margin-top:.75rem;padding:.75rem;border-radius:4px;font-size:.9rem;"></div>
      </div>

      <!-- VALR Account Setup card -->
      <div class="card" id="valrSetupCard">
        <h3>VALR Account Setup</h3>
        <p class="small-muted">Manage VALR subaccounts and deposit references. Customers at Milestone 4 (Setup) awaiting deposit reference.</p>
        <div style="display:flex;align-items:center;gap:.75rem;margin-bottom:.5rem;flex-wrap:wrap;">
          <button id="valrRefreshBtn" class="btn btn-secondary-sm" type="button">Refresh</button>
          <input id="valrSearchInput" type="text" placeholder="Search by name or email..." style="flex:1;min-width:250px;padding:.5rem;border:1px solid #dee2e6;border-radius:4px;">
        </div>
        <div class="table-scroll" id="valrTableContainer">
          <table id="valrTable">
            <thead>
              <tr>
                <th style="min-width:80px;">ID</th>
                <th style="min-width:150px;">Name</th>
                <th style="min-width:200px;">Email</th>
                <th style="min-width:200px;">Subaccount ID</th>
                <th style="min-width:150px;">Deposit Ref</th>
                <th style="min-width:180px;">Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="6" class="muted">Loading VALR setup queue...</td></tr>
            </tbody>
          </table>
        </div>
        <div id="valrMessage" style="display:none;margin-top:.75rem;padding:.75rem;border-radius:4px;font-size:.9rem;"></div>
      </div>

      <!-- Active Customers card -->
      <div class="card" id="activeCustomersCard">
        <h3>Active Customers</h3>
        <p class="small-muted">Manage active customers. Set customers to inactive status to pause trading temporarily.</p>
        <div style="display:flex;align-items:center;gap:.75rem;margin-bottom:.5rem;flex-wrap:wrap;">
          <button id="activeRefreshBtn" class="btn btn-secondary-sm" type="button">Refresh</button>
          <input id="activeSearchInput" type="text" placeholder="Search by name or email..." style="flex:1;min-width:250px;padding:.5rem;border:1px solid #dee2e6;border-radius:4px;">
        </div>
        <div class="table-scroll" id="activeTableContainer">
          <table id="activeTable">
            <thead>
              <tr>
                <th style="min-width:80px;">ID</th>
                <th style="min-width:150px;">Name</th>
                <th style="min-width:200px;">Email</th>
                <th style="min-width:100px;">Strategy</th>
                <th style="min-width:140px;">Activated</th>
                <th style="min-width:140px;">Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="6" class="muted">Loading active customers...</td></tr>
            </tbody>
          </table>
        </div>
        <div id="activeMessage" style="display:none;margin-top:.75rem;padding:.75rem;border-radius:4px;font-size:.9rem;"></div>
      </div>

      <!-- Customer Fee Management card -->
      <div class="card" id="feeManagementCard">
        <h3>Customer Fee Management</h3>
        <p class="small-muted">Adjust BitWealth fees for individual customers. Changes are effective from the beginning of the current month.</p>
        <div style="display:flex;align-items:center;gap:.75rem;margin-bottom:.5rem;flex-wrap:wrap;">
          <button id="feeRefreshBtn" class="btn btn-secondary-sm" type="button">Refresh</button>
          <input id="feeSearchInput" type="text" placeholder="Search by name or email..." style="flex:1;min-width:250px;padding:.5rem;border:1px solid #dee2e6;border-radius:4px;">
        </div>
        <div class="table-scroll" id="feeTableContainer">
          <table id="feeTable">
            <thead>
              <tr>
                <th style="min-width:80px;">ID</th>
                <th style="min-width:150px;">Name</th>
                <th style="min-width:200px;">Email</th>
                <th style="min-width:120px;">Performance Fee</th>
                <th style="min-width:120px;">Platform Fee</th>
                <th style="min-width:180px;"></th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="6" class="muted">Loading customers...</td></tr>
            </tbody>
          </table>
        </div>
        <div id="feeMessage" style="display:none;margin-top:.75rem;padding:.75rem;border-radius:4px;font-size:.9rem;"></div>
      </div>
    </div>

    <!-- ===================== Strategy Maintenance ===================== -->
    <div id="strategy-maintenance-module" class="module">
      <h2>Strategy Maintenance</h2>

      <!-- No Strategy Selected Message -->
      <div id="noStrategyMessage" style="text-align:center;padding:3rem;color:var(--muted);background:#f8f9fa;border:1px solid var(--border);border-radius:12px;margin:2rem auto;max-width:600px;">
        <svg style="width:64px;height:64px;margin:0 auto 1rem;opacity:0.3;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
        </svg>
        <h3 style="margin:0 0 0.5rem 0;color:#374151;">Select a Strategy</h3>
        <p style="margin:0;">Please select a strategy from the <strong>ACTIVE STRATEGY</strong> dropdown above to view and manage strategy variations.</p>
      </div>

      <!-- LTH PVR Strategy Panel -->
      <div id="lthPvrStrategyPanel" class="strategy-panel" data-strategy="LTH_PVR">
        <h3>LTH PVR Strategy Variations</h3>
        <p style="color:var(--muted);margin-bottom:1.5rem;">
          Manage strategy variations, run simulations, and optimize parameters.
        </p>

        <!-- Variation Cards Container -->
        <div id="variationCardsContainer" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(350px,1fr));gap:1.5rem;margin-bottom:2rem;">
          <!-- Variations loaded dynamically -->
          <div style="grid-column:1/-1;text-align:center;padding:2rem;color:var(--muted);">
            Loading variations...
          </div>
        </div>

        <!-- Simulation Controls (Hidden by default) -->
        <div id="simulationControls" class="card" style="display:none;max-width:800px;margin:2rem auto;">
          <h3>Run Simulation</h3>
          <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:1rem;margin-bottom:1rem;">
            <div>
              <label for="simStartDate" style="display:block;margin-bottom:.25rem;font-size:.9rem;">Start Date:</label>
              <input id="simStartDate" type="date" style="width:100%;height:var(--control-height);border-radius:var(--control-radius);border:1px solid var(--border);padding:0 var(--control-pad-x);" />
            </div>
            <div>
              <label for="simEndDate" style="display:block;margin-bottom:.25rem;font-size:.9rem;">End Date:</label>
              <input id="simEndDate" type="date" style="width:100%;height:var(--control-height);border-radius:var(--control-radius);border:1px solid var(--border);padding:0 var(--control-pad-x);" />
            </div>
            <div>
              <label for="simUpfront" style="display:block;margin-bottom:.25rem;font-size:.9rem;">Upfront Investment ($):</label>
              <input id="simUpfront" type="number" min="0" step="1000" value="10000" style="width:100%;height:var(--control-height);border-radius:var(--control-radius);border:1px solid var(--border);padding:0 var(--control-pad-x);" />
            </div>
            <div>
              <label for="simMonthly" style="display:block;margin-bottom:.25rem;font-size:.9rem;">Monthly Contribution ($):</label>
              <input id="simMonthly" type="number" min="0" step="100" value="500" style="width:100%;height:var(--control-height);border-radius:var(--control-radius);border:1px solid var(--border);padding:0 var(--control-pad-x);" />
            </div>
          </div>
          <div style="display:flex;gap:.75rem;justify-content:center;">
            <button id="runSimBtn" type="button" style="padding:.75rem 1.5rem;background:#3b82f6;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;">Run Simulation</button>
            <button id="cancelSimBtn" type="button" style="padding:.75rem 1.5rem;background:#6b7280;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;">Cancel</button>
          </div>
        </div>

        <!-- Simulation Results Panel (Hidden by default) -->
        <div id="simulationResultsPanel" class="card" style="display:none;max-width:1000px;margin:2rem auto;">
          <!-- Results populated dynamically -->
        </div>

        <!-- Optimization Controls (Hidden by default) -->
        <div id="optimizationModal" class="card" style="display:none;max-width:900px;margin:2rem auto;position:relative;">
          <button onclick="window.strategyMaintenance.closeOptimizationModal()" type="button" style="position:absolute;top:1rem;right:1rem;background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--muted);">&times;</button>
          
          <h3>Optimize Strategy Parameters</h3>
          <p style="color:var(--muted);margin-bottom:1.5rem;">
            Configure parameter ranges for grid search optimization. The optimizer will test all combinations to find the best configuration.
          </p>

          <input type="hidden" id="optVariationId">
          <input type="hidden" id="optVariationName">

          <div style="display:grid;gap:1.5rem;">
            <!-- Objective Selection -->
            <div>
              <label style="display:block;margin-bottom:.5rem;font-weight:600;">Optimization Objective:</label>
              <select id="optObjective" class="context-select" style="width:100%;">
                <option value="nav">Final NAV (Maximize absolute returns)</option>
                <option value="cagr" selected>CAGR (Maximize compound growth rate)</option>
                <option value="roi">Total ROI (Maximize return percentage)</option>
                <option value="sharpe">Sharpe Ratio (Maximize risk-adjusted returns)</option>
              </select>
            </div>

            <!-- Date Range & Contributions -->
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:1rem;">
              <div>
                <label style="display:block;margin-bottom:.25rem;font-size:.9rem;">Start Date:</label>
                <input id="optStartDate" type="date" style="width:100%;height:var(--control-height);border-radius:var(--control-radius);border:1px solid var(--border);padding:0 var(--control-pad-x);" />
              </div>
              <div>
                <label style="display:block;margin-bottom:.25rem;font-size:.9rem;">End Date:</label>
                <input id="optEndDate" type="date" style="width:100%;height:var(--control-height);border-radius:var(--control-radius);border:1px solid var(--border);padding:0 var(--control-pad-x);" />
              </div>
              <div>
                <label style="display:block;margin-bottom:.25rem;font-size:.9rem;">Upfront ($):</label>
                <input id="optUpfront" type="number" min="0" step="1000" value="10000" style="width:100%;height:var(--control-height);border-radius:var(--control-radius);border:1px solid var(--border);padding:0 var(--control-pad-x);" />
              </div>
              <div>
                <label style="display:block;margin-bottom:.25rem;font-size:.9rem;">Monthly ($):</label>
                <input id="optMonthly" type="number" min="0" step="100" value="500" style="width:100%;height:var(--control-height);border-radius:var(--control-radius);border:1px solid var(--border);padding:0 var(--control-pad-x);" />
              </div>
            </div>

            <!-- Parameter Ranges -->
            <div>
              <label style="display:block;margin-bottom:.5rem;font-weight:600;">Parameter Ranges to Optimize:</label>
              <div style="background:#f8f9fa;border:1px solid var(--border);border-radius:8px;padding:1rem;">
                <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:.75rem;font-size:.9rem;">
                  <div>
                    <label style="display:block;margin-bottom:.25rem;color:var(--muted);">B1 Range (min, max, step):</label>
                    <input id="optB1Range" type="text" placeholder="0.20, 0.24, 0.01" style="width:100%;height:36px;border-radius:6px;border:1px solid var(--border);padding:0 8px;" />
                  </div>
                  <div>
                    <label style="display:block;margin-bottom:.25rem;color:var(--muted);">B2 Range:</label>
                    <input id="optB2Range" type="text" placeholder="0.19, 0.23, 0.01" style="width:100%;height:36px;border-radius:6px;border:1px solid var(--border);padding:0 8px;" />
                  </div>
                  <div style="grid-column:1/-1;">
                    <label style="display:flex;align-items:center;gap:.5rem;margin-bottom:.5rem;">
                      <input type="checkbox" id="optUseSmartRanges" checked />
                      <span style="font-weight:500;">Use Smart Ranges</span>
                      <span style="color:var(--muted);font-size:.85rem;">(±20% from current config, 3 points per parameter)</span>
                    </label>
                  </div>
                  <div style="grid-column:1/-1;font-size:.85rem;color:var(--muted);padding:.5rem;background:#fff;border-radius:6px;">
                    <strong>Note:</strong> Leave ranges blank to keep current values. Estimated combinations will be shown before running.
                  </div>
                </div>
              </div>
            </div>

            <!-- Action Buttons -->
            <div style="display:flex;gap:.75rem;justify-content:center;">
              <button id="runOptBtn" type="button" style="padding:.75rem 2rem;background:#10b981;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;font-weight:600;">Start Optimization</button>
              <button onclick="window.strategyMaintenance.closeOptimizationModal()" type="button" style="padding:.75rem 2rem;background:#6b7280;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;">Cancel</button>
            </div>
          </div>
        </div>

        <!-- Optimization Results Panel (Hidden by default) -->
        <div id="optimizationResultsPanel" class="card" style="display:none;max-width:1200px;margin:2rem auto;">
          <!-- Results populated dynamically -->
        </div>

        <!-- Parameter History Modal (Hidden by default) -->
        <div id="parameterHistoryModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:9999;overflow:auto;">
          <div style="background:#fff;border-radius:12px;max-width:1200px;margin:2rem auto;padding:2rem;position:relative;">
            <button onclick="window.strategyMaintenance.closeHistoryModal()" type="button" style="position:absolute;top:1rem;right:1rem;background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--muted);">&times;</button>
            
            <h3 style="margin:0 0 0.5rem;">Parameter History: <span id="historyVariationName"></span></h3>
            <p style="color:var(--muted);font-size:.9rem;margin-bottom:1.5rem;">View and restore previous parameter configurations</p>
            
            <div id="historyTableContainer" style="overflow-x:auto;">
              <table style="width:100%;border-collapse:collapse;font-size:.85rem;">
                <thead>
                  <tr style="background:#f8f9fa;">
                    <th style="padding:.75rem;text-align:left;border:1px solid var(--border);">Date</th>
                    <th style="padding:.75rem;text-align:left;border:1px solid var(--border);">Changed By</th>
                    <th style="padding:.75rem;text-align:left;border:1px solid var(--border);">Type</th>
                    <th style="padding:.75rem;text-align:left;border:1px solid var(--border);">B1</th>
                    <th style="padding:.75rem;text-align:left;border:1px solid var(--border);">B6</th>
                    <th style="padding:.75rem;text-align:left;border:1px solid var(--border);">Bear Exit</th>
                    <th style="padding:.75rem;text-align:left;border:1px solid var(--border);">Momentum</th>
                    <th style="padding:.75rem;text-align:left;border:1px solid var(--border);">Actions</th>
                  </tr>
                </thead>
                <tbody id="historyTableBody">
                  <!-- Populated by loadParameterHistory() -->
                </tbody>
              </table>
            </div>
            
            <div style="display:flex;gap:.75rem;justify-content:center;margin-top:1.5rem;">
              <button onclick="window.strategyMaintenance.closeHistoryModal()" type="button" style="padding:.75rem 1.5rem;background:#6b7280;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;">Close</button>
            </div>
          </div>
        </div>
      </div>

      <!-- ADV_DCA Strategy Panel (Future) -->
      <div id="advDcaStrategyPanel" class="strategy-panel" data-strategy="ADV_DCA">
        <h3>Advanced DCA Strategy</h3>
        <p style="color:var(--muted);">Coming soon...</p>
      </div>
    </div>

    <!-- ===================== Import Daily Data ===================== -->
    <div id="import-module" class="module">
      <h2>Import Daily Data</h2>
      <div id="inlineError"></div>
      <p>
        <label>Select CSV file:
          <input type="file" id="csvFileInput" accept=".csv" />
        </label>
        <button id="previewBtn" type="button">Preview</button>
      </p>
      <div id="preview"></div>
      <button id="importBtn" type="button" style="display:none;">Confirm Import</button>
      <div id="report"></div>
    </div>

    <!-- ===================== Customer Balance Maintenance ===================== -->
    <div id="balance-maintenance-module" class="module">
      <h2>Customer Balance Maintenance</h2>

      <!-- Exchange Balances (uses GLOBAL customer selection in the context bar) -->
      <hr class="section-sep">
      <h3 class="subhead">Exchange Balances</h3>

      <div class="reports-controls-outer">
        <div class="reports-controls">
          <div style="grid-column:1 / -1; color:#6b7280; font-size:12px;">
            Using the <strong>Customer</strong> selected in the top context bar.
          </div>

          <label for="retFrom"><strong>From:</strong></label>
          <button id="fetchBalancesBtn" type="button">Show exchange balances</button>
        </div>
      </div>

      <div class="card" id="balancesCard" style="display:none;max-width:1000px;margin:0 auto;">
        <h3>Exchange Balances</h3>
        <table class="details-table">
          <thead><tr><th>Asset</th><th>Available</th><th>Reserved</th></tr></thead>
          <tbody id="balancesTbody"></tbody>
        </table>
        <div style="display:flex;gap:.5rem;justify-content:center;margin-top:.75rem;flex-wrap:wrap;">
          <button id="refreshBalancesBtn" type="button">Refresh</button>
          <button id="hideBalancesBtn" type="button">Hide</button>
          <button id="convertZarBtn" type="button" disabled>Convert ZAR → USDT</button>
        </div>
      </div>

      <div id="balancesError"></div>

      <div class="card" data-strategy="ADV_DCA" style="max-width:1200px">
        <h3 class="chart-title">Real Exchange Transactions</h3>

        <div class="reports-controls-outer">
          <div class="reports-controls">
            <label for="retFrom"><strong>From:</strong></label>
            <input id="retFrom" type="date" />
            <label for="retTo"><strong>To:</strong></label>
            <input id="retTo" type="date" />
          </div>
        </div>

        <div class="tx-toolbar" style="justify-content:center;gap:.5rem;margin-top:.5rem;">
          <button id="retSyncBtn"  type="button">Sync trades from exchange</button>
          <button id="retLoadBtn"  type="button">Load from DB</button>
          <label style="display:inline-flex;align-items:center;gap:.4rem;">
            <input id="retOnlyUnalloc" type="checkbox"> Only unallocated USDT deposits
          </label>
          <select id="retAllocMonth" title="Allocate selected deposits to month (YYYY-MM)" disabled></select>
          <button id="retAllocBtn" type="button" disabled>Allocate selected</button>
        </div>

        <div class="run-status" style="text-align:center;margin-top:.35rem;color:#6b7280">
          <span id="retStatus">Idle</span>
        </div>

        <div id="retWrap" style="display:none;margin-top:.75rem;max-height:360px;overflow:auto;border:1px solid #eee;border-radius:8px">
          <table style="width:100%;border-collapse:collapse;font:12px system-ui">
            <thead>
              <tr>
                <th style="text-align:left;padding:6px;">Date (UTC)</th>
                <th>Type</th>
                <th>Pair</th>
                <th>Debit</th>
                <th>Debit value</th>
                <th>Credit</th>
                <th>Credit value</th>
                <th>Fee</th>
                <th>Price</th>
                <th>Order id</th>
                <th>Classification</th>
                <th>Allocated</th>
                <th><input type="checkbox" id="retCheckAll"></th>
              </tr>
            </thead>
            <tbody id="retBody"></tbody>
          </table>
        </div>
        <div class="tx-toolbar" style="justify-content:center;gap:.5rem;margin-top:.5rem;">
          <button id="retDriftBtn" type="button">Load balance drift (ledger vs snapshots)</button>
        </div>

        <div id="retDriftWrap" style="display:none;margin-top:.5rem;max-height:260px;overflow:auto;border:1px solid #eee;border-radius:8px">
          <table style="width:100%;border-collapse:collapse;font:12px system-ui">
            <thead>
              <tr>
                <th style="text-align:left;padding:6px;">Day (UTC)</th>
                <th>Observed USDT Δ</th>
                <th>Expected USDT Δ</th>
                <th>Drift USDT</th>
                <th>Observed BTC Δ</th>
                <th>Expected BTC Δ</th>
                <th>Drift BTC</th>
                <th>Observed ZAR Δ</th>
                <th>Expected ZAR Δ</th>
                <th>Drift ZAR</th>
              </tr>
            </thead>
            <tbody id="retDriftBody"></tbody>
          </table>
        </div>
      </div>

      <!-- LTH PVR BTC DCA – Ledger & Balances (skeleton for future wiring) -->
      <div class="card strategy-hidden" data-strategy="LTH_PVR" style="max-width:1200px; margin-top:14px">
        <h3 class="chart-title">LTH PVR – Ledger &amp; Balances</h3>

        <div class="reports-controls-outer">
          <div class="reports-controls">
            <label for="lthFrom"><strong>From:</strong></label>
            <input id="lthFrom" type="date" />
            <label for="lthTo"><strong>To:</strong></label>
            <input id="lthTo" type="date" />
          </div>
        </div>

        <div class="tx-toolbar" style="justify-content:center; gap:.5rem; margin-top:.5rem;">
          <button id="lthLoadBtn" type="button">
            Load from DB
          </button>
          <button id="lthRecalcBtn" type="button">
            Recalculate balances
          </button>
        </div>

        <div class="run-status" style="text-align:center; margin-top:.35rem; color:#6b7280">
          <span id="lthStatus">Idle</span>
        </div>

        <div id="lthTableWrap" style="display:none;margin-top:.75rem;max-height:360px;overflow:auto;border:1px solid #eee;border-radius:8px">
          <table style="width:100%;border-collapse:collapse;font:12px system-ui">
            <thead>
              <tr>
                <th style="text-align:left;padding:6px;">Date (UTC)</th>
                <th>Event type</th>
                <th>BTC Δ</th>
                <th>USDT Δ</th>
                <th>Note</th>
              </tr>
            </thead>
            <tbody id="lthBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- ===================== Customer Transactions ===================== -->
    <div id="transactions-module" class="module">
      <h2>Customer Transactions</h2>

      <div id="txAdvDcaBlock" data-strategy="ADV_DCA">

      <hr class="section-sep">
      <h3 class="subhead">Run Daily Rules</h3>

      <section id="daily-rules-runner" data-strategy="ADV_DCA" style="max-width:980px;margin:0 auto;">
        <div class="card">
          <h3>Create Daily Rules</h3>
          <p class="muted">Generate today’s buy/sell rules for all customers.</p>

          <div class="run-toolbar">
            <button id="runRulesBtn" type="button">Run Daily Rules</button>

            <label>
              <input id="dryRunChk" type="checkbox" checked> Dry run
            </label>

            <label>
              Preview limit
              <input id="previewLimit" type="number" value="100" min="1" max="5000" style="width:6rem">
            </label>

            <label>
              Force from date
              <input id="forceFrom" type="date" style="width:10rem">
            </label>

            <span id="rulesStatus">Idle</span>
          </div>

          <pre id="rulesSummary" style="margin-top:.5rem;white-space:pre-wrap;font:12px ui-monospace"></pre>

          <div id="rulesPreview" style="display:none;margin-top:.5rem;max-height:300px;overflow:auto;border:1px solid #eee;border-radius:8px">
            <table style="width:100%;border-collapse:collapse;font:12px system-ui">
              <thead id="rulesHead"></thead>
              <tbody id="rulesBody"></tbody>
            </table>
          </div>
        </div>
      </section>

      <hr class="section-sep">

      <h3 class="subhead">Create Real Orders (VALR)</h3>
      <div class="card" id="realOrdersCard">
        <div class="tx-toolbar" style="justify-content:center; gap:.75rem; flex-wrap:wrap;">
          <button id="previewIntentsBtn" type="button">Preview Orders</button>
          <button id="executeIntentsBtn" type="button" disabled>Execute Orders</button>
        </div>

        <div class="run-status"><span id="intentsStatus">Idle</span></div>

        <div id="intentsTableWrap" style="display:none;margin-top:.5rem;max-height:360px;overflow:auto;border:1px solid #eee;border-radius:8px">
          <table style="width:100%;border-collapse:collapse;font:12px system-ui">
            <thead id="intentsHead"></thead>
            <tbody id="intentsBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Executed orders (collapsible) -->
      <details id="executedDetails" class="executed-collapsible">
        <summary>
          Already executed in the last 7 days <span class="count">(0)</span>
        </summary>
        <div id="executedList" class="executed-list">No executed orders in the last 7 days.</div>
      </details>

      <!-- Placed orders (collapsible) -->
      <details id="placedDetails" class="executed-collapsible" style="margin-top:.5rem;">
        <summary>
          Placed orders (last 24h) <span class="count">(0)</span>
        </summary>
        <div id="placedList" class="executed-list">No placed orders yet.</div>
      </details>

      </div> <!-- /#txAdvDcaBlock -->

      <div class="card" id="livePreviewCard" data-strategy="LTH_PVR">
        <h3 class="chart-title">Preview Live Customer Transactions</h3>
        <p class="chart-notice" style="display:block">
          Coming soon — we’ll show the latest executed buys/sells and balance changes for the selected customer.
        </p>
      </div>
    </div>
    <script>
    (() => {

      // ---- Configure once ----
      const SUPABASE_URL = "https://wqnmxpooabmedvtackji.supabase.co";
      const EDGE_FUNCTION = "create-daily-rules";
      const AUTH_HEADERS = {}; // add anon key headers here only if your function requires JWT

      // ---- Scope to the Customer Transactions module only ----
      const root = document.querySelector('#transactions-module #daily-rules-runner');
      if (!root) return; // not on this view or DOM not rendered yet

      // Query ONLY inside this module (no global lookups)
      const q = (s) => root.querySelector(s);
      const runBtn         = q('#runRulesBtn');
      if (!runBtn) return; // safety
      const dryRunChk      = q('#dryRunChk');
      const previewLimitEl = q('#previewLimit');
      const forceFromEl    = q('#forceFrom');
      const statusEl       = q('#rulesStatus');
      const summaryEl      = q('#rulesSummary');
      const theadEl        = q('#rulesHead');
      const tbodyEl        = q('#rulesBody');
      const previewWrap    = q('#rulesPreview');

      async function callCreateDailyRules({ dryRun, previewLimit, forceFromDate }) {
        // If your function expects snake_case, map them here:
        const payload = {
          dry_run: dryRun,
          preview_limit: previewLimit,
          force_from_date: forceFromDate || null
        };

        const { data, error } = await window.supabaseClient.functions.invoke('create-daily-rules', {
          body: payload
        });
        if (error) throw new Error(error.message || 'Edge Function error');
        return data;
      }

      function renderPreview(rows) {
        if (!rows || !rows.length) { previewWrap.style.display = 'none'; return; }

        // Build columns from the union of keys across all rows
        let cols = Array.from(
          rows.reduce((set, r) => {
            Object.keys(r || {}).forEach(k => set.add(k));
            return set;
          }, new Set())
        );
        const HIDE = new Set(['opening_balance_btc','opening_balance_usdt']);
        cols = cols.filter(c => !HIDE.has(c));

        // Optional: keep sab_price_below_buy_signal next to sab_buy_signal
        const moveAfter = (list, key, after) => {
          const i = list.indexOf(key), j = list.indexOf(after);
          if (i > -1 && j > -1) { list.splice(i, 1); list.splice(j + 1, 0, key); }
        };
        moveAfter(cols, 'sab_price_below_buy_signal', 'sab_buy_signal');

        theadEl.innerHTML =
          '<tr>' +
          cols.map(c => `<th style="border-bottom:1px solid #eee;text-align:left;padding:6px 8px;background:#f8fafc">${c}</th>`).join('') +
          '</tr>';

        tbodyEl.innerHTML =
          rows.map(r =>
            '<tr>' +
            cols.map(c => `<td style="border-bottom:1px solid #f1f5f9;padding:6px 8px">${(r[c] ?? '')}</td>`).join('') +
            '</tr>'
          ).join('');

        previewWrap.style.display = 'block';
      }

      runBtn.addEventListener('click', async () => {
        summaryEl.textContent = '';
        renderPreview([]);
        statusEl.textContent = 'Running…';

        const dryRun   = !!dryRunChk?.checked;
        const limitVal = Number(previewLimitEl?.value) || 100;
        const fromVal  = forceFromEl?.value || null;

        try {
          const j = await callCreateDailyRules({ dryRun, previewLimit: limitVal, forceFromDate: fromVal });

          const lines = [];
          lines.push(`customers: ${j.customers ?? 0}`);
          if ('eligible' in j)     lines.push(`eligible daily rows: ${j.eligible}`);
          if ('to_insert' in j)    lines.push(`rules to insert: ${j.to_insert}`);
          if ('inserted' in j)     lines.push(`inserted: ${j.inserted}`);
          if (j.preview_truncated) lines.push(`preview truncated: true`);
          if (j.debug?.globalFrom) lines.push(`globalFrom: ${j.debug.globalFrom}`);

          summaryEl.textContent = lines.join('\n');
          renderPreview(j.preview);
          statusEl.textContent = dryRun ? 'Dry run complete' : 'Completed';
          document.dispatchEvent(new CustomEvent('daily-rules:completed'));

          if (!dryRun) {
            const yday = (()=>{
              const d=new Date(Date.now()-86400000); return d.toISOString().slice(0,10);
            })();

            // Build ADVANCED (sim)
            statusEl.textContent = 'Rules done — building ADV transactions…';
            try {
              const { data, error } = await supabaseClient.functions.invoke('adv-build-transactions', {
                body: { for_date: yday }
              });
              if (error || data?.error) {
                const msg = data?.error || error?.message || (error && JSON.stringify(error)) || 'Unknown error';
                throw new Error(msg);
              }

              statusEl.textContent = `ADV transactions built (${data?.totalRows ?? 0}).`;
            } catch (e) {
              console.error(e);
              statusEl.textContent = `ADV build failed: ${e.message || e}`;
            }

            // Build STANDARD DCA benchmark (sim)
            statusEl.textContent = 'Building STANDARD DCA benchmark…';
            try {
              const { data, error } = await supabaseClient.functions.invoke('std-build-transactions', {
                body: { for_date: yday }
              });
              if (error || data?.error) {
                const msg = data?.error || error?.message || (error && JSON.stringify(error)) || 'Unknown error';
                throw new Error(msg);
              }
              statusEl.textContent = `STANDARD DCA built (${data?.totalRows ?? 0}).`;
            } catch (e) {
              console.error(e);
              statusEl.textContent = `STANDARD DCA build failed: ${e.message || e}`;
            }
          }

        } catch (e) {
          statusEl.textContent = 'Error';
          summaryEl.textContent = String(e.message || e);
        }
      });
    })();
    </script>

    <!-- ANCHOR: Real Orders (VALR) JS START -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
      const sb = () => {
        const c = window.supabaseClient;
        if (!c) throw new Error('Supabase not ready');
        return c;
    };

    // shared poll state across runs (so resume listeners always see the latest)
    window._valrPollState = window._valrPollState || {
      polling: false,
      lastPollBody: null,
      resume: null,          // set to the latest pollLoop function each execution
    };
    
    // refresh Placed (last 24h) on load (wait for Supabase)
    const whenSbReady = async () => {
      const start = Date.now();
      while (!window.supabaseClient) {
        await new Promise(r => setTimeout(r, 50));
        if (Date.now() - start > 8000) return; // give up silently
      }
    };
    // Don't auto-load on init - wait for authentication
    // Auth state handler will trigger this if needed
    whenSbReady().then(async () => {
      if (window.supabaseClient) {
        const { data: { session } } = await window.supabaseClient.auth.getSession();
        if (session?.user) {
          loadPlaced24h().then(renderPlaced).catch(console.warn);
        }
      }
    });

    const el = (id) => document.getElementById(id);

    const previewBtn = el('previewIntentsBtn');
    const executeBtn = el('executeIntentsBtn');
    if (previewBtn) previewBtn.disabled = false;
    if (executeBtn) executeBtn.disabled = true;
    const statusEl   = el('intentsStatus');
    const tableWrap  = el('intentsTableWrap');
    const headEl     = el('intentsHead');
    const bodyEl     = el('intentsBody');

    // New panels
    const placedWrap = el('placedDetails');
    const placedList = el('placedList');

    // --- Toast (non-blocking) ---
    function showToast(msg, ms = 2200) {
      let box = document.getElementById('toastBox');
      if (!box) {
        box = document.createElement('div');
        box.id = 'toastBox';
        Object.assign(box.style, {
          position: 'fixed', right: '14px', bottom: '14px', zIndex: 99999,
          display: 'flex', flexDirection: 'column', gap: '8px'
        });
        document.body.appendChild(box);
      }
      const t = document.createElement('div');
      t.textContent = msg;
      Object.assign(t.style, {
        background: '#111827', color: 'white', padding: '8px 12px',
        borderRadius: '8px', boxShadow: '0 6px 18px rgba(0,0,0,.18)',
        font: '12px system-ui', maxWidth: '72vw', opacity: '0.98'
      });
      box.appendChild(t);
      setTimeout(() => {
        t.style.transition = 'opacity .25s ease';
        t.style.opacity = '0';
        setTimeout(() => t.remove(), 260);
      }, ms);
    }

    function ydayUTC() {
      const d = new Date(Date.now() - 86_400_000);
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2,'0');
      const day = String(d.getUTCDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function todayUTC() {
      const d = new Date();
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2,'0');
      const day = String(d.getUTCDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function getForDate() { return ydayUTC(); }

    function pill(status, meta = {}) {
      const s = String(status || '').toLowerCase();
      // Accept both snake_case and camelCase from the EF
      const filled = meta.filled_qty ?? meta.filledQuantity;
      const orig   = meta.orig_qty   ?? meta.originalQuantity;

      if (s === 'partially_filled' && filled != null && orig != null) {
        const f = Number(filled), o = Number(orig);
        if (o > 0 && f >= o) return `<span class="status-pill filled">filled</span>`;
        // show progress: partial f/o
        const fTxt = (''+f);
        const oTxt = (''+o);
        return `<span class="status-pill partially_filled">partial ${fTxt}/${oTxt}</span>`;
      }

      const labelMap = { partially_filled: 'partial', partial: 'partial' };
      const text = labelMap[s] || s || '—';
      const cls  = `status-pill ${s.replace(/\s+/g,'_')}`;
      return `<span class="${cls}">${text}</span>`;
    }

    // ====== PREVIEW TABLE ======
    function renderIntentsTable(rows) {
      tableWrap.style.display = 'block';

      const cols = [
        'intent_id','customer_id','symbol','side',
        'intent_btc','intent_usdt','intent_price',
        'source_signal', 'status', 'live', 'notes'
      ];

      headEl.innerHTML = `<tr>${
        cols.map(c => `<th style="text-align:left;background:#f8fafc;padding:.4rem;border-bottom:1px solid #eee">${c.replace(/_/g,' ')}</th>`).join('')
      }</tr>`;

      if (!Array.isArray(rows) || !rows.length) {
        bodyEl.innerHTML = '<tr><td colspan="11" style="padding:.6rem;color:#6b7280">No orders for this date.</td></tr>';
        return;
      }

      bodyEl.innerHTML = rows.map(r => {
        const id  = r.intent_id ?? '';
        const s   = String(r.status || '').toLowerCase();
        const canCancel = ['submitted','executing','partially_filled'].includes(s);

        return `
          <tr data-id="${id}">
            <td>${id}</td>
            <td>${r.customer_id ?? ''}</td>
            <td>${r.symbol ?? ''}</td>
            <td>${r.side ?? ''}</td>
            <td>${Number(r.intent_btc ?? 0)}</td>
            <td>${Number(r.intent_usdt ?? 0)}</td>
            <td>${Number(r.intent_price ?? 0)}</td>
            <td>${r.source_signal ?? ''}</td>
            <td class="status-cell">${r.status ?? ''}</td>
            <td class="live-cell">
              <span class="pill">${pill(s)}</span>
              ${canCancel ? `<button class="cancel-btn" data-cancel="${id}" style="margin-left:.4rem">Cancel</button>` : ''}
            </td>
            <td>${r.notes ?? ''}</td>
          </tr>
        `;
      }).join('');
    }

    async function loadPreviewRows(forDate) {
      const { data, error } = await sb()
        .from('exchange_order_intents')
        .select('*')
        .eq('date_closing', forDate)
        .order('intent_id', { ascending: true });
      if (error) throw error;
      return data || [];
    }

    // ====== PLACED ORDERS (submitted/executing/filled/cancelled/error) ======
    async function loadPlaced24h() {
      // Check if authenticated
      if (!window.supabaseClient) return [];
      const { data: { session } } = await window.supabaseClient.auth.getSession();
      if (!session?.user) {
        console.warn('[Placed Orders] Not authenticated, skipping load');
        return [];
      }
      
      const start = new Date(Date.now() - 24*60*60*1000).toISOString();
      const { data, error } = await sb()
        .from('exchange_order_intents')
        .select('intent_id,created_at,date_closing,symbol,side,intent_btc,intent_usdt,intent_price,status,notes')
        .in('status', ['submitted','executing','partially_filled','filled','cancelled','error'])
        .gte('created_at', start)
        .order('created_at', { ascending: false });
      if (error) { console.warn(error); return []; }
      return data || [];
    }

    function renderPlaced(rows) {
      if (!placedWrap || !placedList) return;
      const cnt = placedWrap.querySelector('.count');
      if (cnt) cnt.textContent = `(${rows.length})`;

      if (!rows.length) {
        placedList.textContent = 'No placed orders yet.';
        return;
      }

      placedList.innerHTML = rows.map(r => {
        const when = new Date(r.created_at);
        const d = when.toISOString().slice(0,10);
        const t = when.toLocaleTimeString([], { hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' });
        const s = String(r.status || '').toLowerCase();
        const canCancel = ['submitted','executing','partially_filled'].includes(s);
        return `
          <div class="row" data-id="${r.intent_id}">
            <div>on <strong>${d}</strong> at <strong>${t}</strong></div>
            <div>${String(r.symbol).toUpperCase()}</div>
            <div>${String(r.side).toUpperCase()}</div>
            <div>qty ₿ ${Number(r.intent_btc ?? 0)}</div>
            <div>qty ₮ ${Number(r.intent_usdt ?? 0)}</div>
            <div>@ ${Number(r.intent_price ?? 0)}</div>
            <div class="pill">${pill(s)}</div>
            ${canCancel ? `<button class="cancel-btn" data-cancel="${r.intent_id}">Cancel</button>` : ''}
            ${r.notes ? `<div class="muted">(${r.notes})</div>` : ''}
          </div>
        `;
      }).join('');
    }

    // Expose globally for auth handler
    window.loadPlaced24h = loadPlaced24h;
    window.renderPlaced = renderPlaced;

    // Delegate cancel clicks (both in table and placed panel)
    document.addEventListener('click', async (e) => {
      const btn = e.target instanceof Element ? e.target.closest('.cancel-btn') : null;
      if (!btn) return;
      const iid = btn.getAttribute('data-cancel');
      if (!iid) return;
      if (!confirm(`Cancel order for intent ${iid}?`)) return;

      let success = false;
      try {
        // prevent double-submits immediately
        btn.setAttribute('disabled','true');

        const { data, error } = await sb().functions.invoke('valr-execute-orders', {
          body: { cancel_intent_id: iid }
        });
        if (error || data?.error) throw new Error(data?.error || error?.message || 'Cancel failed');
        success = true;

        // remember submitted ids from the execute response for consistent polling/resume
        window._lastSubmittedIds = (data?.submitted_intents || []).map(x => String(x.intent_id));

        // Refresh pills & lists
        const forDate = getForDate();
        const rows = await loadPreviewRows(forDate);
        renderIntentsTable(rows);
        const placed = await loadPlaced24h();
        renderPlaced(placed);
        statusEl.textContent = 'Cancelled';

        // ✅ toast on success (non-blocking)
        showToast('Order cancelled');

        // keep the clicked button disabled to avoid double-cancel; it will
        // disappear on the next render for this row (non-cancellable states)
      } catch (err) {
        console.error(err);
        alert('Cancel failed: ' + (err?.message || err));
      } finally {
        // Only re-enable on failure (so user can retry)
        if (!success) btn.removeAttribute('disabled');
      }
    });

    // ===== PREVIEW =====
    previewBtn?.addEventListener('click', async () => {
      const forDate = getForDate();
      try {
        previewBtn.disabled = true;
        executeBtn.disabled = true;
        statusEl.textContent = 'Building preview…';

        // optional: refresh executed & placed
        const placed = await loadPlaced24h();
        renderPlaced(placed);

        const { data, error } = await sb().functions.invoke('valr-preview-orders', { body: { for_date: forDate } });
        if (error || data?.error) throw new Error(data?.error || error?.message || 'Preview failed');

        const rows = await loadPreviewRows(forDate);
        renderIntentsTable(rows);
        statusEl.textContent = rows.length ? 'Preview ready' : 'No orders for this date';

        const hasPreview = rows.some(r => (String(r.status || '')).toLowerCase() === 'preview');
        executeBtn.disabled = !hasPreview;

        // also refresh executed collapsible (existing function in your file)
        try {
          const now = new Date();
          const start7 = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - 7, 0, 0, 0)).toISOString();
          const { data: executedRows } = await sb()
            .from('exchange_order_intents')
            .select('intent_id,date_closing,created_at,symbol,source_signal,side,intent_btc,intent_usdt,intent_price,status,notes')
            .in('status', ['filled','cancelled','error'])
            .gte('created_at', start7)
            .order('created_at', { ascending: false });
          // reuse your existing renderExecuted from earlier block
          if (window.renderExecuted) window.renderExecuted(executedRows || []);
        } catch {}
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Error: ' + (e?.message || e);
        headEl.innerHTML = '';
        bodyEl.innerHTML = '';
      } finally {
        previewBtn.disabled = false;
      }
    });

    // ===== EXECUTE =====
    executeBtn?.addEventListener('click', async () => {
      try {
        executeBtn.disabled = true;
        previewBtn.disabled  = true;

        const forDate = getForDate();

        // Guard
        const rowsNow = await loadPreviewRows(forDate);
        const hasPreview = rowsNow.some(r => String(r.status || '').toLowerCase() === 'preview');
        if (!hasPreview) {
          const statuses = [...new Set(rowsNow.map(r => String(r.status || '').toLowerCase()))].join(', ');
          statusEl.textContent = rowsNow.length
            ? `Nothing to execute — intents are ${statuses}.`
            : 'Nothing to execute — no intents for this date.';
          previewBtn.disabled = false;
          executeBtn.disabled = false;
          return;
        }

        statusEl.textContent = 'Submitting orders…';
        // reuse the forDate defined above
        const { data, error } = await sb().functions.invoke('valr-execute-orders', {
          body: { for_date: forDate }
        });
        
        // Check for errors BEFORE proceeding
        if (error || data?.error) {
          console.error('[Execute Orders] Error:', error, data);
          throw new Error(data?.error || error?.message || error?.toString() || 'Execute failed');
        }
        
        const rowsAfterExec = await loadPreviewRows(forDate);
        renderIntentsTable(rowsAfterExec);
        
        // Check if any orders failed with signature errors
        const signatureErrors = rowsAfterExec.filter(r => 
          r.status === 'error' && 
          (r.notes || '').toLowerCase().includes('invalid signature')
        );
        
        if (signatureErrors.length > 0) {
          const errorMsg = `Warning: ${signatureErrors.length} order(s) failed due to invalid VALR API credentials.\n\n` +
            'The VALR API key/secret appear to be incorrect or have been regenerated.\n\n' +
            'Please update the VALR credentials in Customer Management.';
          alert(errorMsg);
          statusEl.textContent = `${data?.submitted || 0} submitted, ${signatureErrors.length} failed (invalid credentials)`;
        }

        // Show placed orders panel
        const placed = await loadPlaced24h();
        renderPlaced(placed);
        placedWrap.open = true;

        statusEl.textContent = 'Submitted. Polling…';
        try { await window.loadExecutedOrders(); } catch {}

        // keep last poll request so we can resume on focus/visibility
        let _polling = false;
        let _lastPollBody = null;

        // allow an override body when resuming
        async function pollLoop(pollBodyOverride) {
          // hand the latest loop to global state so resume listeners call THIS run
          window._valrPollState.resume = (override) => pollLoop(override ?? window._valrPollState.lastPollBody);
          if (_polling) return;
          _polling = true;
          window._valrPollState.polling = true;

          const submittedIds = (window._lastSubmittedIds && window._lastSubmittedIds.length)
            ? window._lastSubmittedIds
            : (data?.submitted_intents || []).map(x => String(x.intent_id));

          const pollBody = pollBodyOverride
            ? pollBodyOverride
            : (submittedIds.length ? { intent_ids: submittedIds } : { for_date: forDate });

          // remember for resume
          _lastPollBody = pollBody;
          window._valrPollState.lastPollBody = pollBody;

          let delay = 1500;
          const maxDelay = 10000;
          const deadline = Date.now() + 5 * 60_000;   // 5-minute window

          // lock the first poll body for the whole run so we don't lose intent_ids
          const lockedPollBody = pollBody;

          while (Date.now() < deadline) {
            let polled, pErr;

            try {
              ({ data: polled, error: pErr } =
              await sb().functions.invoke('valr-poll-orders', { body: lockedPollBody }));
              // retry once on token/auth hiccup (401, 403)
              if (pErr && /401|403/.test(String(pErr.status || ''))) {
                try { await sb().auth.refreshSession(); } catch {}
                ({ data: polled, error: pErr } =
                  await sb().functions.invoke('valr-poll-orders', { body: lockedPollBody }));
              }
              if (pErr || polled?.error) throw new Error(polled?.error || pErr?.message || 'Polling failed');
            } catch (e) {
              // don’t kill the loop on transient network/auth errors; wait and try again
              await new Promise(r => setTimeout(r, delay));
              delay = Math.min(maxDelay, delay * 2);
              continue;
            }

            // ---- UI updates (unchanged) ----
            if (polled?.per_intent?.length) {
              for (const rec of polled.per_intent) {
                const row = bodyEl.querySelector(`tr[data-id="${rec.intent_id}"]`);
                if (row) {
                  const pillCell = row.querySelector('.live-cell .pill');
                  if (pillCell) pillCell.outerHTML = pill(
                    String(rec.status || '').toLowerCase(),
                    { filled_qty: rec.filled_quantity, orig_qty: rec.original_quantity }
                  );
                  const statusCell = row.querySelector('.status-cell');
                  if (statusCell) statusCell.textContent = String(rec.status || '').toLowerCase();
                  const btn = row.querySelector('.cancel-btn');
                  if (btn && !['submitted','executing','partially_filled'].includes(String(rec.status||'').toLowerCase())) {
                    btn.remove();
                  }
                }
              }
            }

            const rows = await loadPreviewRows(forDate);
            renderIntentsTable(rows);
            const placedNow = await loadPlaced24h();
            renderPlaced(placedNow);

            // Only consider rows we actually placed (submitted/executing/partial/etc.)
            // Prefer the exact submitted ids if we have them.
            const watchingIds = (window._lastSubmittedIds && window._lastSubmittedIds.length)
              ? window._lastSubmittedIds.map(String)
              : null;

            const relevant = rows.filter(r => {
              const s = String(r.status || '').toLowerCase();
              const isPlacedState = ['submitted','executing','partially_filled','filled','cancelled','error','skipped'].includes(s);
              if (watchingIds) return watchingIds.includes(String(r.intent_id));
              // fallback: if we didn’t capture ids, at least ignore pure previews
              return isPlacedState || r.exchange_order_id;
            });

            const allDone = relevant.length > 0 && relevant.every(r =>
              ['filled','cancelled','error','skipped'].includes(String(r.status || '').toLowerCase())
            );

            statusEl.textContent = allDone ? 'Done' : 'Still working…';
            if (allDone) break;

            await new Promise(r => setTimeout(r, delay));
            // background tabs get throttled—don’t let delay explode forever
            delay = Math.min(maxDelay, delay * 2);
          }

          _polling = false;
          window._valrPollState.polling = false;
        }

        // bind resume-on-focus/visibility exactly once per page
        if (!window._valrPollResumeBound) {
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && !window._valrPollState.polling && window._valrPollState.lastPollBody) {
              window._valrPollState.resume?.();
            }
          });
          window.addEventListener('focus', () => {
            if (!window._valrPollState.polling && window._valrPollState.lastPollBody) {
              window._valrPollState.resume?.();
            }
          });
          window._valrPollResumeBound = true;
        }

        // also resume after a TOKEN_REFRESHED / SIGNED_IN event
        if (!window._valrAuthResumeBound && window.supabaseClient?.auth?.onAuthStateChange) {
          try {
            window.supabaseClient.auth.onAuthStateChange((event) => {
              if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN')
                  && !window._valrPollState.polling
                  && window._valrPollState.lastPollBody) {
                window._valrPollState.resume?.();
              }
            });
          } catch {}
          window._valrAuthResumeBound = true;
        }

        // start the first loop
        pollLoop();

      } catch (e) {
        console.error('[Execute Orders] Caught error:', e);
        const errorMsg = e?.message || e?.toString() || 'Unknown error';
        statusEl.textContent = 'Error: ' + errorMsg;
        
        // Check if it's a VALR signature error and provide helpful message
        if (errorMsg.includes('invalid signature') || errorMsg.includes('401')) {
          alert('Execute Orders failed: VALR API Authentication Error\n\n' +
            'The VALR API credentials (key/secret) are invalid or have been regenerated.\n\n' +
            'Please verify and update the VALR API credentials in Customer Management.\n\n' +
            'Technical details: ' + errorMsg);
        } else {
          alert('Execute Orders failed:\n\n' + errorMsg + '\n\nCheck the browser console for more details.');
        }
        
        executeBtn.disabled = false;
        previewBtn.disabled  = false;
      }
    });
  });
  </script>
  <!-- ANCHOR: Real Orders (VALR) JS END -->

  <!-- ANCHOR: Balance Maintenance JS START -->
  <script>
  (() => {
    // ----- helpers -----
    const sb = () => {
      const c = window.supabaseClient;
      if (!c) throw new Error('Supabase not ready');
      return c;
    };
    async function untilSupabase(timeoutMs = 8000) {
      const start = Date.now();
      while (!window.supabaseClient) {
        await new Promise(r => setTimeout(r, 50));
        if (Date.now() - start > timeoutMs) throw new Error('Supabase not ready (timeout)');
      }
    }
    const $  = (s,root=document) => root.querySelector(s);
    const $$ = (s,root=document) => Array.from(root.querySelectorAll(s));

    function yyyymmChoices(fromIso) {
      // Only: current month and next month (UTC)
      const base = fromIso ? new Date(fromIso + 'T00:00:00Z') : new Date();
      const curr = new Date(Date.UTC(base.getUTCFullYear(), base.getUTCMonth(), 1));
      const next = new Date(Date.UTC(base.getUTCFullYear(), base.getUTCMonth() + 1, 1));

      const toOpt = (d, isCurrent=false) => {
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, '0');
        return { value: `${y}-${m}`, label: `${y}-${m}${isCurrent ? ' (current)' : ''}` };
      };

      return [toOpt(curr, true), toOpt(next, false)];
    }

    function fillMonthSelect(sel, iso) {
      sel.innerHTML = yyyymmChoices(iso).map(o=>`<option value="${o.value}">${o.label}</option>`).join('');
    }

    const normalizeDay = s => (s ? s.replace(/\//g, '-') : null);

    // ----- elements -----
    const mod = document.getElementById('balance-maintenance-module');
    if (!mod) return;

    // helper for consistent number formatting
    const fmt = (n, d = 6) => (n == null ? 0 : +n).toFixed(d);

    const ctxCustomerSel = document.getElementById('customerSelect');
    function getContextCustomerId(){
      const v = ctxCustomerSel ? (ctxCustomerSel.value || '') : '';
      return Number(v || 0);
    }

    const dFrom = $('#retFrom', mod);
    const dTo   = $('#retTo', mod);
    const bSync = $('#retSyncBtn', mod);
    const bLoad = $('#retLoadBtn', mod);
    const bAlloc= $('#retAllocBtn', mod);
    const onlyU = $('#retOnlyUnalloc', mod);
    const month = $('#retAllocMonth', mod);
    const status= $('#retStatus', mod);
    const wrap  = $('#retWrap', mod);
    const tbody = $('#retBody', mod);
    const chkAll= $('#retCheckAll', mod);
    const bDrift = $('#retDriftBtn', mod);
    const driftWrap = $('#retDriftWrap', mod);
    const driftBody = $('#retDriftBody', mod);


    // set defaults
    (function initDates(){
      const today = new Date();
      const iso = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate())).toISOString().slice(0,10);
      dFrom.value = iso; dTo.value = iso;
      fillMonthSelect(month, iso);
    })();

    function paintRows(rows){
      if (!rows || !rows.length) {
        wrap.style.display='block';
        tbody.innerHTML = `<tr><td colspan="13" style="padding:.7rem;color:#6b7280;text-align:center">No rows.</td></tr>`;
        chkAll.checked = false;
        month.disabled = true; bAlloc.disabled = true;
        return;
      }
      wrap.style.display='block';
      tbody.innerHTML = rows.map(r=>{
        const fee = r['fee currency'] ? `${r['fee value']} ${r['fee currency']}` : '';
        const price = r['trade price']!=null ? `${r['trade price']} ${r['trade price currency']||''}` : '';
        const isDep = r.classification==='USDT_DEPOSIT';
        const alloc = r.allocated_month ? r.allocated_month : (isDep ? '—' : '');
        const canSelect = isDep && !r.allocated_month;
        return `<tr data-id="${r.real_tx_id}">
          <td style="text-align:left;padding:6px;">${String(r.date).slice(0,19).replace('T',' ')}</td>
          <td>${r['transaction type']||''}</td>
          <td>${r['trade currency pair']||''}</td>
          <td>${r['debit currency']||''}</td>
          <td>${Number(r['debit value']||0)}</td>
          <td>${r['credit currency']||''}</td>
          <td>${Number(r['credit value']||0)}</td>
          <td>${fee}</td>
          <td>${price}</td>
          <td>${r['order id']||''}</td>
          <td>${r.classification||''}</td>
          <td>${alloc}</td>
          <td>${canSelect?'<input type="checkbox" class="retRowChk">':''}</td>
        </tr>`;
      }).join('');
      enableAllocUI();
    }

    function enableAllocUI(){
      const anySelectable = !!$('.retRowChk', tbody);
      const anyChecked = $$('.retRowChk:checked', tbody).length>0;
      month.disabled = !anySelectable;
      bAlloc.disabled = !anyChecked;
      chkAll.checked = anySelectable && $$('.retRowChk', tbody).every(x=>x.checked);
    }

    tbody.addEventListener('change', (e)=>{
      if (e.target.matches('.retRowChk')) enableAllocUI();
    });
    chkAll.addEventListener('change', ()=>{
      $$('.retRowChk', tbody).forEach(x=>x.checked = chkAll.checked);
      enableAllocUI();
    });

    async function loadFromDb() {
      const cid = getContextCustomerId();
      if (!cid) return alert('Select a customer in the top context bar');
      status.textContent = 'Loading…';
      const { data, error } = await sb().functions.invoke('real-txs-extract', {
        body: { customer_id: cid, from: normalizeDay(dFrom.value), to: normalizeDay(dTo.value), only_unallocated_deposits: !!onlyU.checked }
      });
      if (error || data?.error) {
        status.textContent = 'Error';
        alert(data?.error || error?.message || 'Load failed');
        return;
      }
      paintRows(data.rows||[]);
      status.textContent = 'Ready';
    }

    async function loadDrift() {
      const cid = getContextCustomerId();
      if (!cid) return alert('Select a customer in the top context bar');
      status.textContent = 'Loading drift…';
      driftWrap.style.display = 'block';
      driftBody.innerHTML = `<tr><td colspan="10" style="padding:.7rem;color:#6b7280;text-align:center">Loading…</td></tr>`;
      const { data, error } = await sb().from('real_balance_drift')
        .select('*')
        .eq('customer_id', cid)
        .gte('day', (normalizeDay(dFrom.value)||'1970-01-01'))
        .lte('day', (normalizeDay(dTo.value)||'2999-12-31'))
        .order('day', { ascending: true });
      if (error) {
        status.textContent = 'Error';
        driftBody.innerHTML = `<tr><td colspan="10" style="padding:.7rem;color:#b91c1c;text-align:center">${error.message}</td></tr>`;
        return;
      }
      const rows = data || [];
      if (!rows.length) {
        driftBody.innerHTML = `<tr><td colspan="10" style="padding:.7rem;color:#6b7280;text-align:center">No drift rows in range.</td></tr>`;
      } else {
        driftBody.innerHTML = (data || []).map(r => `
          <tr>
          <td style="text-align:left;padding:6px;">${String(r.day).slice(0,10)}</td>

          <td>${fmt(r.obs_usdt_delta, 6)}</td>
          <td>${fmt(r.exp_usdt_delta, 6)}</td>
          <td style="font-weight:600;">${fmt(r.drift_usdt ?? ((+r.obs_usdt_delta || 0) - (+r.exp_usdt_delta || 0)), 6)}</td>

          <td>${fmt(r.obs_btc_delta, 8)}</td>
          <td>${fmt(r.exp_btc_delta, 8)}</td>
          <td style="font-weight:600;">${fmt(r.drift_btc ?? ((+r.obs_btc_delta || 0) - (+r.exp_btc_delta || 0)), 8)}</td>

          <td>${fmt(r.obs_zar_delta, 2)}</td>
          <td>${fmt(r.exp_zar_delta, 2)}</td>
          <td style="font-weight:600;">${fmt(r.drift_zar ?? ((+r.obs_zar_delta || 0) - (+r.exp_zar_delta || 0)), 2)}</td>
        </tr>
      `).join('');

      }
      status.textContent = 'Ready';
    }

    bLoad.addEventListener('click', loadFromDb);

    bSync.addEventListener('click', async ()=>{
      const cid = getContextCustomerId();
      if (!cid) return alert('Select a customer in the top context bar');
      status.textContent = 'Syncing…';
      bSync.disabled = true; bLoad.disabled = true;
      try{
        const { data, error } = await sb().functions.invoke('real-txs-sync-valr', {
          body: { customer_id: cid, from: normalizeDay(dFrom.value), to: normalizeDay(dTo.value) }
        });
        if (error || data?.error) throw new Error(data?.error || error?.message);
        status.textContent = `Synced — inserted ${data.inserted||0}`;
        await loadFromDb();
      }catch(e){
        status.textContent = 'Error';
        alert(e?.message || e);
      }finally{
        bSync.disabled = false; bLoad.disabled = false;
      }
    });

    bAlloc.addEventListener('click', async ()=>{
      const ids = $$('.retRowChk:checked', tbody)
        .map(chk => chk.closest('tr')?.getAttribute('data-id'))
        .filter(Boolean);
      if (!ids.length) return;
      const m = month.value;
      if (!m) return alert('Pick allocation month');
      bAlloc.disabled = true;
      status.textContent = 'Allocating…';
      try{
        const { data, error } = await sb().functions.invoke('real-txs-allocate-deposits', {
          body: { tx_ids: ids, allocate_to_month: m }
        });
        if (error || data?.error) throw new Error(data?.error || error?.message);
        status.textContent = `Allocated ${data.updated||0} deposit(s) to ${m}`;
        await loadFromDb();
      }catch(e){
        status.textContent = 'Error';
        alert(e?.message || e);
      }finally{
        bAlloc.disabled = false;
      }
    });

    onlyU.addEventListener('change', loadFromDb);
    bDrift.addEventListener('click', loadDrift);

    // ----- LTH PVR – Ledger & Balances -----
    (function initLthLedgerBalances(){
      const from   = $('#lthFrom', mod);
      const to     = $('#lthTo', mod);
      const btn    = $('#lthLoadBtn', mod);
      const recalc = $('#lthRecalcBtn', mod);
      const status = $('#lthStatus', mod);
      const wrap   = $('#lthTableWrap', mod);
      const body   = $('#lthBody', mod);

      if (!from || !to || !btn || !status || !wrap || !body) return;

      // Default dates: today (UTC), but don’t overwrite if user already picked something
      (function initLthDates(){
        const today = new Date();
        const iso = new Date(Date.UTC(
          today.getUTCFullYear(),
          today.getUTCMonth(),
          today.getUTCDate()
        )).toISOString().slice(0,10);
        if (!from.value) from.value = iso;
        if (!to.value)   to.value   = iso;
      })();

      function ensureLthContext(){
        const sel = document.getElementById('portfolioSelect');
        if (!sel){
          alert('Select an LTH PVR portfolio / strategy in the top context bar first.');
          return false;
        }

        const pid = sel.value || null;
        const opt = sel.selectedIndex >= 0 ? sel.options[sel.selectedIndex] : null;

        const code = (opt?.getAttribute('data-strategy-code') || window.currentStrategyCode || '')
          .toString()
          .trim()
          .toUpperCase();

        if (!pid || !code || code !== 'LTH_PVR'){
          alert('Select an LTH PVR portfolio / strategy in the top context bar first.');
          return false;
        }

        // keep globals in sync with the actual selection
        window.currentPortfolioId = pid;
        window.currentStrategyCode = code;

        return true;
      }

      function paintLthRows(rows){
        const r = Array.isArray(rows) ? rows : [];
        if (!r.length){
          wrap.style.display = 'block';
          body.innerHTML =
            '<tr><td colspan="5" style="padding:.7rem;color:#6b7280;text-align:center">No rows in range.</td></tr>';
          return;
        }
        wrap.style.display = 'block';
        body.innerHTML = r.map(ev => {
          const dt  = ev.event_date || ev.date || ev.day || ev.tx_date || '';
          const typ = ev.event_type || ev.kind || ev.source || '';
          const btc = ev.btc_delta ?? ev.btc_change ?? ev.delta_btc ?? ev.btc ?? 0;
          const usd = ev.usdt_delta ?? ev.usd_delta ?? ev.delta_usd ?? ev.usdt ?? ev.usd ?? 0;
          const note= ev.note || ev.description || ev.label || '';
          return `<tr>
            <td style="text-align:left;padding:6px;">${String(dt).slice(0,19).replace('T',' ')}</td>
            <td>${typ}</td>
            <td style="text-align:right;">${fmt(btc, 8)}</td>
            <td style="text-align:right;">${fmt(usd, 2)}</td>
            <td>${note}</td>
          </tr>`;
        }).join('');
      }

      async function loadLthFromDb(){
        if (!ensureLthContext()) return;
        await untilSupabase();

        const portfolioId = window.currentPortfolioId;
        const fromDate = normalizeDay(from.value) || null;
        const toDate   = normalizeDay(to.value)   || null;

        status.textContent = 'Loading…';
        btn.disabled = true;

        try{
          // Expects a Postgres RPC that returns rows with:
          //   event_date, event_type, btc_delta, usdt_delta, note
          const { data, error } = await sb().rpc('lth_pvr_list_ledger_and_balances', {
            portfolio_id: portfolioId,
            from_date: fromDate,
            to_date: toDate
          });
          if (error) throw error;
          const rows = (data && (data.rows || data)) || [];
          paintLthRows(rows);
          status.textContent = `Loaded ${rows.length} row${rows.length===1 ? '' : 's'}`;
        }catch(e){
          console.error(e);
          status.textContent = 'Error';
          alert(e?.message || e);
        }finally{
          btn.disabled = false;
        }
      }

      async function recalcLthBalances(){
        if (!ensureLthContext()) return;
        await untilSupabase();

        const portfolioId = window.currentPortfolioId;

        status.textContent = 'Recalculating…';
        if (recalc) recalc.disabled = true;

        try{
          // Calls your existing Edge Function that rebuilds ledger_lines + balances_daily
          const { data, error } = await sb().functions.invoke('ef_post_ledger_and_balances', {
            body: {
              portfolio_id: portfolioId,
              from: normalizeDay(from.value) || null,
              to: normalizeDay(to.value) || null
            }
          });
          if (error || data?.error) throw new Error(data?.error || error?.message);
          status.textContent = 'Recalculated — reloading…';
          await loadLthFromDb();
        }catch(e){
          console.error(e);
          status.textContent = 'Error';
          alert(e?.message || e);
        }finally{
          if (recalc) recalc.disabled = false;
        }
      }

      btn.addEventListener('click', loadLthFromDb);
      if (recalc) recalc.addEventListener('click', recalcLthBalances);
    })();

  })();
  </script>
  <!-- ANCHOR: Balance Maintenance JS END -->

    <!-- ===================== Portfolio Performance Reporting ===================== -->
    <div id="reports-module" class="module">
      <h2>Portfolio Performance Reporting</h2>
      <div id="reportsError"></div>

      <div class="reports-controls-outer">
        <div class="reports-controls">
          <label for="reportTypeSelect"><strong>Report type:</strong></label>
          <select id="reportTypeSelect">
            <option value="holdings" selected>Portfolio Holdings</option>
            <option value="comp_value">Comparison - Portfolio Value</option>
            <option value="comp_roi">Comparison - ROI</option>
            <option value="comp_agr">Comparison - Annualised Growth</option>
          </select>
        </div>
      </div>

      <div class="card">
        <h3 id="reportTitle" class="chart-title"></h3>

        <div class="chart-toolbar">
          <button id="showAllBtn" type="button">Show all</button>
          <button id="hideAllBtn" type="button">Hide all</button>
        </div>

        <div id="chartNotice" class="chart-notice"></div>
        <canvas id="perfChart" height="120"></canvas>

        <div id="chartRange" class="chart-range">
          <div class="sliders">
            <input id="rangeStart" type="range" min="0" max="1" value="0">
            <input id="rangeEnd" type="range" min="0" max="1" value="1">
          </div>
          <div class="labels">
            <span id="rangeStartLabel"></span>
            <span id="rangeEndLabel"></span>
          </div>
        </div>

        <div id="chartFooter" class="chart-footer"></div>

        <div class="chart-actions">
          <button id="resetZoomBtn" type="button" disabled>Reset Zoom</button>
        </div>
        <!-- Table renders here under the chart -->
        <section id="report-tables" class="report-tables-wrapper"></section>

        <!-- AI narrative appears here -->
        <div id="chartNarrative"></div>

        <!-- Export button -->
        <div class="chart-actions" style="margin-top:10px">
          <button id="exportPdfBtn" type="button">Export Customer Charts to PDF</button>
        </div>
      </div>
    </div>

    <div id="backtest-module" class="module">
      <h2>Strategy Back-Testing</h2>

      <div id="btReportsError"></div>

      <div class="reports-controls-outer">
        <div class="reports-controls">
          <!-- Strategy selector -->
          <label for="btStrategySelect"><strong>Strategy:</strong></label>
          <select id="btStrategySelect">
            <option value="LTH_PVR" selected>LTH PVR BTC DCA (current strategy)</option>
            <option value="ADV_DCA" disabled>Advanced BTC DCA (coming soon)</option>
          </select>

          <!-- Dates -->
          <label for="btStartDate"><strong>Start Date:</strong></label>
          <input id="btStartDate" type="date">

          <label for="btEndDate"><strong>End Date:</strong></label>
          <input id="btEndDate" type="date">

          <!-- Contributions -->
          <label for="btUpfrontUsdt"><strong>Upfront USDT contribution:</strong></label>
          <input id="btUpfrontUsdt" type="number" min="0" step="0.01" value="0">

          <label for="btMonthlyUsdt"><strong>Monthly USDT contribution:</strong></label>
          <input id="btMonthlyUsdt" type="number" min="0" step="0.01" value="30">

          <!-- Exchange Fees (VALR) -->
          <label for="btBtcFeePct"><strong>VALR BTC/USDT Fee (bps):</strong></label>
          <input id="btBtcFeePct" type="number" min="0" step="0.01" value="8" title="8 bps = 0.08% - VALR exchange fee for BTC/USDT trades (charged in BTC)">

          <label for="btContribFeePct"><strong>VALR USDT/ZAR Fee (bps):</strong></label>
          <input id="btContribFeePct" type="number" min="0" step="0.01" value="18" title="18 bps = 0.18% - VALR exchange fee for USDT/ZAR conversions (charged in USDT)">

          <!-- BitWealth Fees -->
          <label for="btPlatformFeePct"><strong>BitWealth Platform Fee (%):</strong></label>
          <input id="btPlatformFeePct" type="number" min="0" max="100" step="0.01" value="0.75" title="0.75% - BitWealth platform fee on all contributions">

          <label for="btPerformanceFeePct"><strong>BitWealth Performance Fee (%):</strong></label>
          <input id="btPerformanceFeePct" type="number" min="0" max="100" step="1" value="10" title="10% - BitWealth performance fee on monthly profits (high-water mark)">

          <!-- Chart type -->
          <label for="btReportTypeSelect"><strong>Chart type:</strong></label>
          <select id="btReportTypeSelect">
            <option value="holdings" selected>Back-test holdings</option>
            <option value="comp_value">Comparison – Portfolio Value</option>
            <option value="comp_roi">Comparison – ROI</option>
            <option value="comp_agr">Comparison – Annualised Growth</option>
          </select>

          <!-- Actions / messages -->
          <div class="bt-form-actions">
            <button id="btRunBtn" type="button">Run back-test</button>
            <div id="btInlineError" class="inline-error"></div>
            <div id="btStrategyNote" class="bt-note">
              Advanced BTC DCA back-testing is coming soon. Currently only the LTH PVR BTC DCA strategy is available.
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3 id="btReportTitle" class="chart-title"></h3>

        <div class="chart-toolbar">
          <button id="btShowAllBtn" type="button">Show all</button>
          <button id="btHideAllBtn" type="button">Hide all</button>
        </div>

        <div id="btChartNotice" class="chart-notice"></div>
        <canvas id="btPerfChart" height="120"></canvas>

        <div id="btChartRange" class="chart-range">
          <div class="sliders">
            <input id="btRangeStart" type="range" min="0" max="1" value="0">
            <input id="btRangeEnd" type="range" min="0" max="1" value="1">
          </div>
          <div class="labels">
            <span id="btRangeStartLabel"></span>
            <span id="btRangeEndLabel"></span>
          </div>
        </div>

        <div id="btChartFooter" class="chart-footer"></div>

        <div class="chart-actions">
          <button id="btResetZoomBtn" type="button" disabled>Reset Zoom</button>
        </div>

        <!-- Table renders here under the chart -->
        <section id="btReportTables" class="report-tables-wrapper">
          <table class="report-table">
            <tbody id="btYearlyTable">
              <!-- Filled dynamically by renderBtPerformanceTable(btRunId, ...) -->
            </tbody>
          </table>
        </section>

        <!-- AI narrative appears here -->
        <div id="btChartNarrative"></div>

        <!-- Export button -->
        <div class="chart-actions" style="margin-top:10px">
          <button id="btExportPdfBtn" type="button">Export Customer Charts to PDF</button>
        </div>
      </div>
    </div>

    <div id="finance-module" class="module">
      <h2>Finance</h2>
      
      <!-- Main Account Accumulation Card -->
      <div class="card" style="max-width: 1400px; margin-bottom: 1.5rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <div>
            <h3>Main Account Accumulation</h3>
            <p class="small muted">BTC transferred to main account but below VALR conversion threshold (0.00001 BTC / $0.52 USDT).</p>
          </div>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="refreshMainAccountAccumulation" type="button" onclick="loadMainAccountAccumulation()">Refresh</button>
            <button id="convertMainAccountBtcNow" type="button" onclick="convertMainAccountBtcManually()" style="background: #3b82f6; font-weight: 600; display: none;">Convert Now</button>
          </div>
        </div>

        <div id="mainAccountAccumulationLoading" style="text-align: center; padding: 2rem; color: #64748b;">
          <div style="display: inline-block; width: 20px; height: 20px; border: 3px solid #e2e8f0; border-top-color: #3b82f6; border-radius: 50%; animation: spin 0.8s linear infinite;"></div>
          <p style="margin-top: 0.5rem;">Loading main account accumulation...</p>
        </div>

        <div id="mainAccountAccumulationError" style="display: none; padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; color: #991b1b; border-radius: 4px;">
          <strong>Error loading main account accumulation</strong>
          <p id="mainAccountAccumulationErrorMessage" style="margin: 0.5rem 0 0 0; font-size: 14px;"></p>
        </div>

        <div id="noMainAccountAccumulation" style="display: none; text-align: center; padding: 2rem; color: #64748b;">
          <div style="font-size: 48px; margin-bottom: 1rem;">✅</div>
          <p style="font-size: 16px; font-weight: 600; margin-bottom: 0.5rem;">No Accumulated BTC</p>
          <p style="font-size: 14px; margin: 0;">Main account has no BTC awaiting conversion.</p>
        </div>

        <div id="mainAccountAccumulationContent" style="display: none;">
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem;">
            <div style="padding: 1.5rem; background: linear-gradient(135deg, #f7931a 0%, #ff6b35 100%); border-radius: 8px; color: white;">
              <div style="font-size: 12px; font-weight: 600; text-transform: uppercase; opacity: 0.9; margin-bottom: 0.5rem;">Accumulated BTC</div>
              <div id="mainAccountBtcAmount" style="font-size: 24px; font-weight: 700; margin-bottom: 0.25rem;">0.00000000 BTC</div>
              <div id="mainAccountBtcSats" style="font-size: 14px; opacity: 0.9;">0 sats</div>
            </div>
            <div style="padding: 1.5rem; background: linear-gradient(135deg, #26a17b 0%, #16a085 100%); border-radius: 8px; color: white;">
              <div style="font-size: 12px; font-weight: 600; text-transform: uppercase; opacity: 0.9; margin-bottom: 0.5rem;">Accumulated USDT</div>
              <div id="mainAccountUsdtAmount" style="font-size: 24px; font-weight: 700; margin-bottom: 0.25rem;">$0.00</div>
              <div id="mainAccountUsdtNote" style="font-size: 14px; opacity: 0.9;">Direct transfers</div>
            </div>
            <div style="padding: 1.5rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; color: white;">
              <div style="font-size: 12px; font-weight: 600; text-transform: uppercase; opacity: 0.9; margin-bottom: 0.5rem;">Conversion Status</div>
              <div id="mainAccountConversionStatus" style="font-size: 16px; font-weight: 600; margin-bottom: 0.5rem;">
                <span id="mainAccountBtcStatusBadge"></span>
                <span id="mainAccountUsdtStatusBadge"></span>
              </div>
              <div id="mainAccountConversionCount" style="font-size: 14px; opacity: 0.9;">0 conversions</div>
            </div>
          </div>
          
          <div style="padding: 1rem; background: #f8fafc; border-radius: 6px; border-left: 4px solid #3b82f6;">
            <div style="display: flex; align-items: start; gap: 0.75rem;">
              <div style="font-size: 20px; margin-top: 2px;">ℹ️</div>
              <div style="font-size: 14px; color: #475569;">
                <strong style="color: #1e293b;">Dual-Threshold System:</strong> Platform fees are transferred from customer subaccounts when they reach the <strong>transfer threshold</strong> (0.000001 BTC / $0.06), but only converted to USDT when they reach the <strong>conversion threshold</strong> (0.00001 BTC / $0.52). BTC below the conversion threshold accumulates here until more transfers bring it above the minimum for VALR market orders.
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Accumulated Platform Fees Card -->
      <div class="card" style="max-width: 1400px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <div>
            <h3>Accumulated Platform Fees (Customer Subaccounts)</h3>
            <p class="small muted" id="accumulatedFeesDescription">Platform fees below VALR minimum thresholds that are awaiting batch transfer.</p>
          </div>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button id="refreshAccumulatedFees" type="button" onclick="loadAccumulatedFees()">Refresh</button>
            <button id="transferAccumulatedFeesNow" type="button" onclick="transferAccumulatedFeesManually()" style="background: #10b981; font-weight: 600;">Transfer Now</button>
          </div>
        </div>

        <div id="accumulatedFeesLoading" style="text-align: center; padding: 2rem; color: #64748b;">
          <div style="display: inline-block; width: 20px; height: 20px; border: 3px solid #e2e8f0; border-top-color: #3b82f6; border-radius: 50%; animation: spin 0.8s linear infinite;"></div>
          <p style="margin-top: 0.5rem;">Loading accumulated fees...</p>
        </div>

        <div id="accumulatedFeesError" style="display: none; padding: 1rem; background: #fee2e2; border-left: 4px solid #ef4444; color: #991b1b; border-radius: 4px;">
          <strong>Error loading accumulated fees</strong>
          <p id="accumulatedFeesErrorMessage" style="margin: 0.5rem 0 0 0; font-size: 14px;"></p>
        </div>

        <div id="noAccumulatedFees" style="display: none; text-align: center; padding: 2rem; color: #64748b;">
          <div style="font-size: 48px; margin-bottom: 1rem;">✅</div>
          <p style="font-size: 16px; font-weight: 600; margin-bottom: 0.5rem;">No Accumulated Fees</p>
          <p style="font-size: 14px; margin: 0;">All platform fees have been transferred successfully.</p>
        </div>

        <div id="accumulatedFeesTableContainer" style="display: none;">
          <div style="overflow-x: auto;">
            <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
              <thead>
                <tr style="background: #f8fafc; border-bottom: 2px solid #e2e8f0;">
                  <th style="padding: 12px; text-align: left; font-weight: 600; color: #475569;">Customer ID</th>
                  <th style="padding: 12px; text-align: left; font-weight: 600; color: #475569;">Customer Name</th>
                  <th style="padding: 12px; text-align: left; font-weight: 600; color: #475569;">Email</th>
                  <th style="padding: 12px; text-align: right; font-weight: 600; color: #475569;">Accumulated BTC</th>
                  <th style="padding: 12px; text-align: right; font-weight: 600; color: #475569;">Accumulated USDT</th>
                  <th style="padding: 12px; text-align: right; font-weight: 600; color: #475569;">Total Value (USD)</th>
                  <th style="padding: 12px; text-align: right; font-weight: 600; color: #475569;">Last Updated</th>
                  <th style="padding: 12px; text-align: right; font-weight: 600; color: #475569;">Transfers</th>
                </tr>
              </thead>
              <tbody id="accumulatedFeesTableBody">
                <!-- Populated by JavaScript -->
              </tbody>
              <tfoot>
                <tr style="background: #f8fafc; border-top: 2px solid #e2e8f0; font-weight: 600;">
                  <td colspan="3" style="padding: 12px; text-align: right;">Total:</td>
                  <td id="totalAccumulatedBtc" style="padding: 12px; text-align: right; color: #f59e0b;">0.00000000</td>
                  <td id="totalAccumulatedUsdt" style="padding: 12px; text-align: right; color: #f59e0b;">$0.00</td>
                  <td id="totalAccumulatedUsd" style="padding: 12px; text-align: right; color: #10b981; font-size: 16px;">$0.00</td>
                  <td colspan="2"></td>
                </tr>
              </tfoot>
            </table>
          </div>

          <div style="margin-top: 1rem; padding: 1rem; background: #eff6ff; border-left: 4px solid #3b82f6; border-radius: 4px; font-size: 14px; color: #1e40af;">
            <strong>💡 Info:</strong>
            <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
              <li>Monthly batch transfer runs automatically on the 1st of each month at 02:00 UTC</li>
              <li id="accumulatedFeesThresholdInfo">Fees are transferred when accumulated total ≥ minimum threshold</li>
              <li>Use "Transfer Now" button to manually trigger immediate batch transfer</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    
    <!-- ===================== Administration (owner-only) ===================== -->
    <div id="admin-module" class="module">
      <h2>Administration</h2>

      <!-- Sign-in card (shown until you sign in as the admin email) -->
      <div id="adminAuthCard" class="card" style="max-width:980px;">
        <h3>Sign in as Administrator</h3>
        <p class="small muted">Use the same email/password you created in <em>Supabase → Authentication → Users</em>.</p>
      <form id="adminLoginForm" onsubmit="return false;">   <!-- cancel native submit -->
        <label>Email <input id="adminEmail" type="email" required /></label>
        <label>Password <input id="adminPassword" type="password" required /></label>
        <button id="adminSignInBtn" type="button">Sign in</button>
      </form>
      </div>

      <!-- Admin app (only visible to the configured admin email) -->
      <div id="adminApp" class="card" style="display:none;max-width:1200px;">
        <div style="display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;">
          <strong>Organisation:</strong>
          <select id="adminOrgSelect"></select>
          <button id="adminRefresh" type="button">Refresh</button>
          <div style="margin-left:auto;display:flex;gap:.5rem;">
            <span id="adminSignedInAs" style="opacity:.7;"></span>
            <button id="adminSignOut" type="button">Sign out</button>
          </div>
        </div>

        <hr style="margin:1rem 0;">

        <h3>Add / Update Employee</h3>
        <form id="adminAddForm" style="display:flex;gap:.5rem;flex-wrap:wrap;align-items:end;">
          <label>Email <input id="adminAddEmail" type="email" required /></label>
          <label>Role
            <select id="adminAddRole">
              <option value="viewer">viewer</option>
              <option value="editor">editor</option>
              <option value="admin">admin</option>
            </select>
          </label>
          <label>Temp password
            <input id="adminAddPassword" type="text" placeholder="auto-generate if blank" />
          </label>
          <button type="submit">Add / Update</button>
        </form>

        <h3 style="margin-top:1rem;">Employees</h3>
        <table id="adminMembersTable">
          <thead><tr><th>Email</th><th>Role</th><th>Added</th><th></th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

      <!-- Pipeline Control Panel -->
      <div class="card" id="pipelineControlCard">
        <h3>Pipeline Control</h3>
        <p class="small-muted">Resume daily pipeline after CI bands data becomes available.</p>
        
        <div id="pipelineStatus" style="background:#f8f9fa;border:1px solid #e9ecef;border-radius:8px;padding:1rem;margin-bottom:1rem;">
          <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:.75rem;">
            <div>
              <strong style="display:block;margin-bottom:.25rem;">Pipeline Status</strong>
              <span id="pipelineStatusText" style="color:#6c757d;">Loading...</span>
            </div>
            <button id="pipelineRefreshBtn" class="btn btn-secondary-sm" type="button">Refresh</button>
          </div>
          
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:.75rem;margin-bottom:.75rem;">
            <div>
              <div style="font-size:.8rem;color:#6c757d;margin-bottom:.25rem;">Trade Date</div>
              <div id="pipelineTradeDate" style="font-weight:500;">—</div>
            </div>
            <div>
              <div style="font-size:.8rem;color:#6c757d;margin-bottom:.25rem;">Signal Date (CI Bands)</div>
              <div id="pipelineSignalDate" style="font-weight:500;">—</div>
            </div>
            <div>
              <div style="font-size:.8rem;color:#6c757d;margin-bottom:.25rem;">CI Bands Available</div>
              <div id="pipelineCIStatus" style="font-weight:500;">—</div>
            </div>
            <div>
              <div style="font-size:.8rem;color:#6c757d;margin-bottom:.25rem;">Trade Window</div>
              <div id="pipelineWindowStatus" style="font-weight:500;">—</div>
            </div>
          </div>
          
          <div style="border-top:1px solid #e9ecef;padding-top:.75rem;">
            <div style="font-size:.8rem;color:#6c757d;margin-bottom:.5rem;">Pipeline Steps</div>
            <div style="display:grid;gap:.35rem;">
              <div style="display:flex;align-items:center;gap:.5rem;">
                <span id="stepCIBands" style="font-size:1.2rem;">⏸️</span>
                <span style="font-size:.85rem;">CI Bands</span>
              </div>
              <div style="display:flex;align-items:center;gap:.5rem;">
                <span id="stepDecisions" style="font-size:1.2rem;">⏸️</span>
                <span style="font-size:.85rem;">Decisions</span>
              </div>
              <div style="display:flex;align-items:center;gap:.5rem;">
                <span id="stepIntents" style="font-size:1.2rem;">⏸️</span>
                <span style="font-size:.85rem;">Order Intents</span>
              </div>
              <div style="display:flex;align-items:center;gap:.5rem;">
                <span id="stepOrders" style="font-size:1.2rem;">⏸️</span>
                <span style="font-size:.85rem;">Execute Orders</span>
              </div>
              <div style="display:flex;align-items:center;gap:.5rem;">
                <span id="stepPollOrders" style="font-size:1.2rem;">⏸️</span>
                <span style="font-size:.85rem;">Poll Orders</span>
              </div>
              <div style="display:flex;align-items:center;gap:.5rem;">
                <span id="stepLedger" style="font-size:1.2rem;">⏸️</span>
                <span style="font-size:.85rem;">Ledger Posted</span>
              </div>
            </div>
          </div>
        </div>
        
        <div style="display:flex;gap:.75rem;align-items:center;">
          <button id="pipelineResumeBtn" type="button" class="btn" disabled>Resume Pipeline</button>
          <span id="pipelineResumeMessage" style="font-size:.85rem;color:#6c757d;"></span>
        </div>
        
        <div id="pipelineExecutionLog" style="display:none;margin-top:1rem;background:#f8f9fa;border:1px solid #e9ecef;border-radius:8px;padding:1rem;">
          <strong style="display:block;margin-bottom:.5rem;">Execution Log</strong>
          <div id="pipelineLogContent" style="font-family:monospace;font-size:.8rem;white-space:pre-wrap;color:#495057;"></div>
        </div>
      </div>

      <!-- Pending ZAR Conversions Panel -->
      <div class="card" id="pendingZarCard">
        <h3>⏳ Pending ZAR Conversions</h3>
        <p class="small-muted">ZAR deposits awaiting conversion to USDT. Auto-syncs every 30 minutes to detect conversions.</p>
        
        <div id="zarConversionsContainer" style="margin-bottom:1rem;">
          <div id="zarConversionsList" style="display:grid;gap:.75rem;">
            <!-- Populated dynamically -->
          </div>
        </div>
        
        <div style="display:flex;gap:.75rem;align-items:center;">
          <button id="zarSyncNowBtn" type="button" class="btn btn-secondary-sm">🔄 Sync Now</button>
          <span id="zarRefreshMessage" style="font-size:.85rem;color:#6c757d;"></span>
        </div>
      </div>

      <!-- Alerts card -->
      <div class="card" id="alertsCard">
        <h3>System Alerts</h3>
        <p class="small-muted">Open alerts across all strategies for your organisation.</p>
        <div style="display:flex;align-items:center;gap:.75rem;margin-bottom:.5rem;flex-wrap:wrap;">
          <button id="alertsRefreshBtn" class="btn btn-secondary-sm" type="button">Refresh</button>
          <label style="display:flex;align-items:center;font-size:.8rem;gap:.35rem;">
            <input id="alertsOpenOnlyChk" type="checkbox" checked>
            <span>Show only open alerts</span>
          </label>
          <label style="display:flex;align-items:center;font-size:.8rem;gap:.35rem;">
            <input id="alertsAutoRefreshChk" type="checkbox">
            <span>Auto-refresh (30s)</span>
          </label>
          <select id="alertsComponentFilter" class="context-select" style="min-width:200px;height:36px;">
            <option value="">All Components</option>
            <option value="ef_fetch_ci_bands">ef_fetch_ci_bands</option>
            <option value="ef_generate_decisions">ef_generate_decisions</option>
            <option value="ef_create_order_intents">ef_create_order_intents</option>
            <option value="ef_execute_orders">ef_execute_orders</option>
            <option value="ef_poll_orders">ef_poll_orders</option>
          </select>
        </div>
        <div class="table-scroll" id="alertsTableContainer">
          <table id="alertsTable">
            <thead>
              <tr>
                <th style="min-width:140px;">Created</th>
                <th style="min-width:90px;">Severity</th>
                <th style="min-width:140px;">Component</th>
                <th>Message</th>
                <th style="min-width:140px;">Resolved</th>
                <th style="min-width:80px;"></th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="6" class="muted">No alerts.</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </main>

  <script>
    /* ---------- Helpers ---------- */
    function showInlineError(id,msg){const el=document.getElementById(id);el.textContent=msg;el.style.display='block';}
    function clearInlineError(id){const el=document.getElementById(id);el.textContent='';el.style.display='none';}
    function cssVar(n){return getComputedStyle(document.documentElement).getPropertyValue(n).trim();}

    const hasSupabase=typeof window.supabase!=='undefined';
    const hasPapa=typeof window.Papa!=='undefined';
    const hasChart=typeof window.Chart!=='undefined';
    if(!hasSupabase) showInlineError('inlineError','Supabase library did not load.');
    if(!hasPapa)     showInlineError('inlineError','CSV parser (PapaParse) did not load.');
    if(!hasChart)    showInlineError('reportsError','Chart.js did not load.');

    /* ---------- Supabase ---------- */
    let supabaseClient = null;
    if (hasSupabase) {
      const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';
      const PUBLISHABLE_KEY = 'sb_publishable_8HEKObrmj01h7fd04xOl0w_7QSd89In';
      
      // Expose globally for edge function calls
      window.SUPABASE_ANON_KEY = PUBLISHABLE_KEY;

      try {
        supabaseClient = window.supabase.createClient(SUPABASE_URL, PUBLISHABLE_KEY, {
          auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true
          }
        });
        window.supabaseClient = supabaseClient; // expose globally for Admin module
        
        // Listen for authentication changes and reload data
        supabaseClient.auth.onAuthStateChange((event, session) => {
          console.log('[Auth] State changed:', event, session?.user?.email);
          if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
            // User just signed in or token refreshed - reload data FOR CURRENT MODULE ONLY
            const currentHash = location.hash;
            
            // Import module data
            if (currentHash === '#import-module' || !currentHash) {
              clearInlineError('inlineError');
              if (typeof loadExistingDates === 'function') {
                loadExistingDates();
              }
            }
            
            // Admin module alerts
            if (currentHash === '#admin-module' && typeof window.loadAlerts === 'function') {
              window.loadAlerts();
            }
            
            // Customer Maintenance module data
            if (currentHash === '#customer-maintenance-module') {
              if (typeof window.loadCustomerFees === 'function') {
                window.loadCustomerFees();
              }
              if (typeof window.loadCustomers === 'function') {
                window.loadCustomers();
              }
            }
            
            // Context bar (needed for all modules on sign-in, but not on token refresh when already signed in)
            if (event === 'SIGNED_IN' && typeof window.loadOrgContext === 'function') {
              window.loadOrgContext();
            }
            
            // Customer Transactions module
            if (currentHash === '#customer-transactions-module') {
              if (typeof window.loadPlaced24h === 'function' && typeof window.renderPlaced === 'function') {
                window.loadPlaced24h().then(window.renderPlaced).catch(console.warn);
              }
            }
          }
        });
      } catch (e) {
        console.error(e);
        showInlineError('reportsError','Could not initialize Supabase client.');
      }
    }

    /* ---------- Utils ---------- */
    function normalizeDate(val){
      const s = String(val ?? "").trim();
      if (!s) return "";

      // 1) YYYY-MM-DD or YYYY/MM/DD → always return with hyphens
      let m = s.match(/^(\d{4})[-/](\d{2})[-/](\d{2})$/);
      if (m) return `${m[1]}-${m[2]}-${m[3]}`;

      // 2) yyyymmdd (compact)
      m = s.match(/^(\d{4})(\d{2})(\d{2})$/);
      if (m) return `${m[1]}-${m[2]}-${m[3]}`;

      // 3) Excel serial number (days since 1899-12-30)
      if (/^\d+$/.test(s)) {
        const serial = Number(s);
        if (Number.isFinite(serial) && serial >= 25569) {
          const ms = (serial - 25569) * 86400000;
          const d = new Date(ms);              // treat as local-day, not UTC
          const y = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${y}-${mm}-${dd}`;
        }
      }

      // 4) Fallback: parse as LOCAL (avoid UTC toISOString shifts); normalize separators
      const guess = new Date(s.replace(/\//g, "-"));
      if (!isNaN(guess)) {
        const y = guess.getFullYear();
        const mm = String(guess.getMonth() + 1).padStart(2, "0");
        const dd = String(guess.getDate()).padStart(2, "0");
        return `${y}-${mm}-${dd}`;
      }

      // Last resort: return first 10 chars (keeps already-correct values)
      return s.slice(0, 10);
    }

    function numOrNull(v){if(v==null||v==='')return null;const n=Number(String(v).trim());return Number.isFinite(n)?n:null;}
    const FMT_USD=new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
    function pctText(v){ const n = Number(v ?? 0); return (n * 100).toFixed(2) + '%'; }
    function btcText(v){if(v==null){v=0;}return v.toLocaleString('en-US',{maximumFractionDigits:8})+' BTC';}
    function $footer(){return document.getElementById('chartFooter');}
    function clearChartFooter(){const el=$footer();if(el){el.innerHTML='';el.style.display='none';}}
    function setChartFooter(entries){
      const el=$footer(); if(!el) return;
      el.innerHTML='';
      if(!entries||!entries.length){el.style.display='none';return;}
      el.style.display='flex';
      entries.forEach(e=>{
        const b=document.createElement('div'); b.className='badge';
        const d=document.createElement('span'); d.className='dot'; d.style.backgroundColor=e.color||'#ccc';
        const t=document.createElement('span'); t.textContent=e.label+': '+e.value;
        const s=document.createElement('small'); s.textContent=e.date?(' ('+e.date+')'):'';
        b.appendChild(d); b.appendChild(t); b.appendChild(s); el.appendChild(b);
      });
    }
    function lastIndexNonNullInRange(arr,start,end){for(let i=end;i>=start;i--){const v=arr[i];if(v!==null&&v!==undefined&&!Number.isNaN(v))return i;}return-1;}

    /* ---------- Date slider ---------- */
    let chartInstance=null,currentLabels=[];
    const rangeWrap=()=>document.getElementById('chartRange');
    const rangeStartEl=()=>document.getElementById('rangeStart');
    const rangeEndEl=()=>document.getElementById('rangeEnd');
    const rangeStartLbl=()=>document.getElementById('rangeStartLabel');
    const rangeEndLbl=()=>document.getElementById('rangeEndLabel');
    function showRange(show){const el=rangeWrap();if(el)el.style.display=show?'block':'none';}
    function updateRangeUI(s,e){if(!currentLabels.length)return;rangeStartLbl().textContent=currentLabels[s]||'';rangeEndLbl().textContent=currentLabels[e]||'';}
    function applyRangeToChart(s,e){if(!chartInstance)return;chartInstance.options.scales.x.min=s;chartInstance.options.scales.x.max=e;chartInstance.update('none');rebuildFooterForChart(chartInstance);}
    function resetRangeToFull(){if(!currentLabels.length)return;const s=rangeStartEl(),e=rangeEndEl();s.value=0;e.value=currentLabels.length-1;updateRangeUI(0,currentLabels.length-1);applyRangeToChart(0,currentLabels.length-1);}
    function initOrUpdateRange(labels){
      currentLabels=labels||[];
      const s=rangeStartEl(),e=rangeEndEl(); if(!s||!e) return;
      if(currentLabels.length<=1){showRange(false);return;}
      s.min=0; e.min=0; s.max=currentLabels.length-1; e.max=currentLabels.length-1; s.value=0; e.value=currentLabels.length-1;
      showRange(true); updateRangeUI(0,currentLabels.length-1);
      if(!s._bound){ s.addEventListener('input',()=>{let sv=Number(s.value),ev=Number(e.value); if(sv>ev){ev=sv;e.value=ev;} updateRangeUI(sv,ev); applyRangeToChart(sv,ev);}); s._bound=true;}
      if(!e._bound){ e.addEventListener('input',()=>{let sv=Number(s.value),ev=Number(e.value); if(ev<sv){sv=ev;s.value=sv;} updateRangeUI(sv,ev); applyRangeToChart(sv,ev);}); e._bound=true;}
      applyRangeToChart(0,currentLabels.length-1);
    }

    /* ---------- Import logic ---------- */
    let existingDates=new Set(),previewRows=[];
    async function loadExistingDates(){
      if(!supabaseClient){return;}
      // Check if user is authenticated
      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        console.warn('[Import] User not authenticated. Please sign in via Administration tab.');
        showInlineError('inlineError','Please sign in via the Administration tab to access data.');
        return;
      }
      const res=await supabaseClient.from('daily_data').select('date_closing');
      if(res.error){console.error(res.error);showInlineError('inlineError','Error loading existing dates: '+res.error.message);return;}
      existingDates=new Set(res.data.map(r=>normalizeDate(r.date_closing)));
    }
    function renderPreview(){
      const c=document.getElementById('preview'); c.innerHTML='';
      const headers=['#','date_closing','btc_closing_price_usd','smoothed_risk_score','omega_score','omega_on_off','sab_below_neg_1sd','sab_below_neg_2sd','Status'];
      const t=document.createElement('table'); const th=t.createTHead().insertRow(); headers.forEach(h=>th.insertCell().textContent=h);
      const tb=t.createTBody();
      previewRows.forEach(r=>{
        const tr=tb.insertRow();
        headers.forEach(h=>{
          const td=tr.insertCell();
          if(h==='#') td.textContent=r.index;
          else if(h==='Status'){ td.textContent=r.isDuplicate?'Duplicate (skip)':'Ready'; td.className=r.isDuplicate?'status-duplicate':'status-ready'; }
          else td.textContent=r[h]||'';
        });
      });
      c.appendChild(t);
      document.getElementById('importBtn').style.display=previewRows.length?'inline-block':'none';
      document.getElementById('report').innerHTML='';
    }
    async function importRows(){
      if(!window.supabaseClient){ showInlineError('inlineError','Supabase not available.'); return; }
      
      // Check if authenticated
      const { data: { session } } = await window.supabaseClient.auth.getSession();
      if (!session?.user) {
        showInlineError('inlineError', 'Please sign in to import data.');
        return;
      }
      
      function toBool(v){ if(typeof v==='boolean')return v; const s=String(v==null?'':v).trim().toLowerCase(); return s==='true'||s==='1'||s==='yes'||s==='y'; }
      clearInlineError('inlineError');

      const guard=new Set(existingDates); const finalRows=[];
      previewRows.forEach(r=>{ const d=normalizeDate(r.date_closing); if(!guard.has(d)){ guard.add(d); finalRows.push(r);} });

      const toInsert=finalRows.map(r=>({
        date_closing:normalizeDate(r.date_closing),
        btc_closing_price_usd:numOrNull(r.btc_closing_price_usd),
        smoothed_risk_score:numOrNull(r.smoothed_risk_score),
        omega_score:numOrNull(r.omega_score),
        omega_on_off:toBool(r.omega_on_off),
        sab_below_neg_1sd:numOrNull(r.sab_below_neg_1sd),
        sab_below_neg_2sd:numOrNull(r.sab_below_neg_2sd)
      }));

      const rep=document.getElementById('report'); rep.textContent='Importing…';
      const up=await supabaseClient.from('daily_data')
        .upsert(toInsert, { onConflict:'date_closing', ignoreDuplicates:true })
        .select('date_closing'); // return inserted rows so we can count them
      let html='';
      if(up.error){
        html+='<p style="color:red;">Error: '+up.error.message+'</p>';
      }else{
        const inserted = Array.isArray(up.data) ? up.data.length : 0;
        const skippedClient=previewRows.filter(r=>r.isDuplicate).length;
        const attempted=toInsert.length;
        html+='<p style="color:green;">Inserted '+inserted+' new row'+(inserted!==1?'s':'')+'.</p>';
        html+='<p>Client-side skipped '+skippedClient+' duplicate row'+(skippedClient!==1?'s':'')+'.</p>';
        html+='<p>Ignored by DB (conflict) '+Math.max(0,attempted-inserted)+' row'+((attempted-inserted)!==1?'s':'')+'.</p>';
        await loadExistingDates();
      }
      rep.innerHTML=html;
      document.getElementById('importBtn').style.display='none';
    }

    /* ---------- Reports state & charts ---------- */
    /* ---------- Back-Testing (bt*) state & charts (cloned) ---------- */
    let btCurrentRunId = null;      // latest bt_run_id from ef_bt_execute
    let btAdvData = null;           // LTH PVR results: lth_pvr_bt.bt_results_daily
    let btStdData = null;           // Standard DCA results: lth_pvr_bt.bt_std_dca_balances
    let btCurrentReportType = 'holdings';
    let btChartInstance = null;

    function btDestroyChart() {
      // Destroy our tracked instance
      try {
        if (btChartInstance && typeof btChartInstance.destroy === 'function') {
          btChartInstance.destroy();
        }
      } catch (e) {
        console.warn('btDestroyChart: error destroying btChartInstance', e);
      }
      btChartInstance = null;

      // Extra safety: also destroy any chart still registered on this canvas
      try {
        if (window.Chart) {
          const canvas = document.getElementById('btPerfChart');
          if (canvas && typeof Chart.getChart === 'function') {
            const existing = Chart.getChart(canvas) || Chart.getChart('btPerfChart');
            if (existing && typeof existing.destroy === 'function') {
              existing.destroy();
            }
          }
        }
      } catch (e) {
        console.warn('btDestroyChart: error destroying registry chart', e);
      }
    }

    function btSetChartFooter(entries){
      const el = document.getElementById('btChartFooter');
      if (!el) return;
      el.innerHTML = '';
      if (!entries || !entries.length){ el.style.display='none'; return; }
      el.style.display='flex';
      entries.forEach(e=>{
        const b=document.createElement('div'); b.className='badge';
        const d=document.createElement('span'); d.className='dot'; d.style.backgroundColor=e.color||'#ccc';
        const t=document.createElement('span'); t.textContent=`${e.label}: ${e.value}`;
        const s=document.createElement('small'); s.textContent=e.date?(' ('+e.date+')'):'';
        b.appendChild(d); b.appendChild(t); b.appendChild(s); el.appendChild(b);
      });
    }

    function btApplyRangeToChart(s,e){
      if(!btChartInstance) return;
      btChartInstance.options.scales.x.min = s;
      btChartInstance.options.scales.x.max = e;
      btChartInstance.update('none');
      btRebuildFooterForChart(btChartInstance);
    }

    function btInitOrUpdateRange(labels){
      const wrap = document.getElementById('btChartRange');
      const s = document.getElementById('btRangeStart');
      const e = document.getElementById('btRangeEnd');
      if (!wrap || !s || !e) return;
      if (!labels || labels.length <= 1){ wrap.style.display='none'; return; }
      wrap.style.display='block';

      s.min=0; e.min=0; s.max=labels.length-1; e.max=labels.length-1;
      s.value=0; e.value=labels.length-1;

      const lbS = document.getElementById('btRangeStartLabel');
      const lbE = document.getElementById('btRangeEndLabel');
      const updateLabels = () => {
        if(lbS) lbS.textContent = labels[Number(s.value)] || '';
        if(lbE) lbE.textContent = labels[Number(e.value)] || '';
      };
      updateLabels();

      if(!s._bound){ s.addEventListener('input', ()=>{ if(+s.value > +e.value){ e.value = s.value; } updateLabels(); btApplyRangeToChart(+s.value,+e.value); }); s._bound=true; }
      if(!e._bound){ e.addEventListener('input', ()=>{ if(+e.value < +s.value){ s.value = e.value; } updateLabels(); btApplyRangeToChart(+s.value,+e.value); }); e._bound=true; }

      btApplyRangeToChart(0, labels.length-1);
    }

    // Simple renderer for the bt* block (mirrors your main one)
    function renderBtReportForCurrentState(){
      const noticeEl = document.getElementById('btChartNotice');
      const titleEl  = document.getElementById('btReportTitle');

      if (!btCurrentRunId){
        btDestroyChart();
        btSetCanvasVisible(false);
        btSetResetZoomEnabled(false);
        btClearChartFooter();
        btShowRange(false);

      if (noticeEl){
        noticeEl.textContent = 'Run a back-test to see results.';
        noticeEl.style.display = 'block';
      }
      if (titleEl) titleEl.textContent = '';
        return;
      }

      if (noticeEl){
        noticeEl.style.display = 'none';
      }
      btSetCanvasVisible(true);

      if (btCurrentReportType === 'holdings'){
        if (!btAdvData || !btAdvData.length){
          btDestroyChart();
          btSetCanvasVisible(false);
          btSetResetZoomEnabled(false);
          btClearChartFooter();
          btShowRange(false);

          if (noticeEl){
            noticeEl.textContent = 'No results found for this back-test run.';
            noticeEl.style.display = 'block';
          }
          if (titleEl) titleEl.textContent = '';
          return;
        }
        renderBtHoldingsChart(btAdvData, btCurrentRunId);
      } else if (btCurrentReportType === 'comp_value'){
        renderBTCompPortfolioValueChart(btAdvData || [], btStdData || [], btCurrentRunId);
      } else if (btCurrentReportType === 'comp_roi'){
        renderBTCompROIChart(btAdvData || [], btStdData || [], btCurrentRunId);
      } else if (btCurrentReportType === 'comp_agr'){
        renderBTCompAGRChart(btAdvData || [], btStdData || [], btCurrentRunId);
      }
    }

    function btSetReportTitle(btRunId){
      const el = document.getElementById('btReportTitle');
      if (!el) return;
      el.textContent = btRunId
        ? `LTH PVR BTC DCA Back-Test (Run #${btRunId})`
        : 'LTH PVR BTC DCA Back-Test';
    }

    function btSetResetZoomEnabled(on){const b=document.getElementById('btResetZoomBtn'); if(b) b.disabled=!on;}
    function btSetCanvasVisible(show){const c=document.getElementById('btPerfChart'); if(c) c.style.display=show?'block':'none';}
    function btShowChartNotice(msg){const n=document.getElementById('btChartNotice'); n.textContent=msg; n.style.display='block';}
    function btHideChartNotice(){const n=document.getElementById('btChartNotice'); n.textContent=''; n.style.display='none';}
    function btClearChartFooter(){const f=document.getElementById('btChartFooter'); if(f) f.innerHTML='';}
    function btShowRange(show){
      const box=document.getElementById('btChartRange');
      if(!box) return; box.style.display=show?'block':'none';
    }

    // --- New BT loaders: read from lth_pvr_bt.bt_results_daily / bt_std_dca_balances ---

    async function loadBtLthPvrResults(btRunId){
      if (!supabaseClient) return { data: [], error: { message: 'Supabase not available' } };
      if (!btRunId)        return { data: [], error: null };

      const btDb = supabaseClient.schema('lth_pvr_bt');
      const pageSize = 1000;
      let lastDate = null;
      let all = [];

      while (true) {
        let q = btDb
          .from('bt_results_daily')
          .select('*')
          .eq('bt_run_id', btRunId)
          .order('trade_date', { ascending: true })
          .limit(pageSize);
        if (lastDate) q = q.gt('trade_date', lastDate);

        const res = await q;
        if (res.error) return { data: all, error: res.error };
        if (!res.data || !res.data.length) break;

        all = all.concat(res.data);
        lastDate = res.data[res.data.length - 1].trade_date;
        if (res.data.length < pageSize) break;
      }
      return { data: all, error: null };
    }

    async function loadBtStdDcaResults(btRunId){
      if (!supabaseClient) return { data: [], error: { message: 'Supabase not available' } };
      if (!btRunId)        return { data: [], error: null };

      const btDb = supabaseClient.schema('lth_pvr_bt');
      const pageSize = 1000;
      let lastDate = null;
      let all = [];

      while (true) {
        let q = btDb
          .from('bt_std_dca_balances')
          .select('*')
          .eq('bt_run_id', btRunId)
          .order('trade_date', { ascending: true })
          .limit(pageSize);
        if (lastDate) q = q.gt('trade_date', lastDate);

        const res = await q;
        if (res.error) return { data: all, error: res.error };
        if (!res.data || !res.data.length) break;

        all = all.concat(res.data);
        lastDate = res.data[res.data.length - 1].trade_date;
        if (res.data.length < pageSize) break;
      }
      return { data: all, error: null };
    }

    // Single entry-point: load data for bt_run_id and refresh chart + table
    async function btLoadAndRenderFromRun(btRunId){
      btCurrentRunId = btRunId;
      btAdvData = null;
      btStdData = null;

      btDestroyChart();
      btSetCanvasVisible(false);
      btSetResetZoomEnabled(false);
      btClearChartFooter();
      btShowRange(false);

      if (!supabaseClient || !btRunId){
        renderBtReportForCurrentState();
        return;
      }

      const errId = 'btReportsError';
      clearInlineError(errId);

      try {
        const [lthRes, stdRes] = await Promise.all([
          loadBtLthPvrResults(btRunId),
          loadBtStdDcaResults(btRunId)
        ]);

        if (lthRes.error) {
          showInlineError(errId, lthRes.error.message || 'Could not load LTH PVR back-test results.');
        }
        if (stdRes.error) {
          showInlineError(errId, stdRes.error.message || 'Could not load Standard DCA back-test results.');
        }

        btAdvData = lthRes.data || [];
        btStdData = stdRes.data || [];

      } catch (e) {
        console.error('Error loading back-test results:', e);
        showInlineError(errId, e.message || 'Error loading back-test results.');
      }

      renderBtReportForCurrentState();
      await renderBtPerformanceTable(btRunId, btCurrentReportType);

      // expose for console debugging if needed
      window.btCurrentRunId = btRunId;
      window.btAdvData = btAdvData;
      window.btStdData = btStdData;
    }

    async function loadBtAdvTransactions(customerId){
      if(!supabaseClient) return {data:[],error:{message:'Supabase not available'}};
      const pageSize=1000; let lastDate=null; let all=[];
      while(true){
        let q=supabaseClient.from('adv_dca_customer_transactions')
          .select('transaction_date, btc_closing_price_usd, total_dca_invested_usd, portfolio_value_usd, closing_balance_usd, closing_balance_btc, total_roi_percent, cagr_percent')
          .eq('customer_id',customerId).order('transaction_date',{ascending:true}).limit(pageSize);
        if(lastDate) q=q.gt('transaction_date', lastDate);
        const res=await q; if(res.error) return {data:all,error:res.error};
        if(!res.data||res.data.length===0) break;
        all=all.concat(res.data); lastDate=res.data[res.data.length-1].transaction_date;
        if(res.data.length<pageSize) break;
      }
      return {data:all,error:null};
    }

    // ===== LTH PVR Back-Testing (bt_runs / bt_params / ef_bt_execute) =====

    function btPctToBps(pctStr){
      if (pctStr === null || pctStr === undefined) return 0;
      const n = parseFloat(String(pctStr).replace(',', '.'));
      if (!isFinite(n)) return 0;
      // 1% = 100 bps, so 0.08% => 8 bps
      return Math.round(n * 100);
    }

    function initBtRunForm(){
      const strategySel   = document.getElementById('btStrategySelect');
      const startEl       = document.getElementById('btStartDate');
      const endEl         = document.getElementById('btEndDate');
      const upfrontEl     = document.getElementById('btUpfrontUsdt');
      const monthlyEl     = document.getElementById('btMonthlyUsdt');
      const tradeFeeEl    = document.getElementById('btBtcFeePct');
      const contribFeeEl  = document.getElementById('btContribFeePct');
      const runBtn        = document.getElementById('btRunBtn');

      // Force strategy to LTH PVR for now (ADV DCA is "coming soon")
      if (strategySel) {
        strategySel.value = 'LTH_PVR';
      }

      // Defaults, only if the user hasn’t already typed something
      if (upfrontEl && !upfrontEl.value)       upfrontEl.value    = '0';
      if (monthlyEl && !monthlyEl.value)       monthlyEl.value    = '30';
      if (tradeFeeEl && !tradeFeeEl.value)     tradeFeeEl.value   = '0.08';
      if (contribFeeEl && !contribFeeEl.value) contribFeeEl.value = '0.18';

      if (runBtn && !runBtn._bound){
        runBtn.addEventListener('click', (e)=>{
          e.preventDefault();
          handleBtRunClick();
        });
        runBtn._bound = true;
      }
    }

    async function handleBtRunClick(){
      const errId = 'btInlineError';
      clearInlineError(errId);

      if (!supabaseClient){
        showInlineError(errId, 'Supabase client not available in this environment.');
        return;
      }
      
      // Check if authenticated
      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        showInlineError(errId, 'Please sign in to run backtests.');
        return;
      }

      const strategySel   = document.getElementById('btStrategySelect');
      const startEl       = document.getElementById('btStartDate');
      const endEl         = document.getElementById('btEndDate');
      const upfrontEl     = document.getElementById('btUpfrontUsdt');
      const monthlyEl     = document.getElementById('btMonthlyUsdt');
      const tradeFeeEl    = document.getElementById('btBtcFeePct');
      const contribFeeEl  = document.getElementById('btContribFeePct');
      const runBtn        = document.getElementById('btRunBtn');

      const strategy = strategySel ? (strategySel.value || 'LTH_PVR') : 'LTH_PVR';
      if (strategy !== 'LTH_PVR'){
        showInlineError(errId, 'Only "LTH PVR BTC DCA" is supported right now.');
        return;
      }

      const startDate = startEl && startEl.value ? startEl.value : '';
      const endDate   = endEl   && endEl.value   ? endEl.value   : '';

      if (!startDate || !endDate){
        showInlineError(errId, 'Please select both a Start Date and an End Date.');
        return;
      }

      if (new Date(endDate) <= new Date(startDate)){
        showInlineError(errId, 'End Date must be after Start Date.');
        return;
      }

      const upfront  = upfrontEl  ? (parseFloat(upfrontEl.value || '0')  || 0) : 0;
      const monthly  = monthlyEl  ? (parseFloat(monthlyEl.value || '0')  || 0) : 0;
      
      // Exchange fees are in basis points (8 bps, 18 bps)
      const tradeBps = tradeFeeEl ? (parseFloat(tradeFeeEl.value || '8') || 8) : 8;
      const contrBps = contribFeeEl ? (parseFloat(contribFeeEl.value || '18') || 18) : 18;

      const maker_bps_trade   = tradeBps;      // Already in basis points (e.g., 8 bps = 0.08%)
      const maker_bps_contrib = contrBps;      // Already in basis points (e.g., 18 bps = 0.18%)

      // org_id – try customersCache first, then fall back to my_orgs RPC
      let orgId = null;
      try {
        if (Array.isArray(customersCache) && customersCache.length > 0 && customersCache[0].org_id){
          orgId = customersCache[0].org_id;
        }
      } catch(_) { /* ignore */ }

      if (!orgId){
        try {
          const { data, error } = await supabaseClient.rpc('my_orgs');
          if (!error && Array.isArray(data) && data.length > 0 && data[0].id){
            orgId = data[0].id;
          }
        } catch(e){
          console.error('Unable to fetch org via my_orgs', e);
        }
      }

      if (!orgId){
        showInlineError(errId, 'Unable to determine your organisation (org_id). Please ensure you belong to an organisation.');
        return;
      }

      const originalLabel = runBtn ? runBtn.textContent : '';
      if (runBtn){
        runBtn.disabled = true;
        runBtn.textContent = 'Running…';
      }

      try{
        // 1) Create bt_runs row
        // One helper at the top of handleBtRunClick (or outside, reused):
        const btDb = supabaseClient.schema('lth_pvr_bt');

        // Then use btDb for all lth_pvr_bt tables:
        const { data: runRow, error: runErr } = await btDb
          .from('bt_runs')                     // ✅ table name only
          .insert({
            org_id:        orgId,
            status:        'running'
          })
          .select('bt_run_id')
          .single();


        if (runErr) throw runErr;
        const bt_run_id = runRow.bt_run_id;
        if (!bt_run_id){
          throw new Error('Back-test run did not return a bt_run_id.');
        }

        // 2) Create bt_params row for this run (in lth_pvr_bt schema)
        const platformFeePct = parseFloat(document.getElementById('btPlatformFeePct')?.value || 0.75) / 100;
        const performanceFeePct = parseFloat(document.getElementById('btPerformanceFeePct')?.value || 10) / 100;
        
        const { error: paramsErr } = await btDb
          .from('bt_params')
          .insert({
          bt_run_id,
          start_date:            startDate,
          end_date:              endDate,
          upfront_contrib_usdt:  upfront,
          monthly_contrib_usdt:  monthly,
          maker_bps_trade,
          maker_bps_contrib,
          platform_fee_pct:      platformFeePct,      // BitWealth platform fee (0.75% default)
          performance_fee_pct:   performanceFeePct    // BitWealth performance fee (10% default)
          // B1–B11 + momentum / gating stay on DB defaults for now (aligned with EF / Python)
        });

        if (paramsErr) throw paramsErr;

        // 3) Call ef_bt_execute for this bt_run_id
        const { error: fnErr } = await supabaseClient.functions.invoke('ef_bt_execute', {
          body: { bt_run_id }
        });

        if (fnErr) throw fnErr;

        // 4) Expose bt_run_id and immediately load charts/tables from bt_* tables
        window.btCurrentRunId = bt_run_id;
        btCurrentRunId = bt_run_id;

        await btLoadAndRenderFromRun(bt_run_id);

        showInlineError(errId, `Back-test completed successfully (Run #${bt_run_id}).`);

      }catch(err){
        console.error('Back-test failed:', err);
        showInlineError(errId, err.message || 'Back-test failed. Please check the console for details.');
      }finally{
        if (runBtn){
          runBtn.disabled = false;
          runBtn.textContent = originalLabel || 'Run Back-Test';
        }
      }
    }

    async function loadBtStdPortfolio(customerId){
      if(!supabaseClient) return {data:[],error:{message:'Supabase not available'}};
      const pageSize=1000; let lastDate=null; let all=[];
      while(true){
        let q=supabaseClient.from('std_dca_customer_transactions')
          .select('transaction_date, portfolio_value_usd, total_roi_percent, cagr_percent')
          .eq('customer_id',customerId).order('transaction_date',{ascending:true}).limit(pageSize);
        if(lastDate) q=q.gt('transaction_date', lastDate);
        const res=await q; if(res.error) return {data:all,error:res.error};
        if(!res.data||res.data.length===0) break;
        all=all.concat(res.data); lastDate=res.data[res.data.length-1].transaction_date;
        if(res.data.length<pageSize) break;
      }
      return {data:all,error:null};
    }

    async function handleBtCustomerChange(e){
      if(btChartInstance){ btChartInstance.destroy(); btChartInstance=null; }
      btSetResetZoomEnabled(false); btClearChartFooter(); btShowRange(false);
      btCurrentCustomerId = e.target.value;
      if(!btCurrentCustomerId){
        btCurrentFirst=''; btCurrentLast=''; btAdvData=null; btStdData=null; renderBtReportForCurrentState(); return;
      }
      const found = customersCache.find(c=>String(c.customer_id)===String(btCurrentCustomerId));
      btCurrentFirst = found?.first_names || ''; btCurrentLast = found?.last_name || '';

      const advRes = await loadBtAdvTransactions(btCurrentCustomerId);
      const stdRes = await loadBtStdPortfolio(btCurrentCustomerId);
      if(advRes.error){ showInlineError('btReportsError', advRes.error.message); }
      if(stdRes.error){ showInlineError('btReportsError', stdRes.error.message); }

      btAdvData = advRes.data || [];
      btStdData = stdRes.data || [];
      try { renderBtReportForCurrentState(); }
      catch (e) { console.error('BT chart error:', e); }
      await renderBtPerformanceTable(btCurrentCustomerId, btCurrentReportType);
    }

    (function bindBtReportTypeChange(){
      const sel = document.getElementById('btReportTypeSelect');
      if (!sel || sel._bound) return;
      sel.addEventListener('change', async (e) => {
        btCurrentReportType = e.target.value || 'holdings';
        renderBtReportForCurrentState();
        await renderBtPerformanceTable(btCurrentRunId, btCurrentReportType);
      });
      sel._bound = true;
    })();

    /* Holdings chart (Back-Testing) – LTH PVR vs contributions / balances */
    function renderBtHoldingsChart(rows, btRunId){
      if (!hasChart){
        showInlineError('btReportsError','Chart.js is not available.');
        return;
      }
      btDestroyChart();

      const canvas = document.getElementById('btPerfChart');
      const ctx    = canvas.getContext('2d');

      const labels   = rows.map(r => normalizeDate(r.trade_date));
      const sPrice   = rows.map(r => numOrNull(r.price_usd));
      const sContrib = rows.map(r => numOrNull(r.contrib_gross_usdt_cum));
      const sNav     = rows.map(r => numOrNull(r.nav_usd));
      const sUsd     = rows.map(r => numOrNull(r.usdt_balance));
      const sBtc     = rows.map(r => numOrNull(r.btc_balance));

      btSetReportTitle(btRunId);

      // local formatters for the axes
      const usdFmt = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        maximumFractionDigits: 0
      });
      const btcFmt = new Intl.NumberFormat('en-US', {
        maximumFractionDigits: 8
      });

      // local gradient helper (same pattern as your main holdings chart)
      const grad = (hex, top = 0.18, bottom = 0) => {
        const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, hexToRGBA(hex, top));
        g.addColorStop(1, hexToRGBA(hex, bottom));
        return g;
      };

      // zoom plugin (same pattern as elsewhere)
      let zoomReg = false;
      try {
        const Z = window['chartjs-plugin-zoom'];
        if (Z && !Chart.registry.plugins.get('zoom')) {
          Chart.register(Z);
        }
        zoomReg = !!Chart.registry.plugins.get('zoom');
      } catch (e) {
        zoomReg = false;
      }

      const tickColor = cssVar('--ink-soft') || '#6B7280';
      const gridColor = cssVar('--border-subtle') || '#E5E7EB';

      btChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'BTC Price',
              data: sPrice,
              borderColor: cssVar('--series-btc-price'),
              backgroundColor: 'transparent',
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            },
            {
              label: 'Total Contributions',
              data: sContrib,
              borderColor: cssVar('--series-invested'),
              backgroundColor: 'transparent',
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            },
            {
              label: 'LTH PVR DCA NAV',
              data: sNav,
              borderColor: cssVar('--series-adv-value'),
              backgroundColor: grad(cssVar('--series-adv-value'), 0.14, 0),
              fill: true,
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            },
            {
              label: 'USDT Balance',
              data: sUsd,
              borderColor: cssVar('--series-usd-balance'),
              backgroundColor: grad(cssVar('--series-usd-balance'), 0.12, 0),
              fill: true,
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            },
            {
              label: 'BTC Balance',
              data: sBtc,
              borderColor: cssVar('--series-btc-balance'),
              backgroundColor: 'transparent',
              yAxisID: 'y1',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            }
          ]
        },
        options: {
          responsive: true,
          layout: { padding: { top: 8, right: 14, bottom: 8, left: 12 } },
          interaction: { mode: 'index', intersect: false },
          animation: false,
          scales: {
            x: {
              title: { display: true, text: 'Trade Date' },
              ticks: { color: tickColor, maxRotation: 0, autoSkipPadding: 20 },
              grid: { color: gridColor },
              min: 0,
              max: labels.length - 1
            },
            y: {
              title: { display: true, text: 'USD' },
              position: 'left',
              ticks: {
              color: tickColor,
              callback: (v) => usdFmt.format(v)
            },
            grid: { color: gridColor }
          },
          y1: {
            title: { display: true, text: 'BTC' },
            position: 'right',
            ticks: {
              color: tickColor,
              callback: (v) => btcFmt.format(v) + ' BTC'
            },
            grid: { drawOnChartArea: false, color: gridColor }
          }
        },
        plugins: {
          legend: legendWithFading(),
          title: { display: false },
          decimation: { enabled: true, algorithm: 'lttb', samples: 2000 },
          zoom: {
            pan: { enabled: zoomReg, mode: 'x' },
            zoom: {
              wheel: { enabled: zoomReg },
              pinch: { enabled: zoomReg },
              mode: 'x'
            }
          }
        }
      }
    });

    btInitOrUpdateRange(labels);
    btRebuildFooterForChart(btChartInstance);
    btSetResetZoomEnabled(zoomReg && typeof btChartInstance.resetZoom === 'function');
    }

    /* Comparison – Portfolio Value (LTH PVR vs Standard DCA) */
    function renderBTCompPortfolioValueChart(lthRows, stdRows, btRunId) {
      if (!hasChart) {
        showInlineError('btReportsError', 'Chart.js is not available.');
        return;
      }
      btDestroyChart();

      const canvas = document.getElementById('btPerfChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      // Collect all trade dates from both series
      const dateSet = new Set();
      (lthRows || []).forEach(r => dateSet.add(normalizeDate(r.trade_date)));
      (stdRows || []).forEach(r => dateSet.add(normalizeDate(r.trade_date)));
      const labels = Array.from(dateSet).sort();

      if (!labels.length) {
        btSetChartFooter([]);
        btShowRange(false);
        document.getElementById('btChartNotice').textContent = 'No data to display for this back-test.';
        document.getElementById('btChartNotice').style.display = 'block';
        document.getElementById('btReportTitle').textContent = '';
        return;
      }

      // Map NAV by date
      const lthMap = Object.create(null);
      (lthRows || []).forEach(r => {
        const d = normalizeDate(r.trade_date);
        const v = numOrNull(r.nav_usd);
        if (v != null) lthMap[d] = v;
      });

      const stdMap = Object.create(null);
      (stdRows || []).forEach(r => {
        const d = normalizeDate(r.trade_date);
        const v = numOrNull(r.nav_usd);
        if (v != null) stdMap[d] = v;
      });

      const lthSeries = labels.map(d => (d in lthMap ? lthMap[d] : null));
      const stdSeries = labels.map(d => (d in stdMap ? stdMap[d] : null));

      // ✅ Formatter that was missing
      const usdFmt = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        maximumFractionDigits: 0
      });

      // Title
      btSetReportTitle(btRunId);

      // Enable zoom plugin if available
      let zoomReg = false;
      try {
        const Z = window['chartjs-plugin-zoom'];
        if (Z && !Chart.registry.plugins.get('zoom')) {
          Chart.register(Z);
        }
        zoomReg = !!Chart.registry.plugins.get('zoom');
      } catch (e) {
        zoomReg = false;
      }

      const gridColor = cssVar('--grid') || '#F2F2F2';
      const tickColor = cssVar('--muted') || '#6b7280';

      btChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'LTH PVR BTC DCA NAV',
              data: lthSeries,
              borderColor: cssVar('--series-adv-value') || '#22c55e',
              backgroundColor: 'transparent',
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: 0.22,
              borderWidth: 2
            },
            {
              label: 'Standard DCA NAV',
              data: stdSeries,
              borderColor: cssVar('--series-invested') || '#6366f1',
              backgroundColor: 'transparent',
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: 0.22,
              borderWidth: 2
            }
          ]
        },
        options: {
          responsive: true,
          layout: { padding: { top: 8, right: 14, bottom: 8, left: 12 } },
          interaction: { mode: 'index', intersect: false },
          animation: false,
          scales: {
            x: {
              title: { display: true, text: 'Trade Date' },
              ticks: { color: tickColor, maxRotation: 0, autoSkipPadding: 20 },
              grid: { color: gridColor },
              min: 0,
              max: labels.length - 1
            },
            y: {
              title: { display: true, text: 'Portfolio Value (USD)' },
              position: 'left',
              ticks: {
                color: tickColor,
                callback: v => usdFmt.format(v)
              },
              grid: { color: gridColor }
            }
          },
          plugins: {
            legend: legendWithFading(),
            title: { display: false },
            decimation: { enabled: true, algorithm: 'lttb', samples: 2000 },
            zoom: {
              pan: { enabled: zoomReg, mode: 'x' },
              zoom: {
                wheel: { enabled: zoomReg },
                pinch: { enabled: zoomReg },
                mode: 'x'
              }
            }
          }
        }
      });

      btInitOrUpdateRange(labels);
      btRebuildFooterForChart(btChartInstance);
      btSetResetZoomEnabled(zoomReg && typeof btChartInstance.resetZoom === 'function');
    }

    /* Comparison – ROI (BT) */
    function renderBTCompROIChart(advRows,stdRows,btRunId){
      if (!hasChart){
        showInlineError('btReportsError','Chart.js is not available.');
        return;
      }
      btDestroyChart();

      const canvas = document.getElementById('btPerfChart');
      const ctx    = canvas.getContext('2d');

      const setDates = new Set();
      (advRows || []).forEach(r => setDates.add(normalizeDate(r.trade_date)));
      (stdRows || []).forEach(r => setDates.add(normalizeDate(r.trade_date)));
      const labels = Array.from(setDates).sort();

      const lthMap = new Map();
      const stdMap = new Map();
      (advRows || []).forEach(r => lthMap.set(normalizeDate(r.trade_date), numOrNull(r.total_roi_percent)));
      (stdRows || []).forEach(r => stdMap.set(normalizeDate(r.trade_date), numOrNull(r.total_roi_percent)));

      const sLth = labels.map(d => lthMap.has(d) ? lthMap.get(d) : null);
      const sStd = labels.map(d => stdMap.has(d) ? stdMap.get(d) : null);

      btSetReportTitle(btRunId);

      const tickColor = cssVar('--ink-soft') || '#6B7280';
      const gridColor = cssVar('--border-subtle') || '#E5E7EB';

      btChartInstance = new Chart(ctx,{
        type:'line',
        data:{
          labels,
          datasets:[
            { label:'LTH PVR DCA ROI', data:sLth, borderColor:cssVar('--series-adv-value'), backgroundColor:'transparent', yAxisID:'y', pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2 },
            { label:'Standard DCA ROI', data:sStd, borderColor:cssVar('--series-std-value'), backgroundColor:'transparent', yAxisID:'y', pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2 }
          ]
        },
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{
              title:{display:true,text:'Trade Date'},
              ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},
              grid:{color:gridColor},
              min:0,
              max:labels.length-1
            },
            y:{
              title:{display:true,text:'ROI %'},
              position:'left',
              ticks:{color:tickColor,callback:(v)=> (v==null ? '–' : `${Number(v).toFixed(2)}%`)},
              grid:{color:gridColor}
            }
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:true,text:'ROI – LTH PVR DCA vs Standard DCA'},
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:true,mode:'x'},zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'x'}}
          }
        }
      });

      btInitOrUpdateRange(labels);
      btRebuildFooterForChart(btChartInstance);
      btSetResetZoomEnabled(typeof btChartInstance.resetZoom === 'function');
    }

    /* Comparison – CAGR (BT) */
    function renderBTCompAGRChart(advRows,stdRows,btRunId){
      if (!hasChart){
        showInlineError('btReportsError','Chart.js is not available.');
        return;
      }
      btDestroyChart();

      const canvas = document.getElementById('btPerfChart');
      const ctx    = canvas.getContext('2d');

      const setDates = new Set();
      (advRows || []).forEach(r => setDates.add(normalizeDate(r.trade_date)));
      (stdRows || []).forEach(r => setDates.add(normalizeDate(r.trade_date)));
      const labels = Array.from(setDates).sort();

      const lthMap = new Map();
      const stdMap = new Map();
      (advRows || []).forEach(r => lthMap.set(normalizeDate(r.trade_date), numOrNull(r.cagr_percent)));
      (stdRows || []).forEach(r => stdMap.set(normalizeDate(r.trade_date), numOrNull(r.cagr_percent)));

      const sLth = labels.map(d => lthMap.has(d) ? lthMap.get(d) : null);
      const sStd = labels.map(d => stdMap.has(d) ? stdMap.get(d) : null);

      btSetReportTitle(btRunId);

      const tickColor = cssVar('--ink-soft') || '#6B7280';
      const gridColor = cssVar('--border-subtle') || '#E5E7EB';

      btChartInstance = new Chart(ctx,{
        type:'line',
        data:{
          labels,
          datasets:[
            { label:'LTH PVR DCA CAGR', data:sLth, borderColor:cssVar('--series-adv-value'), backgroundColor:'transparent', yAxisID:'y', pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2 },
            { label:'Standard DCA CAGR', data:sStd, borderColor:cssVar('--series-std-value'), backgroundColor:'transparent', yAxisID:'y', pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2 }
          ]
        },
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{
              title:{display:true,text:'Trade Date'},
              ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},
              grid:{color:gridColor},
              min:0,
              max:labels.length-1
            },
            y:{
              title:{display:true,text:'CAGR %'},
              position:'left',
              ticks:{color:tickColor,callback:(v)=> (v==null ? '–' : `${Number(v).toFixed(2)}%`)},
              grid:{color:gridColor}
            }
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:true,text:'CAGR – LTH PVR DCA vs Standard DCA'},
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:true,mode:'x'},zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'x'}}
          }
        }
      });

      btInitOrUpdateRange(labels);
      btRebuildFooterForChart(btChartInstance);
      btSetResetZoomEnabled(typeof btChartInstance.resetZoom === 'function');
    }

    function btRebuildFooterForChart(chart){
      const labels = chart.data.labels || [];
      if(!labels.length){ btClearChartFooter(); return; }

      const sEl = document.getElementById('btRangeStart');
      const eEl = document.getElementById('btRangeEnd');

      let start = 0, end = labels.length - 1;
      if (sEl && eEl && Number(eEl.max) === labels.length - 1) {
        start = Math.min(Number(sEl.value), Number(eEl.value));
        end   = Math.max(Number(sEl.value), Number(eEl.value));
      }

      const entries = [];
      chart.data.datasets.forEach((d, i) => {
        if(!chart.isDatasetVisible(i)) return;
        const arr = d.data || [];
        for (let ii=end; ii>=start; ii--){
          const v = arr[ii];
          if (v!==null && v!==undefined && !Number.isNaN(v)) {
            const val = d.yAxisID==='y1'
              ? (Number(v).toLocaleString('en-US',{maximumFractionDigits:8})+' BTC')
              : ((/ROI|Growth|%|CAGR/i.test(d.label||''))
                 ? (Number(v).toFixed(2)+'%')
                 : new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0}).format(Number(v)));

            entries.push({ label:d.label, value:val, date:labels[ii]||'', color:d.borderColor });
            break;
          }
        }
      });

      btSetChartFooter(entries);
    }

    let currentCustomerId='',currentFirst='',currentLast='',advData=null,stdData=null,currentReportType='holdings';
    let customersCache=[],customerChoices=null,reportTypeChoices=null,txCustomerChoices=null;

    // Org / portfolio / customer context
    let orgsCache = [];
    let allPortfoliosCache = [];
    let strategiesNameByCode = {}; // { [strategy_code]: strategies.name }
    let currentOrgId = null;
    let currentPortfolioId = null;
    let currentStrategyCode = null;

    /* Track active module in <body data-active-module="..."> so CSS can react */
    function bwSetActiveModuleFlag(){
      const hash = (location.hash || '').replace('#','');
      document.body.setAttribute('data-active-module', hash || '');
    }
    window.addEventListener('hashchange', bwSetActiveModuleFlag);
    bwSetActiveModuleFlag();

    // Strategy-specific UI visibility helper.
    // Any element with data-strategy="CODE[,OTHER]" will only be shown when
    // currentStrategyCode matches one of the codes (case-insensitive).
    function updateStrategyVisibility(){
      const active = (currentStrategyCode || '').toString().toUpperCase();
      const els = document.querySelectorAll('[data-strategy]');
      els.forEach(el => {
        const raw = (el.getAttribute('data-strategy') || '').toUpperCase();
        const allowed = raw.split(',').map(s => s.trim()).filter(Boolean);
        // If an element has data-strategy set, only show it when a strategy is actually selected.
        const show = !allowed.length || (active && allowed.includes(active));
        if (show){
          el.classList.remove('strategy-hidden');
        } else {
          el.classList.add('strategy-hidden');
        }
      });
      
      // Update "no strategy selected" message for Strategy Maintenance module
      if (typeof window.strategyMaintenance?.updateNoStrategyMessage === 'function') {
        window.strategyMaintenance.updateNoStrategyMessage();
      }
    }

    // Loads organisation(s) via my_orgs(), then portfolios via list_customer_portfolios()
    // Falls back to one pseudo-portfolio per active customer if the RPC is not present yet.
    async function loadOrgContext(){
      // Set flag to prevent strategy maintenance from reacting to programmatic changes
      window.programmaticallyUpdatingContext = true;
      
      const orgSel  = document.getElementById('orgSelect');
      const portSel = document.getElementById('portfolioSelect');
      const custSel = document.getElementById('customerSelect');
      if(!orgSel || !portSel) {
        window.programmaticallyUpdatingContext = false;
        return;
      }

      // Multi-customer modules: Customer Transactions and Strategy Maintenance
      const isMultiCustomerModule = () => {
        const hash = location.hash;
        return hash === '#transactions-module' || hash === '#strategy-maintenance-module';
      };

      function setPortPlaceholder(txt){
        portSel.innerHTML = `<option value="">${txt}</option>`;
        portSel.disabled = true;
        currentPortfolioId = null;
        currentStrategyCode = null;
        window.currentStrategyCode = null;
        updateStrategyVisibility();
      }

      function buildStrategyOptionsForTransactions(){
        // Build the strategy list dynamically from the portfolios view (preferred),
        // falling back to a small hard-coded map if the view doesn’t provide names.
        const fallbackName = (code) => {
          const map = {
            'ADV_DCA': 'Advanced BTC DCA',
            'LTH_PVR': 'LTH PVR BTC DCA'
          };
          return map[code] || code;
        };

        const byCode = new Map();

        (allPortfoliosCache || []).forEach(p => {
          const code = String(p.strategy_code || '').toUpperCase();
          if (!code) return;

          const name =
            (p.strategy_name || p.strategy_label || p.strategy_display_name || p.strategy_title || '')
              .toString()
              .trim();

          // keep first name we find, but prefer a real name over fallback
          if (!byCode.has(code)) {
            byCode.set(code, name || fallbackName(code));
          } else if (name && byCode.get(code) === fallbackName(code)) {
            byCode.set(code, name);
          }
        });

        const items = Array.from(byCode.entries())
          .map(([code, name]) => ({ code, name: name || fallbackName(code) }))
          .sort((a,b) => a.name.localeCompare(b.name));

        console.log('📋 Strategy items built:', items);

        portSel.innerHTML =
          ['<option value="">Select strategy…</option>']
            .concat(items.map(i => `<option value="${i.code}">${i.name}</option>`))
            .join('');

        console.log('✅ Portfolio selector HTML:', portSel.innerHTML);

        portSel.disabled = items.length === 0;

        // do NOT auto-select a strategy
        currentPortfolioId = null;
        currentStrategyCode = null;
        window.currentStrategyCode = null;
        updateStrategyVisibility();
      }

      function buildPortfolioOptionsForCustomer(customerId){
        if (!customerId){
          setPortPlaceholder('Select customer first…');
          return;
        }

        const ports = (allPortfoliosCache || []).filter(p => String(p.customer_id) === String(customerId));
        if(!ports.length){
          setPortPlaceholder('No portfolios for customer');
          return;
        }

        portSel.innerHTML = ports.map(p => {
          const portLabel = (p.label || p.portfolio_label || p.portfolio_name || '').toString().trim();
          const code = p.strategy_code ? String(p.strategy_code).toUpperCase() : '';
          const stratName =
            (p.strategy_name || p.strategy_label || p.strategy_display_name || p.strategy_title || '').toString().trim();

          const text = stratName
            ? `${portLabel} — ${stratName}`
            : (code ? `${portLabel} — ${code}` : portLabel);

          const dataCode = code || '';

          // IMPORTANT: embed the strategy code on the option itself
          // Use customer_strategy_id as primary ID (portfolio_id may be NULL)
          const strategyId = p.customer_strategy_id || p.portfolio_id;
          return `<option value="${strategyId}" data-strategy-code="${dataCode}">${text}</option>`;
        }).join('');

        portSel.disabled=false;

        // auto select first portfolio (OK for non-transactions modules)
        const firstStrategyId = ports[0].customer_strategy_id || ports[0].portfolio_id;
        portSel.value = firstStrategyId;
        currentPortfolioId = firstStrategyId;
        currentStrategyCode = ports[0].strategy_code ? String(ports[0].strategy_code).toUpperCase() : null;
        window.currentStrategyCode = currentStrategyCode;
        updateStrategyVisibility();
      }

      function applyContextMode(){
        const custGroup = document.getElementById('ctxCustomerGroup');

        if (isMultiCustomerModule()){
          // Multi-customer modules → hide customer selector
          if (custGroup) custGroup.style.display = 'none';

          if (custSel){
            custSel.disabled = true;
            custSel.setAttribute('disabled', 'disabled');
          }

          buildStrategyOptionsForTransactions();
        } else {
          // All other modules → show customer selector
          if (custGroup) custGroup.style.display = '';

          if (custSel){
            custSel.disabled = false;
            custSel.removeAttribute('disabled');
          }

          const cid = custSel ? (custSel.value || '') : '';
          buildPortfolioOptionsForCustomer(cid);
        }
      }

      if(!supabaseClient){
        orgSel.innerHTML='<option value="">Supabase not ready</option>';
        portSel.innerHTML='<option value="">Supabase not ready</option>';
        orgSel.disabled=true; portSel.disabled=true;
        return;
      }
      
      // Check if authenticated
      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        orgSel.innerHTML='<option value="">Sign in to load organisations</option>';
        portSel.innerHTML='<option value="">Sign in first</option>';
        orgSel.disabled=true; portSel.disabled=true;
        console.warn('[Context] Not authenticated, skipping org context load');
        return;
      }

      try{
        // orgs (best-effort; portfolios do NOT depend on this)
        let orgs = [];
        try{
          const { data, error } = await supabaseClient.rpc('my_orgs');
          if (error) throw error;
          orgs = Array.isArray(data) ? data : [];
        }catch(_e){
          // fallback if my_orgs doesn't exist
          try{
            const orgRes = await supabaseClient.rpc('list_organisations');
            orgs = Array.isArray(orgRes.data) ? orgRes.data : [];
          }catch(_e2){
            orgs = [];
          }
        }

        const activeOrg =
          orgs.find(o => String(o.organisation_status||o.organisation_status_code||'Active').toLowerCase()==='active')
          || orgs[0]
          || null;

        const getOrgId   = (o) => (o ? (o.organisation_id || o.org_id || o.id) : null);
        const getOrgName = (o) => (o ? (o.organisation_name || o.org_name || o.name || String(getOrgId(o)||'')) : '');

        const activeOrgId = getOrgId(activeOrg);

        orgSel.innerHTML = orgs.length
          ? orgs.map(o=>{
              const id = getOrgId(o);
              const name = getOrgName(o);
              return `<option value="${id}" ${String(id)===String(activeOrgId)?'selected':''}>${name}</option>`;
            }).join('')
          : '<option value="">No organisations</option>';

        // keep disabled unless you truly have multiple orgs
        orgSel.disabled = !(orgs.length > 1);

        // portfolios (use consolidated customer_strategies table)
        const orgId = activeOrgId || null;

        let portfolios = [];
        let portErr = null;

        // Query customer_strategies table directly (customer_portfolios view removed)
        try{
          let q = supabaseClient
            .schema('public')
            .from('customer_strategies')
            .select('customer_strategy_id, org_id, customer_id, strategy_code, label, exchange_account_id, exchange_subaccount, status, created_at, closed_at, portfolio_id');

            if (orgId) q = q.eq('org_id', orgId);

            const { data, error } = await q.order('label', { ascending: true });
            if (error) throw error;
            portfolios = Array.isArray(data) ? data : [];
        }catch(err){
          portErr = err;
          portfolios = [];
          console.warn('Failed to load portfolios from customer_strategies table.', err);
        }

        // normalize + client-side sort (keeps it robust if the view has different column names)
        portfolios = (portfolios || [])
          // if the row has a status column, only keep active
          .filter(p => !p.status || String(p.status).toLowerCase() === 'active')
          .map(p => ({
            ...p,
            // normalize strategy_code casing
            strategy_code: p.strategy_code ? String(p.strategy_code).toUpperCase() : p.strategy_code
          }))
          .sort((a,b) => {
            const al = String(a.label || a.portfolio_label || a.portfolio_name || '').toLowerCase();
            const bl = String(b.label || b.portfolio_label || b.portfolio_name || '').toLowerCase();
            return al.localeCompare(bl);
          });

        portfoliosCache = portfolios;
        allPortfoliosCache = portfolios.slice();

        // If nothing loaded, keep portfolio disabled but customer still usable
        if(!allPortfoliosCache.length){
          setPortPlaceholder('No portfolios');
          console.warn('No portfolios loaded for org:', orgId, portErr);
        }

        // portfolio/strategy change
        if(!portSel._bound){
          portSel.addEventListener('change', (e)=>{
            const v = e.target.value || '';
            console.log('🎯 Context bar portfolio change - raw value:', v, 'isMultiCustomer:', isMultiCustomerModule());

            if (isMultiCustomerModule()){
              currentPortfolioId = null;
              currentStrategyCode = v ? v.toUpperCase() : null;
              window.currentStrategyCode = currentStrategyCode;
              console.log('🔧 Set currentStrategyCode to:', currentStrategyCode);
              updateStrategyVisibility();
              return;
            }

            const found = (allPortfoliosCache || []).find(p=>{
              const strategyId = p.customer_strategy_id || p.portfolio_id;
              return String(strategyId)===String(v);
            });
            if(found){
              currentPortfolioId  = found.customer_strategy_id || found.portfolio_id;
              currentStrategyCode = found.strategy_code ? String(found.strategy_code).toUpperCase() : null;
              window.currentStrategyCode = currentStrategyCode;

              if (custSel && String(custSel.value) !== String(found.customer_id)) {
                custSel.value = String(found.customer_id);
              }
              updateStrategyVisibility();
            } else {
              currentPortfolioId = null;
              currentStrategyCode = null;
              window.currentStrategyCode = null;
              updateStrategyVisibility();
            }
          });
          portSel._bound=true;
        }

        // customer change only matters outside multi-customer modules
        if(custSel && !custSel._ctxBound){
          custSel.addEventListener('change', (e)=>{
            if (isMultiCustomerModule()) return;
            buildPortfolioOptionsForCustomer(e.target.value || '');
          });
          custSel._ctxBound = true;
        }

        // update context behaviour when switching tabs
        if(!window._ctxHashBound){
          window.addEventListener('hashchange', applyContextMode);
          window._ctxHashBound = true;
        }

        applyContextMode();

      }catch(err){
        console.error('OrgContext load failed:',err);
        orgSel.innerHTML='<option value="">Error loading</option>';
        portSel.innerHTML='<option value="">Error loading</option>';
        orgSel.disabled=true; portSel.disabled=true;
        if (custSel){ custSel.disabled = false; custSel.removeAttribute('disabled'); }
      } finally {
        // Reset flag after a delay to ensure all change event handlers complete
        // Strategy maintenance listener has a 50ms setTimeout, so wait 150ms to be safe
        setTimeout(() => {
          window.programmaticallyUpdatingContext = false;
          console.log('🔓 Context update complete, flag reset');
        }, 150);
      }
    }

    // Expose globally for auth handler
    window.loadOrgContext = loadOrgContext;
    window.loadCustomers = loadCustomers;

    function setReportTitle(first,last){const el=document.getElementById('reportTitle');el.textContent=(first&&last)?('Advanced DCA Portfolio Performance of '+first+' '+last):'';}
    function setResetZoomEnabled(en){const b=document.getElementById('resetZoomBtn');if(b)b.disabled=!en;}
    function setCanvasVisible(show){const c=document.getElementById('perfChart');if(c)c.style.display=show?'block':'none';}
    function showChartNotice(msg){const n=document.getElementById('chartNotice');n.textContent=msg;n.style.display='block';}
    function hideChartNotice(){const n=document.getElementById('chartNotice');n.textContent='';n.style.display='none';}

    function destroyChoicesInst(inst){ if(inst && typeof inst.destroy==='function'){ inst.destroy(); } }
    function setNativeOptions(sel, html){ destroyChoicesInst(sel._choices); sel.innerHTML = html; }

    async function loadCustomers(){
      const sel=document.getElementById('customerSelect');
      const btSel = document.getElementById('btCustomerSelect');
      const txSel=document.getElementById('txCustomerSelect');
      const editSel=document.getElementById('cmEditSelect');
      if(!supabaseClient){
        const msg='<option value="">Unable to load customers (no Supabase)</option>';
        if(sel) setNativeOptions(sel,msg);
        if(btSel) setNativeOptions(btSel,msg);
        if(txSel) setNativeOptions(txSel,msg);
        if(editSel) setNativeOptions(editSel,msg);
        showInlineError('reportsError','Supabase not available.');
        return;
      }
      // Check if authenticated
      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        const msg='<option value="">Sign in to load customers</option>';
        if(sel) setNativeOptions(sel,msg);
        if(btSel) setNativeOptions(btSel,msg);
        if(txSel) setNativeOptions(txSel,msg);
        if(editSel) setNativeOptions(editSel,msg);
        console.warn('[Reports] Not authenticated, skipping customer load');
        return;
      }
      const timeout=new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')),8000));
      try{
        const fetchPromise = window.supabaseClient.rpc('list_customers');
        const raced=await Promise.race([fetchPromise,timeout]);
        if(raced.error) throw raced.error;
        const list=raced.data||[];
        const active = list.filter(r =>
          String(r.customer_status || 'Active').toLowerCase() === 'active'
         );
        customersCache=list;

        const opts=['<option value="">Select customer…</option>'].concat(
          active.map(r=>'<option value="'+String(r.customer_id)+'">'+r.last_name+', '+r.first_names+'</option>')
        ).join('');

        if(sel){
          sel.disabled = false;
          sel.removeAttribute('disabled');
          setNativeOptions(sel, opts);
        }
        if(txSel) setNativeOptions(txSel, opts);
        if(editSel) {
          setNativeOptions(editSel, opts);
          // Initialize filter functionality after customers loaded
          bindCustomerFilters();
          filterCustomersInEdit(); // Apply default filters (active only)
        }

        if(typeof window.Choices!=="undefined"){
          if(sel){
            customerChoices && customerChoices.destroy();
            customerChoices=new Choices(sel,{searchEnabled:true,searchPlaceholderValue:'Type name…',placeholder:true,placeholderValue:'Select customer…',shouldSort:false,allowHTML:false,itemSelectText:''});
            customerChoices.setChoices(active.map(r=>({value:String(r.customer_id),label:r.last_name+', '+r.first_names})), 'value','label',true);

            // IMPORTANT: keep the global customer selection blank by default
            try {
              if (typeof customerChoices.removeActiveItems === 'function') customerChoices.removeActiveItems();
            } catch (_) {}
            sel.value = '';

            sel._choices = customerChoices;
            if(!sel._bound){sel.addEventListener('change', handleCustomerChange);sel._bound=true;}
          }
          if(btSel){
            btSel._choices && btSel._choices.destroy();
            const ch=new Choices(btSel,{searchEnabled:true,searchPlaceholderValue:'Search customer…',shouldSort:false,allowHTML:false,itemSelectText:''});
            ch.setChoices(active.map(r=>({value:String(r.customer_id),label:r.last_name+', '+r.first_names})), 'value','label',true);
            btSel._choices = ch;
            if(!btSel._bound){ btSel.addEventListener('change', handleBtCustomerChange); btSel._bound=true; }  // bind change handler
          }
          if(txSel){
            txCustomerChoices && txCustomerChoices.destroy();
            txCustomerChoices=new Choices(txSel,{searchEnabled:true,searchPlaceholderValue:'Type name…',placeholder:true,placeholderValue:'Select customer…',shouldSort:false,allowHTML:false,itemSelectText:''});
            txCustomerChoices.setChoices(active.map(r=>({value:String(r.customer_id),label:r.last_name+', '+r.first_names})), 'value','label',true);
            txSel._choices = txCustomerChoices;
          }
          if(editSel){
            editSel._choices && editSel._choices.destroy();
            const ch=new Choices(editSel,{searchEnabled:true,shouldSort:false,allowHTML:false,itemSelectText:''});
            ch.setChoices(list.map(r=>({value:String(r.customer_id),label:r.last_name+', '+r.first_names})), 'value','label',true);
            editSel._choices = ch;
          }
        }else{
          if(sel && !sel._bound){sel.addEventListener('change', handleCustomerChange);sel._bound=true;}
        }

      }catch(err){
        console.error('Customer load failed:',err);
        const msg='<option value="">Unable to load customers</option>';
        if(sel) setNativeOptions(sel,msg);
        if(txSel) setNativeOptions(txSel,msg);
        if(editSel) setNativeOptions(editSel,msg);
        showInlineError('reportsError','Could not load customers (network/CORS/timeout).');
      }
    }

    // Customer Search & Filter functionality
    function filterCustomersInEdit() {
      const searchInput = document.getElementById('cmSearchInput');
      const statusFilter = document.getElementById('cmStatusFilter');
      const editSel = document.getElementById('cmEditSelect');
      const matchCount = document.getElementById('cmMatchCount');
      
      if (!editSel || !customersCache) return;
      
      const searchTerm = searchInput?.value.toLowerCase() || '';
      const statusValue = statusFilter?.value || '';
      
      // Filter customers based on search and status
      let filtered = customersCache.filter(r => {
        // Status filter
        if (statusValue && String(r.registration_status || '').toLowerCase() !== statusValue) {
          return false;
        }
        
        // Search filter (name, email, or customer_id)
        if (searchTerm) {
          const fullName = `${r.first_names || ''} ${r.last_name || ''}`.toLowerCase();
          const email = String(r.email_address || '').toLowerCase();
          const id = String(r.customer_id || '');
          
          if (!fullName.includes(searchTerm) && 
              !email.includes(searchTerm) && 
              !id.includes(searchTerm)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Update match count display
      if (matchCount) {
        matchCount.textContent = `${filtered.length} customer${filtered.length !== 1 ? 's' : ''} found`;
      }
      
      // Update select options
      const opts = ['<option value="">Select customer…</option>'].concat(
        filtered.map(r => `<option value="${r.customer_id}">${r.last_name}, ${r.first_names}</option>`)
      ).join('');
      
      setNativeOptions(editSel, opts);
      
      return filtered;
    }

    // Bind filter event listeners
    function bindCustomerFilters() {
      const searchInput = document.getElementById('cmSearchInput');
      const statusFilter = document.getElementById('cmStatusFilter');
      const clearBtn = document.getElementById('cmClearFilters');
      
      if (searchInput && !searchInput._bound) {
        searchInput.addEventListener('input', filterCustomersInEdit);
        searchInput._bound = true;
      }
      
      if (statusFilter && !statusFilter._bound) {
        statusFilter.addEventListener('change', filterCustomersInEdit);
        statusFilter._bound = true;
      }
      
      if (clearBtn && !clearBtn._bound) {
        clearBtn.addEventListener('click', () => {
          if (searchInput) searchInput.value = '';
          if (statusFilter) statusFilter.value = '';
          filterCustomersInEdit();
        });
        clearBtn._bound = true;
      }
    }

    async function handleCustomerChange(e){
      destroyChart(); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
      currentCustomerId = e.target.value;
      if(!currentCustomerId){
        currentFirst=''; currentLast=''; advData=null; stdData=null; renderReportForCurrentState(); return;
      }
      const found = customersCache.find(c=>String(c.customer_id)===String(currentCustomerId));
      currentFirst = found && found.first_names ? found.first_names : '';
      currentLast  = found && found.last_name ? found.last_name : '';

      const advRes = await loadAdvTransactions(currentCustomerId);
      const stdRes = await loadStdPortfolio(currentCustomerId);
      if(advRes.error){ showInlineError('reportsError', advRes.error.message); }
      if(stdRes.error){ showInlineError('reportsError', stdRes.error.message); }
      advData = advRes.data || [];
      stdData = stdRes.data || [];
      renderReportForCurrentState();
      
      // make selection + data available to the PDF exporter
      window.currentCustomerId = currentCustomerId;
      window.advData = advData;
      window.stdData = stdData;
      await renderPerformanceTable(currentCustomerId, currentReportType);
    }

    // hook the report-type dropdown to refresh everything
    (function bindReportTypeChange(){
      const sel = document.getElementById('reportTypeSelect');
      if (!sel || sel._bound) return;
      sel.addEventListener('change', async (e) => {
        // update state
        currentReportType = e.target.value || 'holdings';

        // redraw the chart for the newly selected type
        renderReportForCurrentState();

        // and refresh the yearly table + narrative underneath
        await renderPerformanceTable(currentCustomerId, currentReportType);
      });
      sel._bound = true;
    })();

    async function loadAdvTransactions(customerId){
      if(!supabaseClient) return {data:[],error:{message:'Supabase not available'}};
      const pageSize=1000; let lastDate=null; let all=[];
      while(true){
        let q=supabaseClient.from('real_customer_performance_daily')
          .select('transaction_date:tx_date, btc_closing_price_usd, total_dca_invested_usd:total_invested_usdt, portfolio_value_usd, closing_balance_usd:closing_balance_usdt, closing_balance_btc, total_roi_percent, cagr_percent')
          .eq('customer_id',customerId).order('tx_date',{ascending:true}).limit(pageSize);
        if(lastDate) q=q.gt('tx_date', lastDate);
        const res=await q;
        if(res.error) return {data:all,error:res.error};
        if(!res.data||res.data.length===0) break;
        all=all.concat(res.data);
        lastDate=res.data[res.data.length-1].transaction_date;
        if(res.data.length<pageSize)break;
      }
      return {data:all,error:null};
    }
    async function loadStdPortfolio(customerId){
      if(!supabaseClient) return {data:[],error:{message:'Supabase not available'}};
      const pageSize=1000; let lastDate=null; let all=[];
      while(true){
        let q=supabaseClient.from('real_std_compare_customer_performance_daily')
          .select('transaction_date:tx_date, portfolio_value_usd, total_roi_percent, cagr_percent')
          .eq('customer_id',customerId).order('tx_date',{ascending:true}).limit(pageSize);
        if(lastDate) q=q.gt('tx_date', lastDate);
        const res=await q;
        if(res.error) return {data:all,error:res.error};
        if(!res.data||res.data.length===0) break;
        all=all.concat(res.data);
        lastDate=res.data[res.data.length-1].transaction_date;
        if(res.data.length<pageSize)break;
      }
      return {data:all,error:null};
    }

    const hexToRGBA=(hex,a)=>{const c=hex.replace('#','');const r=parseInt(c.slice(0,2),16),g=parseInt(c.slice(2,4),16),b=parseInt(c.slice(4,6),16);return`rgba(${r},${g},${b},${a})`;};
    function legendWithFading(){
      const base=cssVar('--ink')||'#111827';
      return {
        position:'top',
        labels:{color:(ctx)=>{const ch=ctx.chart,i=ctx.datasetIndex;return ch.isDatasetVisible(i)?base:'rgba(17,24,39,0.35)';},
                boxWidth:24,boxHeight:2,useBorderRadius:true,borderRadius:2,padding:14},
        onClick:(e,item,leg)=>{const ch=leg.chart,i=item.datasetIndex;ch.setDatasetVisibility(i,!ch.isDatasetVisible(i));ch.update();rebuildFooterForChart(ch);}
      };
    }
    function destroyChart(){if(chartInstance){chartInstance.destroy();chartInstance=null;}}

    /* Holdings chart */
    function renderHoldingsChart(rows,first,last){
      if(!hasChart){showInlineError('reportsError','Chart.js is not available.');return;}
      destroyChart();
      const canvas=document.getElementById('perfChart');const ctx=canvas.getContext('2d');
      const labels=rows.map(r=>normalizeDate(r.transaction_date));
      const sBTC=rows.map(r=>numOrNull(r.btc_closing_price_usd));
      const sInvest=rows.map(r=>numOrNull(r.total_dca_invested_usd));
      const sPV=rows.map(r=>numOrNull(r.portfolio_value_usd));
      const sUSD=rows.map(r=>numOrNull(r.closing_balance_usd));
      const sBTCBal=rows.map(r=>numOrNull(r.closing_balance_btc));
      document.getElementById('reportTitle').textContent=(first&&last)?(`Advanced DCA Portfolio Performance of ${first} ${last}`):'Advanced DCA Portfolio Performance';

      const usdFmt=new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
      const btcFmt=new Intl.NumberFormat('en-US',{maximumFractionDigits:8});
      const grad=(hex,top=.18,bottom=0)=>{const g=ctx.createLinearGradient(0,0,0,canvas.height);g.addColorStop(0,hexToRGBA(hex,top));g.addColorStop(1,hexToRGBA(hex,bottom));return g;};

      let zoomReg=false;
      try{const Z=window['chartjs-plugin-zoom'];if(Z&&!Chart.registry.plugins.get('zoom'))Chart.register(Z);zoomReg=!!Chart.registry.plugins.get('zoom');}catch(e){zoomReg=false;}

      const gridColor=cssVar('--grid')||'#F2F2F2';
      const tickColor=cssVar('--muted')||'#6b7280';

      chartInstance=new Chart(ctx,{
        type:'line',
        data:{labels,datasets:[
          {label:'BTC Closing Price',data:sBTC,borderColor:cssVar('--series-btc-price'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Total Investment',data:sInvest,borderColor:cssVar('--series-invested'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Advanced DCA Portfolio Value',data:sPV,borderColor:cssVar('--series-adv-value'),backgroundColor:grad(cssVar('--series-adv-value'),.14,0),fill:true,yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'USD Balance',data:sUSD,borderColor:cssVar('--series-usd-balance'),backgroundColor:grad(cssVar('--series-usd-balance'),.12,0),fill:true,yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'BTC Balance',data:sBTCBal,borderColor:cssVar('--series-btc-balance'),backgroundColor:'transparent',yAxisID:'y1',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2}
        ]},
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{title:{display:true,text:'Transaction Date'},ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},grid:{color:gridColor},min:0,max:labels.length-1},
            y:{title:{display:true,text:'USD'},position:'left',ticks:{color:tickColor,callback:(v)=>usdFmt.format(v)},grid:{color:gridColor}},
            y1:{title:{display:true,text:'BTC'},position:'right',ticks:{color:tickColor,callback:(v)=>btcFmt.format(v)+' BTC'},grid:{drawOnChartArea:false,color:gridColor}}
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:false},
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:zoomReg,mode:'x'},zoom:{wheel:{enabled:zoomReg},pinch:{enabled:zoomReg},mode:'x'}}
          }
        }
      });

      initOrUpdateRange(labels);
      rebuildFooterForChart(chartInstance);
      setResetZoomEnabled(zoomReg&&typeof chartInstance.resetZoom==='function');
    }

    /* Comparison – Portfolio Value */
    function renderCompPortfolioValueChart(advRows,stdRows,first,last){
      if(!hasChart){showInlineError('reportsError','Chart.js is not available.');return;}
      destroyChart();
      const canvas=document.getElementById('perfChart');const ctx=canvas.getContext('2d');

      const setDates=new Set();
      advRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      stdRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      const labels=Array.from(setDates).sort();

      const advMap=Object.create(null);advRows.forEach(r=>advMap[normalizeDate(r.transaction_date)]=numOrNull(r.portfolio_value_usd));
      const stdMap=Object.create(null);stdRows.forEach(r=>stdMap[normalizeDate(r.transaction_date)]=numOrNull(r.portfolio_value_usd));
      const advSeries=labels.map(d=>advMap[d]!=null?advMap[d]:null);
      const stdSeries=labels.map(d=>stdMap[d]!=null?stdMap[d]:null);

      const usdFmt=new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
      document.getElementById('reportTitle').textContent=(first&&last)?(`Portfolio Value Comparison (Advanced DCA vs. Standard DCA) of ${first} ${last}`):'Portfolio Value Comparison (Advanced DCA vs. Standard DCA)';

      let zoomReg=false;
      try{const Z=window['chartjs-plugin-zoom'];if(Z&&!Chart.registry.plugins.get('zoom'))Chart.register(Z);zoomReg=!!Chart.registry.plugins.get('zoom');}catch(e){zoomReg=false;}

      const gridColor=cssVar('--grid')||'#F2F2F2';
      const tickColor=cssVar('--muted')||'#6b7280';

      chartInstance=new Chart(ctx,{
        type:'line',
        data:{labels,datasets:[
          {label:'Advanced DCA Portfolio Value',data:advSeries,borderColor:cssVar('--series-comp-adv'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Standard DCA Portfolio Value',data:stdSeries,borderColor:cssVar('--series-comp-std'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2}
        ]},
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{title:{display:true,text:'Transaction Date'},ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},grid:{color:gridColor},min:0,max:labels.length-1},
            y:{title:{display:true,text:'USD'},position:'left',ticks:{color:tickColor,callback:(v)=>usdFmt.format(v)},grid:{color:gridColor}}
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:false},
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:zoomReg,mode:'x'},zoom:{wheel:{enabled:zoomReg},pinch:{enabled:zoomReg},mode:'x'}}
          }
        }
      });

      initOrUpdateRange(labels);
      rebuildFooterForChart(chartInstance);
      setResetZoomEnabled(zoomReg&&typeof chartInstance.resetZoom==='function');
    }

    /* Comparison – ROI */
    function renderCompROIChart(advRows,stdRows,first,last){
      if(!hasChart){showInlineError('reportsError','Chart.js is not available.');return;}
      destroyChart();
      const canvas=document.getElementById('perfChart');const ctx=canvas.getContext('2d');

      const setDates=new Set();
      advRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      stdRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      const labels=Array.from(setDates).sort();

      const advMap=Object.create(null);advRows.forEach(r=>advMap[normalizeDate(r.transaction_date)]=numOrNull(r.total_roi_percent));
      const stdMap=Object.create(null);stdRows.forEach(r=>stdMap[normalizeDate(r.transaction_date)]=numOrNull(r.total_roi_percent));
      const advSeries=labels.map(d=>advMap[d]!=null?advMap[d]:null);
      const stdSeries=labels.map(d=>stdMap[d]!=null?stdMap[d]:null);

      document.getElementById('reportTitle').textContent=(first&&last)?(`ROI Comparison (Advanced DCA vs. Standard DCA) of ${first} ${last}`):'ROI Comparison (Advanced DCA vs. Standard DCA)';

      let zoomReg=false;
      try{const Z=window['chartjs-plugin-zoom'];if(Z&&!Chart.registry.plugins.get('zoom'))Chart.register(Z);zoomReg=!!Chart.registry.plugins.get('zoom');}catch(e){zoomReg=false;}

      const gridColor=cssVar('--grid')||'#F2F2F2';
      const tickColor=cssVar('--muted')||'#6b7280';

      chartInstance=new Chart(ctx,{
        type:'line',
        data:{labels,datasets:[
          {label:'Advanced DCA ROI %',data:advSeries,borderColor:cssVar('--series-comp-adv'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Standard DCA ROI %',data:stdSeries,borderColor:cssVar('--series-comp-std'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2}
        ]},
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{title:{display:true,text:'Transaction Date'},ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},grid:{color:gridColor},min:0,max:labels.length-1},
            y:{title:{display:true,text:'ROI %'},position:'left',ticks:{color:tickColor,callback:(v)=>pctText(v==null?0:v)},grid:{color:gridColor}}
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:false},
            tooltip:{ callbacks:{ label:(ctx)=>`${ctx.dataset.label}: ${(Number(ctx.parsed.y)*100).toFixed(2)}%` } },
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:zoomReg,mode:'x'},zoom:{wheel:{enabled:zoomReg},pinch:{enabled:zoomReg},mode:'x'}}
          }
        }
      });

      initOrUpdateRange(labels);
      rebuildFooterForChart(chartInstance);
      setResetZoomEnabled(zoomReg&&typeof chartInstance.resetZoom==='function');
    }

    /* Comparison – Annualised Growth */
    function renderCompAGRChart(advRows,stdRows,first,last){
      if(!hasChart){showInlineError('reportsError','Chart.js is not available.');return;}
      destroyChart();
      const canvas=document.getElementById('perfChart');const ctx=canvas.getContext('2d');

      const setDates=new Set();
      advRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      stdRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      const labels=Array.from(setDates).sort();

      const advMap=Object.create(null);advRows.forEach(r=>advMap[normalizeDate(r.transaction_date)]=numOrNull(r.cagr_percent));
      const stdMap=Object.create(null);stdRows.forEach(r=>stdMap[normalizeDate(r.transaction_date)]=numOrNull(r.cagr_percent));
      const advSeries=labels.map(d=>advMap[d]!=null?advMap[d]:null);
      const stdSeries=labels.map(d=>stdMap[d]!=null?stdMap[d]:null);

      document.getElementById('reportTitle').textContent=(first&&last)?(`Annualised Growth Comparison (Advanced DCA vs. Standard DCA) of ${first} ${last}`):'Annualised Growth Comparison (Advanced DCA vs. Standard DCA)';

      let zoomReg=false;
      try{const Z=window['chartjs-plugin-zoom'];if(Z&&!Chart.registry.plugins.get('zoom'))Chart.register(Z);zoomReg=!!Chart.registry.plugins.get('zoom');}catch(e){zoomReg=false;}

      const gridColor=cssVar('--grid')||'#F2F2F2';
      const tickColor=cssVar('--muted')||'#6b7280';

      chartInstance=new Chart(ctx,{
        type:'line',
        data:{labels,datasets:[
          {label:'Advanced DCA Ann. Growth %',data:advSeries,borderColor:cssVar('--series-comp-adv'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Standard DCA Ann. Growth %',data:stdSeries,borderColor:cssVar('--series-comp-std'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2}
        ]},
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{title:{display:true,text:'Transaction Date'},ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},grid:{color:gridColor},min:0,max:labels.length-1},
            y:{title:{display:true,text:'Annualised Growth %'},position:'left',ticks:{color:tickColor,callback:(v)=>pctText(v==null?0:v)},grid:{color:gridColor}}
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:false},
            tooltip:{ callbacks:{ label:(ctx)=>`${ctx.dataset.label}: ${(Number(ctx.parsed.y)*100).toFixed(2)}%` } },
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:zoomReg,mode:'x'},zoom:{wheel:{enabled:zoomReg},pinch:{enabled:zoomReg},mode:'x'}}
          }
        }
      });

      initOrUpdateRange(labels);
      rebuildFooterForChart(chartInstance);
      setResetZoomEnabled(zoomReg&&typeof chartInstance.resetZoom==='function');
    }

    function rebuildFooterForChart(chart){
      const labels=chart.data.labels||[]; if(!labels.length){clearChartFooter();return;}
      const sEl=document.getElementById('rangeStart'),eEl=document.getElementById('rangeEnd'); let start=0,end=labels.length-1;
      if(sEl&&eEl&&Number(eEl.max)===labels.length-1){ start=Math.min(Number(sEl.value),Number(eEl.value)); end=Math.max(Number(sEl.value),Number(eEl.value)); }
      const entries=[];
      chart.data.datasets.forEach((d,i)=>{
        if(!chart.isDatasetVisible(i))return;
        const arr=d.data||[];
        const ii=lastIndexNonNullInRange(arr,start,end);
        if(ii<0)return;
        const val=arr[ii];
        let text;
        if(d.yAxisID==='y1'){text=btcText(val);} 
        else if(/%|ROI|Growth/i.test(d.label||'')){text=pctText(val==null?0:val);} 
        else{ text=FMT_USD.format(val==null?0:val); }
        entries.push({label:d.label,value:text,date:labels[ii]||'',color:d.borderColor});
      });
      setChartFooter(entries);
    }

    /* ---------- Balances (VALR via Edge Function) ---------- */
    async function fetchBalances(customerId){
      if(!supabaseClient) throw new Error('Supabase not initialized');
      const { data, error } = await supabaseClient.functions.invoke('valr-balances', {
        body: { customer_id: customerId }
      });
      if(error){ throw new Error(error.message || 'Function error'); }
      return data;
    }

    function renderBalances(data){
      // HTML uses <tbody id="balancesTbody"> (not #balancesTable)
      const tb = document.getElementById('balancesTbody');
      if(!tb) throw new Error('balancesTbody not found (expected <tbody id="balancesTbody"> inside #balancesCard)');

      const toVal = (v)=> (v==null || v==='') ? '—' : String(v);

      // Table columns are: Asset | Available | Reserved
      const rows = [
        ['ZAR',  toVal(data?.zar?.available),  toVal(data?.zar?.reserved)],
        ['USDT', toVal(data?.usdt?.available), toVal(data?.usdt?.reserved)],
        ['BTC',  toVal(data?.btc?.available),  toVal(data?.btc?.reserved)],
        ['Staked USDT',      toVal(data?.usdtStakedQty ?? 'N/A'), '—'],
        ['USDT Staking APR', toVal(data?.usdtApr ?? 'N/A'), '—']
      ];

      tb.innerHTML = rows
        .map(([asset, avail, reserved]) => `<tr><td>${asset}</td><td>${avail}</td><td>${reserved}</td></tr>`)
        .join('');

      // Expose for other actions
      window._lastBalances = data;

      // Enable Convert button only if ZAR ≥ 15 and balances are visible
      const cz = document.getElementById('convertZarBtn');
      if (cz) {
        const zarAvail = Number(data?.zar?.available ?? 0);
        cz.disabled = !(zarAvail >= 15);
      }

      const card = document.getElementById('balancesCard');
      if (card) card.style.display='block';
    }

    function bindBalancesUI(){
      const btn     = document.getElementById('fetchBalancesBtn');
      const refresh = document.getElementById('refreshBalancesBtn');
      const hide    = document.getElementById('hideBalancesBtn');
      const convert = document.getElementById('convertZarBtn');   // NEW
      const ctxSel  = document.getElementById('customerSelect');

      async function doFetch(){
        clearInlineError('balancesError');
        const id = ctxSel?.value || '';
        if(!id){ alert('Select a customer in the top context bar first.'); return; }
        btn.disabled=true; if (refresh) refresh.disabled=true;
        btn.textContent='Fetching…';
        try{
          const data=await fetchBalances(id);
          renderBalances(data);
        }catch(e){
          console.error(e);
          showInlineError('balancesError', e.message || 'Could not fetch balances.');
        }finally{
          btn.disabled=false; if (refresh) refresh.disabled=false;
          btn.textContent='Show exchange balances';
          // Re-evaluate Convert button state after fetch
          if (convert) {
            const zarAvail = Number(window?._lastBalances?.zar?.available ?? 0);
            convert.disabled = !(zarAvail >= 15);
          }
        }
      }

      if(btn && !btn._bound){ btn.addEventListener('click', doFetch); btn._bound=true; }
      if(refresh && !refresh._bound){ refresh.addEventListener('click', doFetch); refresh._bound=true; }
      if(hide && !hide._bound){ hide.addEventListener('click', ()=>{ document.getElementById('balancesCard').style.display='none'; }); hide._bound=true; }

      // NEW: Convert ZAR → USDT via Edge Function
      if(convert && !convert._bound){
        convert.addEventListener('click', async ()=>{
          clearInlineError('balancesError');
          const id = ctxSel?.value || '';
          if(!id){ alert('Select a customer in the top context bar first.'); return; }

          convert.disabled = true;
          const oldText = convert.textContent;
          convert.textContent = 'Placing…';

          try{
            const { data, error } = await supabaseClient.functions.invoke('valr-convert-zar', {
              body: { customer_id: Number(id) }
            });
            if (error) throw error;
            alert(`Submitted convert order\nOrder ID: ${data?.order_id || '(n/a)'}\nQty: ${data?.qty || ''}\nPrice: ${data?.price || ''}`);

            // refresh balances after placement
            const fresh = await fetchBalances(id);
            renderBalances(fresh);
          }catch(e){
            console.error(e);
            showInlineError('balancesError', e.message || 'Convert order failed.');
          }finally{
            convert.textContent = oldText;
            const zarAvail = Number(window?._lastBalances?.zar?.available ?? 0);
            convert.disabled = !(zarAvail >= 15);
          }
        });
        convert._bound = true;
      }
    }

    /* ===== Tables under the chart (by trading_year) ===== */
    // ---- formatters (as requested)
    function buildTradingYearHeaders(years){
      if(!years || !years.length) return ['Metric'];
      const maxTY = Math.max(...years);
      const h = ['Metric'];
      years.forEach((ty, i) => h.push(`${ty===maxTY ? '*' : ''}Year ${i+1}`));
      return h;
    }
    // 0-decimals USD (BTC price)
    const fmtUSD0 = v => v == null ? '-' :
      Number(v).toLocaleString('en-US',{ style:'currency', currency:'USD', minimumFractionDigits:0, maximumFractionDigits:0 });
    // 2-decimals USD (Total Investment, Portfolio Value, USD Holdings)
    const fmtUSD2 = v => v == null ? '-' :
      Number(v).toLocaleString('en-US',{ style:'currency', currency:'USD', minimumFractionDigits:2, maximumFractionDigits:2 });
    // 8-decimals BTC (BTC Holdings)
    const fmtBTC8 = v => v == null ? '-' :
      Number(v).toLocaleString('en-US',{ minimumFractionDigits:8, maximumFractionDigits:8 });
    // 1-decimal % (ROI, CAGR) – DB stores fractions, so ×100
      const fmtPct1 = v => v == null ? '-' :
      `${Number(v*100).toLocaleString('en-US',{ minimumFractionDigits:1, maximumFractionDigits:1 })}%`;

    /* ---- Portfolio module table (uses #report-tables) ---- */
    async function renderPerformanceTable(customerId, reportType){
      const root = document.getElementById('report-tables');
      if (!root) return;
      if (!customerId){ root.innerHTML = ''; return; }
      root.innerHTML = '<div style="padding:.6rem 0;color:#6b7280;">Loading…</div>';

      const [{ data: advRows, error: advErr }, { data: stdRows, error: stdErr }] = await Promise.all([
        window.supabaseClient.from('real_customer_performance_annually')
          .select('trading_year, btc_closing_price_usd:latest_btc_closing_price_usd, total_dca_invested_usd:total_invested_usdt, portfolio_value_usd, closing_balance_btc, closing_balance_usd:closing_balance_usdt, total_roi_percent, cagr_percent')
          .eq('customer_id', customerId).order('trading_year', { ascending: true }),
        window.supabaseClient.from('real_std_compare_customer_performance_annually')
          .select('trading_year, portfolio_value_usd, total_roi_percent, cagr_percent')
          .eq('customer_id', customerId).order('trading_year', { ascending: true })
      ]);

      if (advErr){ root.innerHTML = `<div style="color:#b91c1c;background:#fee2e2;border:1px solid #fecaca;border-radius:10px;padding:.6rem 1rem;">${advErr.message}</div>`; return; }
      if ((reportType !== 'holdings') && stdErr){ root.innerHTML = `<div style="color:#b91c1c;background:#fee2e2;border:1px solid #fecaca;border-radius:10px;padding:.6rem 1rem;">${stdErr.message}</div>`; return; }

      const years   = (advRows || []).map(r => Number(r.trading_year));
      const headers = buildTradingYearHeaders(years);
      const stdByTY = new Map((stdRows||[]).map(r => [Number(r.trading_year), r]));

      let rows = [];
      if (reportType === 'holdings') {
        rows = [
          ['BTC Price',         ...(advRows||[]).map(r => fmtUSD0(r.btc_closing_price_usd))],
          ['Total Investment',  ...(advRows||[]).map(r => fmtUSD2(r.total_dca_invested_usd))],
          ['Portfolio Value',   ...(advRows||[]).map(r => fmtUSD2(r.portfolio_value_usd))],
          ['BTC Holdings',     ...(advRows||[]).map(r => fmtBTC8(r.closing_balance_btc))],
          ['Cumulative ROI',    ...(advRows||[]).map(r => fmtPct1(r.total_roi_percent))],
          ['Annualised Growth', ...(advRows||[]).map(r => fmtPct1(r.cagr_percent))],
          ['USD Holdings',      ...(advRows||[]).map(r => fmtUSD2(r.closing_balance_usd))],
        ];
      } else if (reportType === 'comp_value') {
        rows = [
          ['Advanced DCA<br>Portfolio Value', ...(advRows||[]).map(r => fmtUSD2(r.portfolio_value_usd))],
          ['Standard DCA<br>Comparative<br>Portfolio Value', ...(advRows||[]).map(r => fmtUSD2(stdByTY.get(Number(r.trading_year))?.portfolio_value_usd ?? null))],
        ];
      } else if (reportType === 'comp_roi') {
        rows = [
          ['Advanced DCA<br>Portfolio Total ROI', ...(advRows||[]).map(r => fmtPct1(r.total_roi_percent))],
          ['Standard DCA<br>Portfolio Total ROI', ...(advRows||[]).map(r => fmtPct1(stdByTY.get(Number(r.trading_year))?.total_roi_percent ?? null))],
        ];
      } else if (reportType === 'comp_agr') {
        rows = [
          ['Advanced DCA<br>Portfolio<br>Annualised CAGR', ...(advRows||[]).map(r => fmtPct1(r.cagr_percent))],
          ['Standard DCA<br>Portfolio<br>Annualised CAGR', ...(advRows||[]).map(r => fmtPct1(stdByTY.get(Number(r.trading_year))?.cagr_percent ?? null))],
        ];
      }

      const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
      const tbody = rows.map((row, i) => {
        const isMuted = (reportType.startsWith('comp_') && i === 1);
        const labelTd = `<td class="${isMuted ? 'metric-cell metric-muted' : 'metric-cell'}">${row[0]}</td>`;
        const cells   = row.slice(1).map(v => `<td>${v}</td>`).join('');
        return `<tr>${labelTd}${cells}</tr>`;
      }).join('');
      const colCount = headers.length || 1;
      const colgroup = `<colgroup>${Array.from({ length: colCount }, () => `<col style="width:${(100/colCount)}%;"></col>`).join('')}</colgroup>`;

      root.innerHTML = `<table class="report-table">${colgroup}${thead}<tbody>${tbody}</tbody></table>`;
    }

    async function renderBtPerformanceTable(btRunId, type){
      const table = document.getElementById('btYearlyTable');
      if (!table) return;

      const layoutType = type || btCurrentReportType || 'holdings';

      // No run selected yet
      if (!btRunId){
        table.innerHTML = '<tr><td colspan="8">Run a back-test to see annual results.</td></tr>';
        return;
      }

      try{
        const { data, error } = await supabaseClient
          .schema('lth_pvr_bt')
          .from('v_bt_results_annual')
          .select('*')
          .eq('bt_run_id', btRunId)
          .order('trading_year', { ascending: true });

        if (error){
          console.error('v_bt_results_annual error:', error);
          table.innerHTML = `<tr><td colspan="8">Could not load annual results: ${error.message}</td></tr>`;
          return;
        }

        const rows = data || [];
        if (!rows.length){
          table.innerHTML = '<tr><td colspan="8">No annual results for this back-test run.</td></tr>';
          return;
        }

        const usdFmt = new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
          maximumFractionDigits: 0
        });
        const btcFmt = new Intl.NumberFormat('en-US', {
          minimumFractionDigits: 0,
          maximumFractionDigits: 8
        });
        const pct = (v) => (v == null ? '–' : `${Number(v).toFixed(2)}%`);

        if (layoutType === 'holdings') {
          // 1) Back-test holdings table
          const header = `
            <tr>
              <th>Year</th>
              <th>BTC Price</th>
              <th>Total Investment (USDT)</th>
              <th>BTC Holdings</th>
              <th>USD Holdings</th>
              <th>NAV (USD)</th>
              <th>Cumulative ROI %</th>
              <th>CAGR %</th>
            </tr>
          `;
          const body = rows.map(r => `
            <tr>
              <td>${r.trading_year}</td>
              <td>${r.btc_price == null ? '–' : usdFmt.format(r.btc_price)}</td>
              <td>${r.total_investment == null ? '–' : usdFmt.format(r.total_investment)}</td>
              <td>${r.btc_holdings == null ? '–' : btcFmt.format(r.btc_holdings)}</td>
              <td>${r.usd_holdings == null ? '–' : usdFmt.format(r.usd_holdings)}</td>
              <td>${r.nav_usd == null ? '–' : usdFmt.format(r.nav_usd)}</td>
              <td>${pct(r.roi_percent)}</td>
              <td>${pct(r.cagr_percent)}</td>
            </tr>
          `).join('');
          table.innerHTML = header + body;

        } else if (layoutType === 'comp_value') {
          // 2) Comparison – Portfolio Value
          const header = `
            <tr>
              <th>Year</th>
              <th>LTH PVR DCA Portfolio Value</th>
              <th>Standard DCA Portfolio Value</th>
            </tr>
          `;
          const body = rows.map(r => `
            <tr>
              <td>${r.trading_year}</td>
              <td>${r.nav_usd == null ? '–' : usdFmt.format(r.nav_usd)}</td>
              <td>${r.std_nav_usd == null ? '–' : usdFmt.format(r.std_nav_usd)}</td>
            </tr>
          `).join('');
          table.innerHTML = header + body;

        } else if (layoutType === 'comp_roi') {
          // 3) Comparison – ROI (cumulative)
          const header = `
            <tr>
              <th>Year</th>
              <th>LTH PVR DCA Cumulative ROI %</th>
              <th>Standard DCA Cumulative ROI %</th>
            </tr>
          `;
          const body = rows.map(r => `
            <tr>
              <td>${r.trading_year}</td>
              <td>${pct(r.roi_percent)}</td>
              <td>${pct(r.std_roi_percent)}</td>
            </tr>
          `).join('');
          table.innerHTML = header + body;

        } else if (layoutType === 'comp_agr') {
          // 4) Comparison – Annualised Growth (CAGR)
          const header = `
            <tr>
              <th>Year</th>
              <th>LTH PVR DCA Annualised CAGR %</th>
              <th>Standard DCA Annualised CAGR %</th>
            </tr>
          `;
          const body = rows.map(r => `
            <tr>
              <td>${r.trading_year}</td>
              <td>${pct(r.cagr_percent)}</td>
              <td>${pct(r.std_cagr_percent)}</td>
            </tr>
          `).join('');
          table.innerHTML = header + body;

        } else {
          // Fallback: default to holdings layout
          return renderBtPerformanceTable(btRunId, 'holdings');
        }

      }catch(e){
        console.error('renderBtPerformanceTable error:', e);
        table.innerHTML = `<tr><td colspan="8">Error loading annual results: ${e.message || e}</td></tr>`;
      }
    }

    function renderReportForCurrentState(){
      if(!currentCustomerId){
        destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
        showChartNotice('Select a customer to view this report.'); document.getElementById('reportTitle').textContent='';
        renderPerformanceTable('', currentReportType); // clear table
        return;
      }
      hideChartNotice(); setCanvasVisible(true);

      if(currentReportType==='holdings'){
        if(!advData||!advData.length){
          destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
          showChartNotice('No transactions found for this customer.'); setReportTitle(currentFirst,currentLast);
          renderPerformanceTable(currentCustomerId, currentReportType);
          return;
        }
        renderHoldingsChart(advData,currentFirst,currentLast);
        renderPerformanceTable(currentCustomerId, currentReportType);
      }else if(currentReportType==='comp_value'){
        if((!advData||!advData.length)&&(!stdData||!stdData.length)){
          destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
          showChartNotice('No portfolio values found for this customer.'); document.getElementById('reportTitle').textContent='';
          renderPerformanceTable(currentCustomerId, currentReportType);
          return;
        }
        renderCompPortfolioValueChart(advData||[],stdData||[],currentFirst,currentLast);
        renderPerformanceTable(currentCustomerId, currentReportType);
      }else if(currentReportType==='comp_roi'){
        if((!advData||!advData.length)&&(!stdData||!stdData.length)){
          destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
          showChartNotice('No ROI values found for this customer.'); document.getElementById('reportTitle').textContent='';
          renderPerformanceTable(currentCustomerId, currentReportType);
          return;
        }
        renderCompROIChart(advData||[],stdData||[],currentFirst,currentLast);
        renderPerformanceTable(currentCustomerId, currentReportType);
      }else if(currentReportType==='comp_agr'){
        if((!advData||!advData.length)&&(!stdData||!stdData.length)){
          destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
          showChartNotice('No annualised growth values found for this customer.'); document.getElementById('reportTitle').textContent='';
          renderPerformanceTable(currentCustomerId, currentReportType);
          return;
        }
        renderCompAGRChart(advData||[],stdData||[],currentFirst,currentLast);
        renderPerformanceTable(currentCustomerId, currentReportType);
      }
    }

    /* =================== Customer Management JS =================== */
    function cmShowAlert(type, msg){
      const el = document.getElementById('cmAlert');
      el.style.display = 'block';
      el.textContent = msg;
      el.style.borderColor = type==='error' ? '#fecaca' : '#bbf7d0';
      el.style.background = type==='error' ? '#fee2e2' : '#ecfdf5';
      el.style.color = type==='error' ? '#7f1d1d' : '#065f46';
    }
    function cmHideAlert(){ const el=document.getElementById('cmAlert'); el.style.display='none'; el.textContent=''; }

    function cmNum(v, fallback=0){ const n = Number(String(v ?? '').trim()); return Number.isFinite(n) ? n : fallback; }
    function cmDate(v){ if(!v) return null; const d = new Date(v); return isNaN(d) ? null : d.toISOString(); }

    function cmBindTabs(){
      const bNew = document.getElementById('cmTabNew');
      const bEdit = document.getElementById('cmTabEdit');
      const fNew = document.getElementById('cmFormNew');
      const fEdit = document.getElementById('cmFormEdit');
      function set(active){
        cmHideAlert();
        if(active==='new'){ bNew.classList.add('cm-tab--active'); bEdit.classList.remove('cm-tab--active'); fNew.style.display='block'; fEdit.style.display='none'; }
        else{ bEdit.classList.add('cm-tab--active'); bNew.classList.remove('cm-tab--active'); fEdit.style.display='block'; fNew.style.display='none'; }
      }
      if(bNew && !bNew._bound){ bNew.addEventListener('click',()=>set('new')); bNew._bound=true; }
      if(bEdit && !bEdit._bound){ bEdit.addEventListener('click',()=>set('edit')); bEdit._bound=true; }
      set('new');
    }

    function cmWireFrequency(formEl){
      const freq = formEl.querySelector('select[name="recurring_contribution_frequency"]');
      const amt  = formEl.querySelector('input[name="recurring_contribution_zar"]');
      const star = formEl.querySelector('[data-cm-req="freq"]');
      function sync(){
        const val = freq ? String(freq.value) : '';
        if(!freq || !amt) return;
        if(val === 'None'){
          amt.value = '0';
          amt.disabled = true;
          amt.required = false;
          if(star) star.style.visibility='hidden';
        }else{
          amt.disabled = false;
          amt.required = true;
          if(star) star.style.visibility='visible';
        }
      }
      if(freq && !freq._bound){ freq.addEventListener('change', sync); freq._bound=true; }
      sync();
    }

    function cmValidateId13(val){
      return /^\d{13}$/.test(String(val||'').trim());
    }

    async function cmCreateCustomer(payload){
      const row = {
        first_names: payload.first_names.trim(),
        last_name: payload.last_name.trim(),
        email_address: payload.email_address.trim(),
        cellphone_number: payload.cellphone_number.trim(),
        id_number: payload.id_number.trim(),
        trade_start_date: cmDate(payload.trade_start_date),
        recurring_contribution_frequency: payload.recurring_contribution_frequency,
        recurring_contribution_zar: cmNum(payload.recurring_contribution_zar || 0, 0),
        upfront_contribution_zar: cmNum(payload.upfront_contribution_zar, 0),
        upfront_contribution_btc: cmNum(payload.upfront_contribution_btc, 0),
        exchange_api_name: payload.exchange_api_name || null,
        exchange_username: payload.exchange_username || null,
        exchange_password: payload.exchange_password || null,
        exchange_api_key: payload.exchange_api_key || null,
        exchange_api_secret: payload.exchange_api_secret || null,
        exchange_btc_wallet_address: payload.exchange_btc_wallet_address || null,
        customer_status: payload.customer_status || 'Active'
      };
      const { data, error } = await supabaseClient.from('customer_details').insert(row).select('customer_id').single();
      if(error) throw error;
      return data;
    }

    async function cmUpdateCustomer(id, payload){
      const row = {
        first_names: payload.first_names.trim(),
        last_name: payload.last_name.trim(),
        email_address: payload.email_address.trim(),
        cellphone_number: payload.cellphone_number.trim(),
        id_number: payload.id_number.trim(),
        trade_start_date: cmDate(payload.trade_start_date),
        recurring_contribution_frequency: payload.recurring_contribution_frequency,
        recurring_contribution_zar: cmNum(payload.recurring_contribution_zar || 0, 0),
        upfront_contribution_zar: cmNum(payload.upfront_contribution_zar, 0),
        upfront_contribution_btc: cmNum(payload.upfront_contribution_btc, 0),
        exchange_api_name: payload.exchange_api_name || null,
        exchange_username: payload.exchange_username || null,
        exchange_password: payload.exchange_password || null,
        exchange_api_key: payload.exchange_api_key || null,
        exchange_api_secret: payload.exchange_api_secret || null,
        exchange_btc_wallet_address: payload.exchange_btc_wallet_address || null,
        customer_status: payload.customer_status || 'Active'
      };
      const { error } = await supabaseClient.from('customer_details').update(row).eq('customer_id', id);
      if(error) throw error;
    }

    async function cmLoadCustomer(id){
      const { data, error } = await supabaseClient
        .from('customer_details')
        .select('customer_id, first_names, last_name, email_address, cellphone_number, id_number, trade_start_date, recurring_contribution_frequency, recurring_contribution_zar, upfront_contribution_zar, upfront_contribution_btc, exchange_api_name, exchange_username, exchange_password, exchange_api_key, exchange_api_secret, exchange_btc_wallet_address, customer_status')
        .eq('customer_id', id).single();
      if(error) throw error;
      return data;
    }

    function cmFillForm(formEl, row){
      formEl.reset();
      const set = (name, val) => { const el=formEl.querySelector(`[name="${name}"]`); if(!el) return; if(el.type==='date' && val){ el.value = String(val).slice(0,10); } else { el.value = (val ?? ''); } };
      ['first_names','last_name','email_address','cellphone_number','id_number','recurring_contribution_frequency','recurring_contribution_zar','upfront_contribution_zar','upfront_contribution_btc','exchange_api_name','exchange_username','exchange_password','exchange_api_key','exchange_api_secret','exchange_btc_wallet_address','customer_status'].forEach(k=>set(k,row[k]));
      set('trade_start_date', row.trade_start_date);
      cmWireFrequency(formEl);
    }

    function cmSerialize(formEl){
      const data = Object.fromEntries(new FormData(formEl).entries());

      // Required basics (includes frequency)
      const must = ['first_names','last_name','email_address','cellphone_number','id_number','recurring_contribution_frequency','customer_status'];
      for(const k of must){ if(!String(data[k]||'').trim()) throw new Error(`Please complete the "${k.replaceAll('_',' ')}" field.`); }

      // ID number 13-digit check
      if(!cmValidateId13(data.id_number)){ throw new Error('ID number must be a 13-digit number.'); }

      // Frequency logic
      const freq = String(data.recurring_contribution_frequency).trim();
      if(freq === 'None'){
        data.recurring_contribution_zar = '0';
      }else{
        if(!data.recurring_contribution_zar || Number(data.recurring_contribution_zar)<=0){
          throw new Error('Recurring contribution (ZAR) is required and must be > 0 when Recurrence is not None.');
        }
      }

      // Optional amounts default to 0
      if(!data.upfront_contribution_zar) data.upfront_contribution_zar = '0';
      if(!data.upfront_contribution_btc) data.upfront_contribution_btc = '0';

      return data;
    }

    function cmSetNewDefaults(formEl){
      // Set default selections/values when the form is reset or after create
      const freq = formEl.querySelector('select[name="recurring_contribution_frequency"]');
      const upZ  = formEl.querySelector('input[name="upfront_contribution_zar"]');
      const upB  = formEl.querySelector('input[name="upfront_contribution_btc"]');
      if(freq) freq.value = 'Monthly';
      if(upZ) upZ.value = '0';
      if(upB) upB.value = '0';
      cmWireFrequency(formEl);
    }

    function cmBindForms(){
      // New
      const fNew = document.getElementById('cmFormNew');
      if(fNew && !fNew._bound){
        cmWireFrequency(fNew);
        fNew.addEventListener('submit', async (e)=>{
          e.preventDefault(); cmHideAlert();
          try{
            const payload = cmSerialize(fNew);
            const res = await cmCreateCustomer(payload);
            cmShowAlert('success', `Client created (ID ${res.customer_id}).`);
            fNew.reset();
            cmSetNewDefaults(fNew);
            await loadCustomers();
            const editSel = document.getElementById('cmEditSelect');
            if(editSel){ editSel.value = String(res.customer_id); editSel.dispatchEvent(new Event('change')); }
          }catch(err){ cmShowAlert('error', err.message || 'Could not create client.'); }
        });
        // Ensure defaults after manual reset
        fNew.addEventListener('reset', ()=>setTimeout(()=>cmSetNewDefaults(fNew)));
        fNew._bound = true;
      }

      // Edit
      const fEdit = document.getElementById('cmFormEdit');
      const sel = document.getElementById('cmEditSelect');
      if(sel && !sel._bound){
        sel.addEventListener('change', async (e)=>{
          cmHideAlert();
          const id = e.target.value;
          if(!id){ fEdit.reset(); return; }
          try{
            const row = await cmLoadCustomer(id);
            cmFillForm(fEdit, row);
            fEdit.dataset.customerId = String(id);
          }catch(err){ cmShowAlert('error', err.message || 'Failed to load client.'); }
        });
        sel._bound = true;
      }
      if(fEdit && !fEdit._bound){
        cmWireFrequency(fEdit);
        fEdit.addEventListener('submit', async (e)=>{
          e.preventDefault(); cmHideAlert();
          const id = e.currentTarget.dataset.customerId;
          if(!id) return cmShowAlert('error','Please select a client to edit.');
          try{
            const payload = cmSerialize(fEdit);
            await cmUpdateCustomer(id, payload);
            cmShowAlert('success', 'Changes saved.');
            await loadCustomers();
          }catch(err){ cmShowAlert('error', err.message || 'Could not save changes.'); }
        });
        const delBtn = document.getElementById('cmDeleteBtn');
        if(delBtn && !delBtn._bound){
          delBtn.addEventListener('click', async ()=>{
            cmHideAlert();
            const id = fEdit.dataset.customerId;
            if(!id) return cmShowAlert('error','Select a client first.');
            if(!confirm('Delete this client? This cannot be undone.')) return;
            try{
              const { error } = await supabaseClient.from('customer_details').delete().eq('customer_id', id);
              if(error) throw error;
              cmShowAlert('success','Client deleted.');
              fEdit.reset(); document.getElementById('cmEditSelect').value='';
              await loadCustomers();
            }catch(err){ cmShowAlert('error', err.message || 'Delete failed.'); }
          });
          delBtn._bound=true;
        }
        fEdit._bound = true;
      }
    }

    // Load Dashboard Metrics
    async function loadDashboardMetrics() {
      const loading = document.getElementById('dashboardMetricsLoading');
      const content = document.getElementById('dashboardMetricsContent');
      const error = document.getElementById('dashboardMetricsError');
      
      if (!supabaseClient) {
        if (loading) loading.style.display = 'none';
        if (error) {
          error.textContent = 'Supabase client not available';
          error.style.display = 'block';
        }
        return;
      }
      
      try {
        const { data, error: rpcError } = await supabaseClient.rpc('get_admin_dashboard_metrics');
        
        if (rpcError) throw rpcError;
        
        // Hide loading, show content
        if (loading) loading.style.display = 'none';
        if (content) content.style.display = 'block';
        if (error) error.style.display = 'none';
        
        // Populate metrics
        const metricTotalCustomers = document.getElementById('metricTotalCustomers');
        const metricActiveCustomers = document.getElementById('metricActiveCustomers');
        const metricTotalAUM = document.getElementById('metricTotalAUM');
        const metricAvgNAV = document.getElementById('metricAvgNAV');
        const metricAlerts = document.getElementById('metricAlerts');
        const metricUpdatedAt = document.getElementById('metricUpdatedAt');
        
        if (metricTotalCustomers) metricTotalCustomers.textContent = data.total_customers || 0;
        if (metricActiveCustomers) metricActiveCustomers.textContent = data.active_customers || 0;
        
        if (metricTotalAUM) {
          const aum = parseFloat(data.total_aum_usd) || 0;
          metricTotalAUM.textContent = `$${aum.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
        }
        
        if (metricAvgNAV) {
          const avg = parseFloat(data.avg_nav_usd) || 0;
          metricAvgNAV.textContent = `$${avg.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
        }
        
        if (metricAlerts && data.alerts) {
          const critical = data.alerts.critical || 0;
          const errorCount = data.alerts.error || 0;
          const warn = data.alerts.warn || 0;
          
          let alertHTML = '';
          if (critical > 0) alertHTML += `<span style="color:#dc2626;font-weight:600;">${critical} Critical</span>`;
          if (errorCount > 0) alertHTML += (alertHTML ? ' · ' : '') + `<span style="color:#ef4444;">${errorCount} Error</span>`;
          if (warn > 0) alertHTML += (alertHTML ? ' · ' : '') + `<span style="color:#f59e0b;">${warn} Warning</span>`;
          if (!alertHTML) alertHTML = '<span style="color:#10b981;">No Active Alerts</span>';
          
          metricAlerts.innerHTML = alertHTML;
        }
        
        if (metricUpdatedAt && data.updated_at) {
          const updated = new Date(data.updated_at);
          metricUpdatedAt.textContent = `Updated: ${updated.toLocaleTimeString()}`;
        }
        
      } catch (err) {
        console.error('Failed to load dashboard metrics:', err);
        if (loading) loading.style.display = 'none';
        if (error) {
          error.textContent = `Failed to load metrics: ${err.message || 'Unknown error'}`;
          error.style.display = 'block';
        }
      }
    }

    // Hook into init when customers are loaded
    (function cmInitAfterLoad(){
      const ready = () => typeof supabaseClient!=='undefined' && supabaseClient && Array.isArray(customersCache);
      const interval = setInterval(()=>{
        if(!ready()) return;
        clearInterval(interval);
        cmBindTabs();
        cmBindForms();
        loadDashboardMetrics(); // Load dashboard metrics after customers loaded
      }, 200);
    })();

    /* ------------------ INIT ------------------ */
    (async function init(){
      if(!location.hash) location.hash = '#import-module';

      await loadExistingDates();

      const previewBtn=document.getElementById('previewBtn');
      if(previewBtn){
        previewBtn.addEventListener('click',function(){
          if(!hasPapa){showInlineError('inlineError','CSV parser is unavailable.');return;}
          clearInlineError('inlineError');
          const file=document.getElementById('csvFileInput').files[0]; if(!file) return alert('Please select a CSV file.');
          Papa.parse(file,{header:true,skipEmptyLines:true,complete:function(results){
            const seen=new Set();
            previewRows=results.data.map((row,i)=>{
              const d=normalizeDate(row.date_closing);
              const dupDb=existingDates.has(d);
              const dupFile=seen.has(d);
              if(!dupFile)seen.add(d);
              return{
                index:i+1,
                date_closing:d,
                btc_closing_price_usd:row.btc_closing_price_usd,
                smoothed_risk_score:row.smoothed_risk_score,
                omega_score:row.omega_score,
                omega_on_off:row.omega_on_off,
                sab_below_neg_1sd:row.sab_below_neg_1sd,
                sab_below_neg_2sd:row.sab_below_neg_2sd,
                isDuplicate:dupDb||dupFile
              };
            });
            renderPreview();
          },error:function(err){showInlineError('inlineError','Error parsing CSV: '+err.message);console.error(err);}});
        });
        document.getElementById('importBtn').addEventListener('click',importRows);
      }

      await loadCustomers();
      await loadOrgContext();

      // Initialise the LTH PVR Back-Testing form (strategy selector + inputs + Run button)
      initBtRunForm();

      /* Initialize Choices for Report Type too (search disabled) so both boxes match exactly */
      const rtSel=document.getElementById('reportTypeSelect');

      if(window.Choices){
        reportTypeChoices=new Choices(rtSel,{searchEnabled:false,shouldSort:false,allowHTML:false,itemSelectText:''});
      }

      const resetBtn=document.getElementById('resetZoomBtn');
      if(resetBtn){resetBtn.addEventListener('click',function(){if(chartInstance&&typeof chartInstance.resetZoom==='function'){chartInstance.resetZoom();resetRangeToFull();}});}

      const showAllBtn=document.getElementById('showAllBtn');
      const hideAllBtn=document.getElementById('hideAllBtn');
      if(showAllBtn){showAllBtn.addEventListener('click',function(){if(!chartInstance)return;let changed=false;chartInstance.data.datasets.forEach((ds,i)=>{if(!chartInstance.isDatasetVisible(i)){chartInstance.setDatasetVisibility(i,true);changed=true;}});if(changed)chartInstance.update();rebuildFooterForChart(chartInstance);});}
      if(hideAllBtn){hideAllBtn.addEventListener('click',function(){if(!chartInstance)return;let changed=false;chartInstance.data.datasets.forEach((ds,i)=>{if(chartInstance.isDatasetVisible(i)){chartInstance.setDatasetVisibility(i,false);changed=true;}});if(changed)chartInstance.update();rebuildFooterForChart(chartInstance);});}

//      const repSel=document.getElementById('reportTypeSelect');
//      if(repSel){repSel.addEventListener('change',function(e){clearChartFooter();currentReportType=e.target.value;renderReportForCurrentState();});}
//      renderReportForCurrentState();

      // Ensure default values for New form on first load
      const fNew = document.getElementById('cmFormNew');
      if(fNew){ cmSetNewDefaults(fNew); }

      // Bind balances UI handlers
      bindBalancesUI();
    })();
  </script>

  <script>
  /* ===== ADMIN MODULE (drop-in, robust) ===== */
  (function(){
    const ADMIN_EMAIL = 'davin.gaier@gmail.com';

    function isAdmin(email){ return !!email && email.toLowerCase() === ADMIN_EMAIL.toLowerCase(); }

    // ---- UI flip helpers ----
    function flipUI(email){
      const authCard = document.getElementById('adminAuthCard');
      const appCard  = document.getElementById('adminApp');
      const signed   = document.getElementById('adminSignedInAs');
      const allowed  = isAdmin(email);

      if (authCard) authCard.style.display = allowed ? 'none'  : 'block';
      if (appCard)  appCard.style.display  = allowed ? 'block' : 'none';
      if (signed)   signed.textContent     = allowed ? `Signed in as ${email}` : '';

      if (allowed) {
        const init = (window.adminInitApp || adminInitApp);
        if (typeof init === 'function') init();
      }
    }

    async function waitForSb(timeoutMs = 8000){
      const start = Date.now();
      while(!window.supabaseClient){
        await new Promise(r => setTimeout(r, 50));
        if(Date.now() - start > timeoutMs) return null;
      }
      return window.supabaseClient;
    }

    async function paintFromSession(){
      try{
        const sb = await waitForSb();
        if(!sb?.auth) return;
        const { data: { session } } = await sb.auth.getSession();
        flipUI(session?.user?.email || null);
      }catch(e){ console.warn('[ADMIN] getSession failed', e); }
    }

    // ---- Data loaders ----
    async function adminLoadOrgs(){
      const sel = document.getElementById('adminOrgSelect');
      if(!sel) return;
      // Check if authenticated
      const { data: { session } } = await window.supabaseClient.auth.getSession();
      if (!session?.user) {
        console.warn('[ADMIN] Not authenticated, skipping org load');
        sel.innerHTML = '<option value="">Sign in to view orgs</option>';
        return;
      }
      const { data, error } = await window.supabaseClient.rpc('my_orgs');
      if(error){ console.error('[ADMIN] my_orgs error:', error); sel.innerHTML = '<option value="">No orgs</option>'; return; }

      const list = data || [];
      sel.innerHTML = list.length
        ? list.map(o=>`<option value="${o.id}">${o.name} (${o.role})</option>`).join('')
        : '<option value="">No orgs</option>';

      if (!sel._bound){
        sel.addEventListener('change', adminLoadMembers);
        sel._bound = true;
      }
    }

    async function adminLoadMembers(){
      const orgSel = document.getElementById('adminOrgSelect');
      const tb = document.querySelector('#adminMembersTable tbody');
      if(!orgSel || !tb) return;
      // Check if authenticated
      const { data: { session } } = await window.supabaseClient.auth.getSession();
      if (!session?.user) {
        console.warn('[ADMIN] Not authenticated, skipping members load');
        tb.innerHTML = '<tr><td colspan="3">Please sign in to view members</td></tr>';
        return;
      }

      const orgId = orgSel.value;
      if(!orgId){ tb.innerHTML = '<tr><td colspan="4">Select an organisation.</td></tr>'; return; }

      const { data, error } = await window.supabaseClient.rpc('org_member_list', { p_org_id: orgId });
      if(error){ console.error('[ADMIN] org_member_list error:', error); tb.innerHTML = `<tr><td colspan="4">${error.message}</td></tr>`; return; }

      const rows = (data || []).map(r=>{
        const dt = new Date(r.created_at).toISOString().slice(0,19).replace('T',' ');
        return `<tr>
          <td>${r.email}</td>
          <td>${r.role}</td>
          <td>${dt}</td>
          <td><button data-email="${r.email}" class="btn-remove">Remove</button></td>
        </tr>`;
      });
      tb.innerHTML = rows.join('') || '<tr><td colspan="4">No members.</td></tr>';

      tb.querySelectorAll('.btn-remove').forEach(b=>{
        if(!b._bound){
          b.addEventListener('click', async ()=>{
            const email = b.getAttribute('data-email');
            if(!confirm(`Remove ${email}?`)) return;
            const { error } = await window.supabaseClient.rpc('org_member_remove', { p_org_id: orgSel.value, p_email: email });
            if(error){ alert(error.message || 'Remove failed'); return; }
            await adminLoadMembers();
          });
          b._bound = true;
        }
      });
    }

    // ---- Handlers ----
    function bindAdminHandlers(){
      const loginForm = document.getElementById('adminLoginForm');
      const signInBtn = document.getElementById('adminSignInBtn');
      const signOutBtn = document.getElementById('adminSignOut');
      const refreshBtn = document.getElementById('adminRefresh');
      const addForm = document.getElementById('adminAddForm');

      if (loginForm && !loginForm._cancel){
        loginForm.addEventListener('submit', (e)=>{ e.preventDefault(); e.stopPropagation(); return false; });
        loginForm._cancel = true;
      }

      const doLogin = async (e)=>{
        if (e){ e.preventDefault(); e.stopPropagation(); }
        console.log('[ADMIN] Sign-in clicked');
        if (!window.supabaseClient?.auth){ alert('Supabase not ready'); return; }

        const email = document.getElementById('adminEmail').value.trim();
        const password = document.getElementById('adminPassword').value;

        const { data, error } = await window.supabaseClient.auth.signInWithPassword({ email, password });
        console.log('[ADMIN] signInWithPassword result:', { hasUser: !!data?.user, error });
        if (error){ alert(error.message || 'Sign-in failed'); return; }

        if (data?.user?.email) flipUI(data.user.email);
        await paintFromSession();
        setTimeout(paintFromSession, 300);
      };

      if (signInBtn && !signInBtn._bound){ signInBtn.addEventListener('click', doLogin); signInBtn._bound = true; }
      if (signOutBtn && !signOutBtn._bound){
        signOutBtn.addEventListener('click', async ()=>{
          await window.supabaseClient.auth.signOut();
          flipUI(null);
        });
        signOutBtn._bound = true;
      }

      if (refreshBtn && !refreshBtn._bound){
        refreshBtn.addEventListener('click', adminLoadMembers);
        refreshBtn._bound = true;
      }

      if (addForm && !addForm._bound) {
        addForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          e.stopPropagation();

          // ✅ Read values from the DOM
          const orgId = (document.getElementById('adminOrgSelect') || {}).value || '';
          const email = (document.getElementById('adminAddEmail') || {}).value.trim();
          const role  = (document.getElementById('adminAddRole') || {}).value || 'viewer';
          const pw    = (document.getElementById('adminAddPassword') || {}).value.trim();

          if (!orgId) return alert('Select an organisation first.');
          if (!email) return alert('Enter an email address.');

          // Optional: simple busy state
          const btn = addForm.querySelector('button[type="submit"]');
          if (btn) { btn.disabled = true; btn.textContent = 'Working…'; }

          try {
            // Call your Edge Function (it creates the user and adds org membership)
            const { data, error } = await window.supabaseClient.functions.invoke('admin-create-user', {
              body: { org_id: orgId, email, role, ...(pw ? { password: pw } : {}) }
            });

            if (error || data?.error) {
              const msg = data?.error || error?.message || 'Edge Function error';
              throw new Error(msg);
            }

            if (!pw) alert('User created. A secure temporary password was generated and emailed to them.');
            // Refresh the table
            await adminLoadMembers();

            // Clear inputs
            (document.getElementById('adminAddEmail') || {}).value = '';
            (document.getElementById('adminAddPassword') || {}).value = '';
          } catch (err) {
            console.error('[ADMIN] create-user failed:', err);
            alert(err.message || 'Create user failed');
          } finally {
            if (btn) { btn.disabled = false; btn.textContent = 'Add / Update'; }
          }
        });
        addForm._bound = true;
      }
    }

    async function adminInitApp(){
      try { await adminLoadOrgs(); }    catch(e){ console.warn('[ADMIN] load orgs:', e); }
      try { await adminLoadMembers(); } catch(e){ console.warn('[ADMIN] load members:', e); }
      try { bindAdminHandlers(); }      catch(_){ /* already bound */ }
    }

    // Expose to avoid scope issues from other scripts
    window.adminLoadOrgs     = adminLoadOrgs;
    window.adminLoadMembers  = adminLoadMembers;
    window.adminInitApp      = adminInitApp;
    window.bindAdminHandlers = bindAdminHandlers;

    // ---- BOOT ----
    bindAdminHandlers();

    // paint on auth changes
    if (window.supabaseClient?.auth?.onAuthStateChange){
      window.supabaseClient.auth.onAuthStateChange((_evt, session)=>{
        console.log('[ADMIN] auth event:', _evt, session?.user?.email);
        // Only update admin UI if on admin module or on SIGNED_IN event
        if (_evt === 'SIGNED_IN' || location.hash === '#admin-module') {
          flipUI(session?.user?.email || null);
        }
      });
    }

    // first paint
    paintFromSession();
  })();
  </script>


  <!-- Final CSS overrides to guarantee alignment (left text, centered block) -->
  <style>
    .reports-controls-outer{display:flex !important;justify-content:center !important;align-items:center !important;width:100% !important;}
    .reports-controls{display:grid !important;grid-template-columns:max-content var(--control-width) max-content var(--control-width) !important;column-gap:1rem !important;row-gap:.75rem !important;width:auto !important;align-items:center !important;}
    .reports-controls label{justify-self:end !important;}
    .reports-controls select{text-align:left !important;}
    .reports-controls .choices,
    .reports-controls .choices__inner,
    .reports-controls .choices__list--single,
    .reports-controls .choices__item,
    .reports-controls .choices__input{text-align:left !important;}
    .reports-controls .choices__list--single{justify-content:flex-start !important;}
    @media (max-width:760px){
      .reports-controls{grid-template-columns:1fr !important;justify-items:center !important;}
      .reports-controls label{justify-self:center !important;}
    }

    /* === Performance tables under the chart === */
    .report-table{ table-layout: fixed; width:96%; max-width:1280px; }
    .report-table th, .report-table td{ word-wrap: break-word; white-space: normal; }
    
    .report-tables-wrapper{
      display:flex;
      justify-content:center;
      margin-top:16px;
    }
    .report-table{
      width:96%;
      max-width:1280px;
      border-collapse:collapse;
      font-family: 'Aptos', system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      font-size:13px;
      text-align:left;
    }
    .report-table th,.report-table td{
      padding:10px 12px;
      border:1px solid #d7d7d7;
      white-space:nowrap;
    }
    .report-table thead th{
      background:#e5e7eb;     /* header grey like screenshots */
      font-weight:700;
      text-align:center;
    }
    .report-table tbody tr:nth-child(odd) td{ background:#f3f4f6; } /* zebra */
    .report-table td.metric-cell{ font-weight:700; color:#0f172a; }
    .report-table td.metric-muted{ color:#9ca3af; font-weight:600; } /* “comparison” second row */
    .report-table{ table-layout: fixed; width:96%; max-width:1280px; }
    .report-table th, .report-table td{ word-wrap: break-word; white-space: normal; }

    /* Hide old CBM Allocate + Convert controls, but keep Scan visible */
    #balance-maintenance-module #bmAllocBtn,
    #balance-maintenance-module #bmConvertBtn,
    #balance-maintenance-module #bmConvertMode {
      display: none !important;
    }

    /* Back-test form extras */
    .bt-form-actions {
      grid-column: 1 / -1;          /* span full width of the grid */
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.35rem;
      margin-top: 0.5rem;
    }

    #btRunBtn {
      min-width: 9rem;
    }

    #btInlineError.inline-error {
      color: #b91c1c;
      font-size: 0.85rem;
    }

    .bt-note {
      font-size: 0.85rem;
      color: #6b7280;
      max-width: 480px;
    }

    /* Executed-orders collapsible */
    .executed-collapsible summary{cursor:pointer;font-weight:600;margin:.5rem 0}
    .executed-list table{width:100%;border-collapse:collapse}
    .executed-list th, .executed-list td { border:1px solid #eee; padding:.4rem; font-size:.9rem }
    .executed-list .muted{opacity:.7}

    /* Hide global Customer selector on multi-customer modules */
    body[data-active-module="transactions-module"] #ctxCustomerGroup,
    body[data-active-module="strategy-maintenance-module"] #ctxCustomerGroup{
      display: none !important;
    }

    </style>


  <noscript>
    <div style="padding:1em;margin:1em;border:1px solid var(--border);border-radius:10px;background:#fff3cd;color:#7a5a00;">
      This page needs JavaScript enabled.
    </div>
  </noscript>

  <script>
    /* =========================
       Export Customer Charts to PDF (improved)
       - Robust logo capture
       - True landscape pages
       - Smart chart/table scaling
       - AI narrative fetch (fallback to DOM)
       ========================= */
    (function(){
      const exportBtn = document.getElementById('exportPdfBtn');
      if (!exportBtn) return;

      // ---- Configuration you can tweak ----
      const EDGE_FUNCTION_NARRATIVE = 'chart-narrative'; // <-- set to your actual EF name
      const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';

      // ---- Small helpers ----
      function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
      function normalizeDate(val){
        if (val == null) return '';
        const s = String(val).trim();

        // Already a plain calendar date (YYYY-MM-DD or YYYY/MM/DD)
        if (/^\d{4}[-/]\d{2}[-/]\d{2}$/.test(s)) return s.slice(0, 10);

        // Compact yyyymmdd
        const m = s.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (m) return `${m[1]}-${m[2]}-${m[3]}`;

        // Fallback: parse and render as local date (no UTC shift)
        const t = Date.parse(s);
        if (!Number.isNaN(t)) {
          const d = new Date(t);
          const y = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          const dd = String(d.getDate()).padStart(2, '0');
          return `${y}-${mm}-${dd}`;
        }

        return s;
      }
      
      function disclaimer(){ return 'This report is for information only and is not financial advice. Past performance is not indicative of future results.'; }

      async function elementToPng(el, widthPx){
        const scale = Math.min(2, (widthPx || 1400) / Math.max(1200, el.offsetWidth || 1200));
        const canvas = await html2canvas(el, { scale });
        return canvas.toDataURL('image/png', 1.0);
      }

      // Try several ways to get a logo image as a dataURL
      async function getLogoDataUrl(){
        const img = document.getElementById('pdfLogo');
        if (!img) return null;

        // ensure image is loaded
        if (!img.complete || !img.naturalWidth) {
          await new Promise((res, rej) => {
            img.addEventListener('load', res, { once:true });
            img.addEventListener('error', () => rej(new Error('Logo failed to load')), { once:true });
          });
        }
        // draw it to a canvas → dataURL (works for relative paths without CORS headaches)
        const can = document.createElement('canvas');
        can.width = img.naturalWidth;
        can.height = img.naturalHeight;
        const ctx = can.getContext('2d');
        ctx.drawImage(img, 0, 0);
        return can.toDataURL('image/png', 1.0);
      }

      // Build offscreen chart PNG so we don’t disturb your on-screen chart
      async function buildChartImage({ type, advRows, stdRows }){
        const c = document.createElement('canvas'); c.width = 1400; c.height = 650;
        const ctx = c.getContext('2d');
        const labelsFrom = (rows)=> (rows||[]).map(r=> normalizeDate(r.transaction_date));
        const mergeLabels = (a,b)=> Array.from(new Set([...(a||[]), ...(b||[])])).sort();
        const col = {
          btc: cssVar('--series-btc-price') || '#ff8c00',
          inv: cssVar('--series-invested') || '#000000',
          adv: cssVar('--series-adv-value') || '#22c55e',
          usd: cssVar('--series-usd-balance') || '#60a5fa',
          btcBal: cssVar('--series-btc-balance') || '#ef4444',
          compAdv: cssVar('--series-comp-adv') || '#032C48',
          compStd: cssVar('--series-comp-std') || '#BEBEBE'
        };

        let chart;
        if(type === 'holdings'){
          const labels = labelsFrom(window.advData||[]);
          chart = new Chart(ctx, {
            type:'line',
            data:{labels,
              datasets:[
                { label:'BTC Closing Price', data:(window.advData||[]).map(r=>r.btc_closing_price_usd), borderColor:col.btc, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label:'Total Investment',  data:(window.advData||[]).map(r=>r.total_dca_invested_usd), borderColor:col.inv, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label:'Advanced DCA Portfolio Value', data:(window.advData||[]).map(r=>r.portfolio_value_usd), borderColor:col.adv, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label:'USD Balance',       data:(window.advData||[]).map(r=>r.closing_balance_usd), borderColor:col.usd, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label:'BTC Balance',       data:(window.advData||[]).map(r=>r.closing_balance_btc), borderColor:col.btcBal, fill:false, pointRadius:0, tension:.22, borderWidth:2 }
              ]},
            options:{ responsive:false, animation:false, plugins:{legend:{position:'top'}} }
          });
        } else {
          const L1 = labelsFrom(window.advData||[]), L2 = labelsFrom(window.stdData||[]), labels = mergeLabels(L1,L2);
          const key = type==='comp_value' ? 'portfolio_value_usd' : (type==='comp_roi' ? 'total_roi_percent' : 'cagr_percent');
          const toMap = (rows)=> { const m={}; (rows||[]).forEach(r=> m[normalizeDate(r.transaction_date)] = r[key]); return labels.map(d=> m[d] ?? null); };
          chart = new Chart(ctx, {
            type:'line',
            data:{labels,
              datasets:[
                { label: type==='comp_value' ? 'Advanced DCA Portfolio Value' : (type==='comp_roi' ? 'Advanced DCA ROI %' : 'Advanced DCA Ann. Growth %'),
                  data: toMap(window.advData), borderColor:col.compAdv, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label: type==='comp_value' ? 'Standard DCA Portfolio Value' : (type==='comp_roi' ? 'Standard DCA ROI %' : 'Standard DCA Ann. Growth %'),
                  data: toMap(window.stdData), borderColor:col.compStd, fill:false, pointRadius:0, tension:.22, borderWidth:2 }
              ]},
            options:{ responsive:false, animation:false, plugins:{legend:{position:'top'}} }
          });
        }
        await new Promise(r=>setTimeout(r,10));
        const dataUrl = c.toDataURL('image/png', 1.0);
        chart.destroy();
        return dataUrl;
      }

      // Yearly table builders (use your snapshots views)
      function fmtUSD(v){ return v==null ? '-' : Number(v).toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0}); }
      function fmtBTC(v){ return v==null ? '-' : Number(v).toLocaleString('en-US',{minimumFractionDigits:3,maximumFractionDigits:3}); }
      function fmtPct(v){ 
        if (v==null) return '-'; 
        const n = Number(v)*100; 
        return `${n.toLocaleString('en-US',{maximumFractionDigits:0})}%`; 
      }
      function headersByYears(advRows){
        const years = (advRows||[]).map(r => Number(r.trading_year));
        if(!years.length) return ['Metric'];
        const maxTY = Math.max(...years);
        const h = ['Metric']; years.forEach((ty,i) => h.push(`${ty===maxTY ? '*' : ''}Year ${i+1}`));
        return h;
      }

      function buildYearTableHTML(reportType, advRows, stdRows){
        const fmtUSD = (v)=> v==null ? '-' : Number(v).toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
        const fmtBTC = (v)=> v==null ? '-' : Number(v).toLocaleString('en-US',{minimumFractionDigits:3,maximumFractionDigits:3});
        const fmtPct = (v)=> v==null ? '-' : `${Number(v).toLocaleString('en-US',{maximumFractionDigits:0})}%`;

        const headers = headersByYears(advRows);
        const stdByTY = new Map((stdRows||[]).map(r => [Number(r.trading_year), r]));

        let rows = [];
        if (reportType === 'holdings'){
          rows = [
            ['BTC Price',           ...(advRows||[]).map(r => fmtUSD(r.btc_closing_price_usd))],
            ['Total Investment',    ...(advRows||[]).map(r => fmtUSD(r.total_dca_invested_usd))],
            ['Portfolio Value',     ...(advRows||[]).map(r => fmtUSD2(r.portfolio_value_usd))],
            ['BTC Holdings',       ...(advRows||[]).map(r => fmtBTC(r.closing_balance_btc))],
            ['Cumulative ROI',      ...(advRows||[]).map(r => fmtPct1(r.total_roi_percent))],
            ['Annualised Growth',   ...(advRows||[]).map(r => fmtPct1(r.cagr_percent))],
            ['USD Holdings',        ...(advRows||[]).map(r => fmtUSD(r.closing_balance_usd))],
          ];
        } else if (reportType === 'comp_value'){
          rows = [
            ['Advanced DCA<br>Portfolio Value', ...(advRows||[]).map(r => fmtUSD2(r.portfolio_value_usd))],
            ['Standard DCA<br>Comparative<br>Portfolio Value', ...(advRows||[]).map(r => {
              const s = stdByTY.get(Number(r.trading_year));
              return fmtUSD2(s?.portfolio_value_usd ?? null);
            })],
          ];
        } else if (reportType === 'comp_roi'){
          rows = [
            ['Advanced DCA<br>Portfolio Total ROI', ...(advRows||[]).map(r => fmtPct1(r.total_roi_percent))],
            ['Standard DCA<br>Portfolio Total ROI',  ...(advRows||[]).map(r => {
              const s = stdByTY.get(Number(r.trading_year));
              return fmtPct1(s?.total_roi_percent ?? null);
            })],
          ];
        } else if (reportType === 'comp_agr'){
          rows = [
            ['Advanced DCA<br>Portfolio<br>Annualised CAGR', ...(advRows||[]).map(r => fmtPct1(r.cagr_percent))],
            ['Standard DCA<br>Portfolio<br>Annualised CAGR',  ...(advRows||[]).map(r => {
              const s = stdByTY.get(Number(r.trading_year));
              return fmtPct1(s?.cagr_percent ?? null);
            })],
          ];
        }

        const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
        const tbody = rows.map((row, i) => {
          const isMuted = (reportType.startsWith('comp_') && i === 1);
          const labelTd = `<td class="${isMuted ? 'metric-cell metric-muted' : 'metric-cell'}">${row[0]}</td>`;
          const cells = row.slice(1).map(v => `<td>${v}</td>`).join('');
          return `<tr>${labelTd}${cells}</tr>`;
        }).join('');

        // equal-width columns via <colgroup> (declare ONCE)
        const colCount = headers?.length ? headers.length : 1;
        const colgroup = `<colgroup>${
          Array.from({ length: colCount }, () => `<col style="width:${(100/colCount)}%;"></col>`).join('')
        }</colgroup>`;

        return `<table class="report-table">${colgroup}${thead}<tbody>${tbody}</tbody></table>`;
      }

      async function fetchYearlySnapshots(customerId){
        const [{ data: advRows, error: advErr }, { data: stdRows }] = await Promise.all([
          window.supabaseClient.from('real_customer_performance_annually')
            .select('trading_year, btc_closing_price_usd:latest_btc_closing_price_usd, total_dca_invested_usd:total_invested_usdt, portfolio_value_usd, closing_balance_btc, closing_balance_usd:closing_balance_usdt, total_roi_percent, cagr_percent')
            .eq('customer_id', customerId).order('trading_year', { ascending: true }),

          window.supabaseClient.from('real_std_compare_customer_performance_annually')
            .select('trading_year, portfolio_value_usd, total_roi_percent, cagr_percent')
            .eq('customer_id', customerId).order('trading_year', { ascending: true })
        ]);
        if (advErr) throw advErr;
        return { advRows: advRows||[], stdRows: stdRows||[] };
      }
      async function fetchCustomerName(customerId){
        const { data } = await window.supabaseClient
          .from('customer_details').select('first_names, last_name')
          .eq('customer_id', customerId).single();
        return { first: data?.first_names || '', last: data?.last_name || '' };
      }
      async function fetchNarrativeFor(type, customerId){
        try{
          // Use Supabase client to automatically include authentication
          if (!window.supabaseClient) {
            console.warn('[Narrative] Supabase client not ready');
            return 'Narrative unavailable for this chart.';
          }
          const { data, error } = await window.supabaseClient.functions.invoke('chart-narrative', {
            body: { customer_id: customerId, report_type: type }
          });
          if (error) {
            console.error('[Narrative] Error:', error);
            return 'Narrative unavailable for this chart.';
          }
          return (data?.text || data?.html || 'Narrative unavailable for this chart.');
        }catch(err){
          console.error('[Narrative] Exception:', err);
          return 'Narrative unavailable for this chart.';
        }
      }

      function addFooter(doc, text){
        const W = doc.internal.pageSize.getWidth();
        const H = doc.internal.pageSize.getHeight();
        doc.setFont('helvetica','italic'); doc.setFontSize(9);
        doc.setTextColor(120);
        doc.text(text, W/2, H - 18, { align:'center' });
      }

      async function exportPDF(){
        if(!window.jspdf){ alert('PDF library not loaded'); return; }
        // resolve the selected customer ID from global or the dropdown
        const selectedId =
          (typeof window.currentCustomerId !== 'undefined' && window.currentCustomerId) ||
          document.getElementById('customerSelect')?.value || '';

        if (!selectedId) { alert('Please select a customer first.'); return; }

        exportBtn.disabled = true;
        exportBtn.textContent = 'Preparing PDF…';

        try{
          const { jsPDF } = window.jspdf;

          // --- Cover (portrait) ---
          const doc = new jsPDF({ unit:'pt', format:'a4', orientation:'portrait' });
          const Wp = doc.internal.pageSize.getWidth();

          const logoData = await getLogoDataUrl();
          if(logoData){
            doc.addImage(logoData, 'PNG', (Wp-160)/2, 80, 160, 80, undefined, 'FAST');
          }
          const { first, last } = await fetchCustomerName(selectedId);
          const today = new Date().toISOString().slice(0,10);
          doc.setFont('helvetica','bold'); doc.setFontSize(18);
          doc.text(`Portfolio Performance Report of ${first} ${last} as at ${today}`, Wp/2, 220, { align:'center' });
          doc.setFont('helvetica','normal'); doc.setFontSize(11);
          doc.text('Advanced DCA Strategy — BitWealth', Wp/2, 245, { align:'center' });
          addFooter(doc, disclaimer());

          // --- Data we reuse on all sections ---
          const { advRows, stdRows } = await fetchYearlySnapshots(selectedId);
          const sections = [
            { key:'holdings',   title:'Portfolio Holdings' },
            { key:'comp_value', title:'Comparison — Portfolio Value' },
            { key:'comp_roi',   title:'Comparison — ROI' },
            { key:'comp_agr',   title:'Comparison — Annualised Growth' },
          ];

          // Hidden container for screenshotting the year-table
          const tmp = document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-99999px'; tmp.style.top='-99999px';
          document.body.appendChild(tmp);

          for(const s of sections){
            // force reliable landscape page
            doc.addPage('a4', 'l'); // force landscape

            // page dims + margins
            const W = doc.internal.pageSize.getWidth();
            const H = doc.internal.pageSize.getHeight();
            const margin = 36;
            const topTitle = 50;

            // available space calculation (to prevent overflow)
            const footerSpace = 28;
            const titleSpace = 20;
            const gap = 12; // gap between blocks

            // 1) Title
            doc.setFont('helvetica','bold'); doc.setFontSize(14); doc.setTextColor(20);
            doc.text(s.title, margin, topTitle);

            // 2) Chart (scale to fit half the page height)
            const chartPng = await buildChartImage({ type:s.key });
            // reserve roughly 45% height for chart, 30% for table, rest for narrative
            const maxChartH = (H - topTitle - footerSpace - gap*3) * 0.45;
            const chartW = W - margin*2;
            const chartH = Math.min(maxChartH, chartW * (650/1400));
            doc.addImage(chartPng, 'PNG', margin, topTitle + gap, chartW, chartH, undefined, 'FAST');

            // 3) Table under chart (render off-screen HTML to PNG)
            tmp.innerHTML = `<section class="report-tables-wrapper">${buildYearTableHTML(s.key, advRows, stdRows)}</section>`;
            const tableEl = tmp.querySelector('.report-tables-wrapper');
            const tablePng = await elementToPng(tableEl, 1400);

            const tableTop = topTitle + gap + chartH + gap;
            const maxTableH = (H - tableTop - footerSpace - gap*2) * 0.35;
            const tableW = chartW;
            const tableH = Math.min(maxTableH, tableW * 0.26); // safe default ratio
            doc.addImage(tablePng, 'PNG', margin, tableTop, tableW, tableH, undefined, 'FAST');

            // 4) Narrative
            const narrativeText = await fetchNarrativeFor(s.key, selectedId);
            doc.setFont('helvetica','normal'); doc.setFontSize(11); doc.setTextColor(40);
            const textTop = tableTop + tableH + gap;
            const maxTextWidth = W - margin*2;
            const lines = doc.splitTextToSize(narrativeText, maxTextWidth);
            // ensure narrative doesn't collide with footer; trim if needed
            const lineHeight = 14;
            const maxLines = Math.floor((H - textTop - footerSpace - gap) / lineHeight);
            const safeLines = lines.slice(0, Math.max(0, maxLines));
            doc.text(safeLines, margin, textTop, { maxWidth: maxTextWidth });

            addFooter(doc, disclaimer());
          }

          document.body.removeChild(tmp);
          doc.save(`BitWealth_Portfolio_Performance_${first}_${last}_${today}.pdf`);
        }catch(err){
          console.error(err);
          alert('Could not build PDF. See console for details.');
        }finally{
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export Customer Charts to PDF';
        }
      }

      if (!exportBtn._bound) {
        exportBtn.addEventListener('click', exportPDF);
        exportBtn._bound = true;
      }
    })();
  </script>
  <script>
  (() => {
    const SB = () => {
      const c = window.supabaseClient;
      if (!c) throw new Error('Supabase not ready');
      return c;
    };
    const wrap = document.getElementById('executedDetails');
    const list = document.getElementById('executedList');

    async function loadExecutedLast7Days(){
      const now = new Date();
      const start7 = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - 7, 0, 0, 0)).toISOString();

      list.textContent = 'Loading…';
      const { data, error } = await SB()
        .from('exchange_order_intents')
        .select('intent_id, status, source_signal, intent_usdt, intent_btc, intent_price, avg_price, min_notional, exchange_order_id, notes, created_at, symbol, side')
        .in('status', ['filled','cancelled','error'])
        .gte('created_at', start7)
        .order('created_at', { ascending: false });

      if (error) {
        console.error(error);
        list.textContent = 'Error loading executed orders.';
        return;
      }

      const cnt = wrap.querySelector('.count');
      if (cnt) cnt.textContent = `(${data?.length || 0})`;

      if (!data || !data.length) {
        list.textContent = 'No executed orders in the last 7 days.';
        return;
      }

      const rows = data.map(r => {
        const when = r.created_at ? new Date(r.created_at) : null;
        const d = when ? when.toISOString().slice(0,10) : '—';
        const t = when ? when.toLocaleTimeString([], { hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' }) : '—';
        const px = r.avg_price ?? r.intent_price ?? '—';
        const usdt = r.intent_usdt ?? '—';
        const btc  = r.intent_btc  ?? '—';
        const sig  = r.source_signal || '—';
        const exid = r.exchange_order_id || '—';
        const st   = (r.status || '').toLowerCase();

        return `<tr>
          <td class="muted">${d} ${t}</td>
          <td>${(r.symbol||'').toUpperCase()} ${(r.side||'').toUpperCase()}</td>
          <td><span class="status-pill ${st}">${st}</span></td>
          <td>${sig}</td>
          <td>${usdt}</td>
          <td>${btc}</td>
          <td>${px}</td>
          <td class="muted">${exid}</td>
        </tr>`;
      }).join('');

      list.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>When</th><th>Pair/Side</th><th>Status</th><th>Signal</th>
              <th>USDT</th><th>BTC</th><th>Price</th><th>Exchange ID</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    // Expose a stable name so other code can call it after preview/execute
    window.loadExecutedOrders = loadExecutedLast7Days;

    // Load once on page open
    loadExecutedLast7Days();
  })();

  // --- Alerts card (Administration module) ---
  (() => {
    const tableBody   = document.querySelector('#alertsTable tbody');
    const refreshBtn  = document.getElementById('alertsRefreshBtn');
    const openOnlyChk = document.getElementById('alertsOpenOnlyChk');
    const autoRefreshChk = document.getElementById('alertsAutoRefreshChk');
    const componentFilter = document.getElementById('alertsComponentFilter');
    const alertBadge = document.getElementById('alertBadge');

    if (!tableBody || !refreshBtn) return;

    let autoRefreshInterval = null;

    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/[&<>"']/g, (ch) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch] || ch));
    }

    function severityClass(sev) {
      const s = String(sev || '').toLowerCase();
      if (s === 'critical') return 'critical';
      if (s === 'error')    return 'error';
      if (s === 'warn' || s === 'warning') return 'warn';
      return 'info';
    }

    function fmtDate(iso) {
      if (!iso) return '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return iso;
      return d.toLocaleString();
    }

    async function loadAlerts() {
      // Check if authenticated first
      if (!supabaseClient) {
        tableBody.innerHTML = '<tr><td colspan="6">Loading Supabase client…</td></tr>';
        return;
      }
      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">Please sign in via Administration tab to view alerts.</td></tr>';
        if (alertBadge) {
          alertBadge.textContent = '0';
          alertBadge.classList.add('zero');
        }
        return;
      }

      // Load alerts
      tableBody.innerHTML = '<tr><td colspan="6">Loading…</td></tr>';
      const onlyOpen = !openOnlyChk || openOnlyChk.checked;
      const component = componentFilter ? componentFilter.value : '';

      const { data, error } = await supabaseClient.rpc('list_lth_alert_events', {
        p_only_open: onlyOpen,
        p_limit: 100
      });

      // Filter by component on client side if specified
      let filteredData = data;
      if (data && component) {
        filteredData = data.filter(row => row.component === component);
      }

      if (error) {
        console.error('loadAlerts error', error);
        tableBody.innerHTML =
          '<tr><td colspan="6" class="error">Failed to load alerts: ' +
          escapeHtml(error.message || String(error)) +
          '</td></tr>';
        return;
      }

      // Update badge with open alert count (unfiltered)
      if (alertBadge && data) {
        const openCount = data.filter(row => !row.resolved_at).length;
        alertBadge.textContent = String(openCount);
        if (openCount === 0) {
          alertBadge.classList.add('zero');
        } else {
          alertBadge.classList.remove('zero');
        }
      }

      if (!filteredData || filteredData.length === 0) {
        tableBody.innerHTML =
          '<tr><td colspan="6" class="muted">No alerts.</td></tr>';
        return;
      }

      const rowsHtml = filteredData.map((row) => {
        const created  = fmtDate(row.created_at);
        const resolved = row.resolved_at ? fmtDate(row.resolved_at) : '';
        const sevClass = severityClass(row.severity);
        const sevLabel = escapeHtml(row.severity || '');
        const component = escapeHtml(row.component || '');
        const message   = escapeHtml(row.message || '');

        const resolveBtn = row.resolved_at
          ? ''
          : '<button type="button" class="btn btn-secondary-sm js-alert-resolve">Resolve</button>';

        return `
          <tr data-alert-id="${row.alert_id}">
            <td>${created}</td>
            <td><span class="status-pill ${sevClass}">${sevLabel}</span></td>
            <td>${component}</td>
            <td>${message}</td>
            <td>${resolved}</td>
            <td>${resolveBtn}</td>
          </tr>
        `;
      }).join('');

      tableBody.innerHTML = rowsHtml;
    }

    async function handleResolveClick(ev) {
      const target = ev.target;
      if (!(target instanceof HTMLElement)) return;
      const btn = target.closest('.js-alert-resolve');
      if (!btn) return;
      const tr = btn.closest('tr');
      if (!tr) return;
      const alertId = tr.getAttribute('data-alert-id');
      if (!alertId) return;

      const note = window.prompt('Optional note to attach when resolving this alert:', '');
      
      // If user clicked Cancel, note will be null - abort the operation
      if (note === null) return;
      
      // If user left it blank (empty string), pass null to the RPC
      const resolveNote = note.trim() === '' ? null : note;

      btn.setAttribute('disabled', 'true');
      btn.textContent = 'Resolving…';

      const { error } = await supabaseClient.rpc('resolve_lth_alert_event', {
        p_alert_id: alertId,
        p_resolved_by: 'ui-admin',
        p_resolution_note: resolveNote
      });

      if (error) {
        console.error('resolve alert error', error);
        window.alert('Failed to resolve alert: ' + (error.message || String(error)));
        btn.removeAttribute('disabled');
        btn.textContent = 'Resolve';
        return;
      }

      await loadAlerts();
    }

    function toggleAutoRefresh() {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
      if (autoRefreshChk && autoRefreshChk.checked) {
        autoRefreshInterval = setInterval(loadAlerts, 30000);
      }
    }

    refreshBtn.addEventListener('click', loadAlerts);
    if (openOnlyChk) openOnlyChk.addEventListener('change', loadAlerts);
    if (autoRefreshChk) autoRefreshChk.addEventListener('change', toggleAutoRefresh);
    if (componentFilter) componentFilter.addEventListener('change', loadAlerts);
    tableBody.addEventListener('click', handleResolveClick);

    // Stop auto-refresh when leaving admin module
    document.querySelectorAll('nav a').forEach(link => {
      link.addEventListener('click', (e) => {
        if (!e.target.href.includes('#admin-module')) {
          if (autoRefreshInterval) {
            clearInterval(autoRefreshInterval);
            autoRefreshInterval = null;
          }
          // Also uncheck the checkbox
          if (autoRefreshChk) autoRefreshChk.checked = false;
        }
      });
    });

    // Expose loadAlerts globally so auth handler can call it
    window.loadAlerts = loadAlerts;

    // Don't auto-load alerts on DOMContentLoaded anymore - wait for authentication
    // The auth state change handler will call loadAlerts() after sign-in
    document.addEventListener('DOMContentLoaded', () => {
      // Check if already authenticated and load
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user) {
            loadAlerts();
          }
        });
      }
    });
  })();

  // ===================== Accumulated Fees (Finance Module) =====================
  // Global functions for Finance module (outside any IIFE scope)
  async function loadAccumulatedFees() {
    const loadingEl = document.getElementById('accumulatedFeesLoading');
    const errorEl = document.getElementById('accumulatedFeesError');
    const errorMessageEl = document.getElementById('accumulatedFeesErrorMessage');
    const noFeesEl = document.getElementById('noAccumulatedFees');
    const tableContainer = document.getElementById('accumulatedFeesTableContainer');
    const tableBody = document.getElementById('accumulatedFeesTableBody');

    if (!loadingEl || !errorEl || !tableContainer || !tableBody) {
      console.error('Accumulated fees elements not found');
      return;
    }

    // Show loading, hide others
    loadingEl.style.display = 'block';
    errorEl.style.display = 'none';
    noFeesEl.style.display = 'none';
    tableContainer.style.display = 'none';

    try {
      // Check authentication
      if (!supabaseClient) {
        throw new Error('Supabase client not initialized');
      }

      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        throw new Error('Please sign in via Administration tab to view accumulated fees');
      }

      // Call list_accumulated_fees RPC
      const { data, error } = await supabaseClient.rpc('list_accumulated_fees');

      if (error) {
        throw new Error(error.message || 'Failed to load accumulated fees');
      }

      // Fetch thresholds from system_config (both transfer and conversion)
      const { data: configData, error: configError } = await supabaseClient
        .schema('lth_pvr')
        .from('system_config')
        .select('config_key, config_value')
        .in('config_key', [
          'valr_min_transfer_btc',
          'valr_min_transfer_usdt',
          'valr_min_conversion_btc',
          'valr_min_conversion_usdt'
        ]);

      let minTransferBtc = 0.000001;
      let minTransferUsdt = 0.06;
      let minConversionBtc = 0.00001;
      let minConversionUsdt = 0.52;

      if (!configError && configData) {
        const transferBtcConfig = configData.find(c => c.config_key === 'valr_min_transfer_btc');
        const transferUsdtConfig = configData.find(c => c.config_key === 'valr_min_transfer_usdt');
        const conversionBtcConfig = configData.find(c => c.config_key === 'valr_min_conversion_btc');
        const conversionUsdtConfig = configData.find(c => c.config_key === 'valr_min_conversion_usdt');
        
        if (transferBtcConfig) minTransferBtc = parseFloat(transferBtcConfig.config_value);
        if (transferUsdtConfig) minTransferUsdt = parseFloat(transferUsdtConfig.config_value);
        if (conversionBtcConfig) minConversionBtc = parseFloat(conversionBtcConfig.config_value);
        if (conversionUsdtConfig) minConversionUsdt = parseFloat(conversionUsdtConfig.config_value);
      }

      // Update dynamic labels with fetched thresholds
      const descriptionEl = document.getElementById('accumulatedFeesDescription');
      if (descriptionEl) {
        descriptionEl.textContent = `Platform fees below VALR transfer threshold (BTC: ${minTransferBtc.toFixed(8).replace(/\.?0+$/, '')} = ${(minTransferBtc * 100000000).toFixed(0)} sats, USDT: $${minTransferUsdt.toFixed(2)}) awaiting batch transfer.`;
      }
      const thresholdInfoEl = document.getElementById('accumulatedFeesThresholdInfo');
      if (thresholdInfoEl) {
        thresholdInfoEl.textContent = `Fees are transferred at ${minTransferBtc.toFixed(8)} BTC / $${minTransferUsdt.toFixed(2)} USDT, converted at ${minConversionBtc.toFixed(8)} BTC / $${minConversionUsdt.toFixed(2)} USDT`;
      }

      loadingEl.style.display = 'none';

      // Disable "Transfer Now" button if no fees meet minimum thresholds
      const transferBtn = document.getElementById('transferAccumulatedFeesNow');
      if (transferBtn) {
        // Check if ANY customer has fees >= minimum transfer threshold
        const hasEligibleFees = data && data.some(customer => {
          const btc = parseFloat(customer.accumulated_btc) || 0;
          const usdt = parseFloat(customer.accumulated_usdt) || 0;
          return btc >= minTransferBtc || usdt >= minTransferUsdt;
        });

        if (!hasEligibleFees) {
          transferBtn.disabled = true;
          transferBtn.style.opacity = '0.5';
          transferBtn.style.cursor = 'not-allowed';
          transferBtn.title = `No fees meet minimum transfer thresholds (BTC ≥ ${minTransferBtc.toFixed(8)}, USDT ≥ $${minTransferUsdt.toFixed(2)})`;
        } else {
          transferBtn.disabled = false;
          transferBtn.style.opacity = '1';
          transferBtn.style.cursor = 'pointer';
          transferBtn.title = 'Trigger immediate batch transfer of eligible fees';
        }
      }

      if (!data || data.length === 0) {
        noFeesEl.style.display = 'block';
        return;
      }

      // Calculate totals
      let totalBtc = 0;
      let totalUsdt = 0;
      let totalUsd = 0;

      function escapeHtml(value) {
        if (value === null || value === undefined) return '';
        return String(value).replace(/[&<>"']/g, (ch) => ({
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        }[ch] || ch));
      }

      // Populate table
      tableBody.innerHTML = data.map(fee => {
        const btc = parseFloat(fee.accumulated_btc || 0);
        const usdt = parseFloat(fee.accumulated_usdt || 0);
        const usd = parseFloat(fee.total_usd || 0);

        totalBtc += btc;
        totalUsdt += usdt;
        totalUsd += usd;

        // Format date
        const lastUpdated = fee.last_updated_at 
          ? new Date(fee.last_updated_at).toLocaleString('en-GB', { 
              day: '2-digit', 
              month: '2-digit', 
              year: 'numeric', 
              hour: '2-digit', 
              minute: '2-digit' 
            })
          : '-';

        // Dual badge system: Transferable (green) vs Convertible (blue)
        const btcTransferable = btc >= minTransferBtc;
        const btcConvertible = btc >= minConversionBtc;
        const usdtTransferable = usdt >= minTransferUsdt;
        const usdtConvertible = usdt >= minConversionUsdt;

        let btcBadge = '';
        if (btcConvertible) {
          btcBadge = '<span style="background: #3b82f6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: 600; margin-left: 4px;" title="Ready for conversion to USDT">✨ CONVERTIBLE</span>';
        } else if (btcTransferable) {
          btcBadge = '<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: 600; margin-left: 4px;" title="Ready for transfer to main account">✓ TRANSFERABLE</span>';
        } else if (btc > 0) {
          btcBadge = '<span style="background: #f59e0b; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: 600; margin-left: 4px;" title="Accumulating">⏳</span>';
        }

        let usdtBadge = '';
        if (usdtConvertible) {
          usdtBadge = '<span style="background: #3b82f6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: 600; margin-left: 4px;" title="Ready for conversion">✨ CONVERTIBLE</span>';
        } else if (usdtTransferable) {
          usdtBadge = '<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: 600; margin-left: 4px;" title="Ready for transfer">✓ TRANSFERABLE</span>';
        } else if (usdt > 0) {
          usdtBadge = '<span style="background: #f59e0b; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: 600; margin-left: 4px;" title="Accumulating">⏳</span>';
        }

        const btcColor = btcConvertible ? '#3b82f6' : (btcTransferable ? '#10b981' : '#64748b');
        const usdtColor = usdtConvertible ? '#3b82f6' : (usdtTransferable ? '#10b981' : '#64748b');

        return `
          <tr style="border-bottom: 1px solid #e2e8f0;">
            <td style="padding: 12px; font-family: monospace;">${fee.customer_id}</td>
            <td style="padding: 12px;">${escapeHtml(fee.customer_name || '-')}</td>
            <td style="padding: 12px; color: #3b82f6;">${escapeHtml(fee.email || '-')}</td>
            <td style="padding: 12px; text-align: right; font-family: monospace; color: ${btcColor}; font-weight: 500;">
              ${btc.toFixed(8)}${btcBadge}
            </td>
            <td style="padding: 12px; text-align: right; font-family: monospace; color: ${usdtColor}; font-weight: 500;">
              $${usdt.toFixed(2)}${usdtBadge}
            </td>
            <td style="padding: 12px; text-align: right; font-family: monospace; font-weight: 600; color: #10b981;">
              $${usd.toFixed(2)}
            </td>
            <td style="padding: 12px; text-align: right; font-size: 13px; color: #64748b;">
              ${lastUpdated}
            </td>
            <td style="padding: 12px; text-align: right; font-family: monospace; color: #64748b;">
              ${fee.transfer_count || 0}
            </td>
          </tr>
        `;
      }).join('');

      // Update totals footer
      document.getElementById('totalAccumulatedBtc').textContent = totalBtc.toFixed(8);
      document.getElementById('totalAccumulatedUsdt').textContent = `$${totalUsdt.toFixed(2)}`;
      document.getElementById('totalAccumulatedUsd').textContent = `$${totalUsd.toFixed(2)}`;

      tableContainer.style.display = 'block';

    } catch (err) {
      console.error('Error loading accumulated fees:', err);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      errorMessageEl.textContent = err.message || 'Unknown error';
    }
  }

  async function transferAccumulatedFeesManually() {
    const btn = document.getElementById('transferAccumulatedFeesNow');
    if (!btn) return;

    // Confirm action
    if (!confirm('This will trigger an immediate batch transfer of all accumulated fees that meet minimum thresholds. Continue?')) {
      return;
    }

    // Disable button
    btn.disabled = true;
    btn.textContent = 'Transferring...';
    btn.style.opacity = '0.6';

    try {
      // Check authentication
      if (!supabaseClient) {
        throw new Error('Supabase client not initialized');
      }

      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        throw new Error('Not authenticated');
      }

      // Call ef_transfer_accumulated_fees edge function
      // Note: Uses anon key because function deployed with --no-verify-jwt (internal admin function)
      const response = await fetch(
        `${supabaseClient.supabaseUrl}/functions/v1/ef_transfer_accumulated_fees`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
          },
          body: JSON.stringify({})
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Transfer failed: ${errorText}`);
      }

      const result = await response.json();

      // Show success message
      alert(
        `Batch transfer complete!\n\n` +
        `✅ Transferred: ${result.transferred_count} customers\n` +
        `❌ Failed: ${result.failed_count} customers\n` +
        `₿ Total BTC: ${result.total_btc.toFixed(8)}\n` +
        `💵 Total USDT: $${result.total_usdt.toFixed(2)}`
      );

      // Reload accumulated fees table
      await loadAccumulatedFees();

    } catch (err) {
      console.error('Error transferring accumulated fees:', err);
      alert(`Error: ${err.message || 'Failed to transfer accumulated fees'}`);
    } finally {
      // Re-enable button
      btn.disabled = false;
      btn.textContent = 'Transfer Now';
      btn.style.opacity = '1';
    }
  }

  // Auto-load accumulated fees when Finance module is shown
  window.addEventListener('hashchange', () => {
    if (window.location.hash === '#finance-module') {
      setTimeout(() => {
        loadAccumulatedFees();
        loadMainAccountAccumulation();
      }, 500);
    }
  });

  // Initial load if Finance module is active
  if (window.location.hash === '#finance-module') {
    setTimeout(() => {
      loadAccumulatedFees();
      loadMainAccountAccumulation();
    }, 500);
  }

  // ===================== Main Account Accumulation (Finance Module) =====================
  async function loadMainAccountAccumulation() {
    const loadingEl = document.getElementById('mainAccountAccumulationLoading');
    const errorEl = document.getElementById('mainAccountAccumulationError');
    const errorMessageEl = document.getElementById('mainAccountAccumulationErrorMessage');
    const noAccumEl = document.getElementById('noMainAccountAccumulation');
    const contentEl = document.getElementById('mainAccountAccumulationContent');
    const convertBtn = document.getElementById('convertMainAccountBtcNow');

    if (!loadingEl || !errorEl || !contentEl) {
      console.error('Main account accumulation elements not found');
      return;
    }

    // Show loading, hide others
    loadingEl.style.display = 'block';
    errorEl.style.display = 'none';
    noAccumEl.style.display = 'none';
    contentEl.style.display = 'none';
    if (convertBtn) convertBtn.style.display = 'none';

    try {
      // Check authentication
      if (!supabaseClient) {
        throw new Error('Supabase client not initialized');
      }

      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        throw new Error('Please sign in via Administration tab to view main account accumulation');
      }

      // Call get_main_account_accumulation RPC
      const { data, error } = await supabaseClient.rpc('get_main_account_accumulation');

      if (error) {
        throw new Error(error.message || 'Failed to load main account accumulation');
      }

      loadingEl.style.display = 'none';

      if (!data || data.length === 0) {
        noAccumEl.style.display = 'block';
        return;
      }

      const accum = data[0];
      const btc = parseFloat(accum.accumulated_btc || 0);
      const usdt = parseFloat(accum.accumulated_usdt || 0);
      const sats = Math.round(btc * 100000000);

      // Show/hide convert button based on convertible status
      if (convertBtn && accum.btc_convertible) {
        convertBtn.style.display = 'inline-block';
      }

      // If no accumulation, show "no accumulation" message
      if (btc === 0 && usdt === 0) {
        noAccumEl.style.display = 'block';
        return;
      }

      // Update BTC amount
      const btcAmountEl = document.getElementById('mainAccountBtcAmount');
      const btcSatsEl = document.getElementById('mainAccountBtcSats');
      if (btcAmountEl) btcAmountEl.textContent = `${btc.toFixed(8)} BTC`;
      if (btcSatsEl) btcSatsEl.textContent = `${sats.toLocaleString()} sats`;

      // Update USDT amount
      const usdtAmountEl = document.getElementById('mainAccountUsdtAmount');
      if (usdtAmountEl) usdtAmountEl.textContent = `$${usdt.toFixed(2)}`;

      // Update conversion status badges
      const statusEl = document.getElementById('mainAccountConversionStatus');
      const btcBadgeEl = document.getElementById('mainAccountBtcStatusBadge');
      const usdtBadgeEl = document.getElementById('mainAccountUsdtStatusBadge');

      if (btcBadgeEl) {
        if (accum.btc_convertible) {
          btcBadgeEl.innerHTML = '<span style="background: #3b82f6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; margin-right: 4px;">✨ BTC CONVERTIBLE</span>';
        } else if (accum.btc_transferable) {
          btcBadgeEl.innerHTML = '<span style="background: #10b981; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; margin-right: 4px;">✓ BTC TRANSFERABLE</span>';
        } else if (btc > 0) {
          btcBadgeEl.innerHTML = '<span style="background: #f59e0b; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; margin-right: 4px;">⏳ BTC ACCUMULATING</span>';
        } else {
          btcBadgeEl.innerHTML = '';
        }
      }

      if (usdtBadgeEl) {
        if (accum.usdt_convertible) {
          usdtBadgeEl.innerHTML = '<span style="background: #3b82f6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">✨ USDT CONVERTIBLE</span>';
        } else if (accum.usdt_transferable) {
          usdtBadgeEl.innerHTML = '<span style="background: #10b981; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">✓ USDT TRANSFERABLE</span>';
        } else if (usdt > 0) {
          usdtBadgeEl.innerHTML = '<span style="background: #f59e0b; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">⏳ USDT ACCUMULATING</span>';
        } else {
          usdtBadgeEl.innerHTML = '';
        }
      }

      // Update conversion count
      const convCountEl = document.getElementById('mainAccountConversionCount');
      if (convCountEl) {
        const count = accum.conversion_count || 0;
        convCountEl.textContent = `${count} conversion${count === 1 ? '' : 's'}`;
      }

      // Show content
      contentEl.style.display = 'block';

    } catch (err) {
      console.error('Error loading main account accumulation:', err);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      if (errorMessageEl) {
        errorMessageEl.textContent = err.message || 'Unknown error occurred';
      }
    }
  }

  async function convertMainAccountBtcManually() {
    const btn = document.getElementById('convertMainAccountBtcNow');
    if (!btn) return;

    // Confirm action
    if (!confirm('This will convert all accumulated BTC in the main account to USDT via VALR market order. Continue?')) {
      return;
    }

    // Disable button
    btn.disabled = true;
    btn.textContent = 'Converting...';
    btn.style.opacity = '0.6';

    try {
      // Check authentication
      if (!supabaseClient) {
        throw new Error('Supabase client not initialized');
      }

      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        throw new Error('Not authenticated');
      }

      // Get current accumulation
      const { data: accumData, error: accumError } = await supabaseClient.rpc('get_main_account_accumulation');
      
      if (accumError) {
        throw new Error(`Failed to get accumulation: ${accumError.message}`);
      }

      if (!accumData || accumData.length === 0) {
        throw new Error('No accumulation data found');
      }

      const btcAmount = parseFloat(accumData[0].accumulated_btc || 0);
      
      if (btcAmount <= 0) {
        throw new Error('No BTC to convert');
      }

      // Call ef_convert_platform_fee_btc edge function
      const response = await fetch(
        `${supabaseClient.supabaseUrl}/functions/v1/ef_convert_platform_fee_btc`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
          },
          body: JSON.stringify({
            btc_amount: btcAmount,
            is_main_account: true
          })
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Conversion failed: ${errorText}`);
      }

      const result = await response.json();

      // Show success message
      alert(
        `BTC conversion successful!\n\n` +
        `₿ BTC Sold: ${result.btc_sold.toFixed(8)}\n` +
        `💵 USDT Received: $${result.usdt_received.toFixed(2)}\n` +
        `📊 Rate: $${result.btc_usd_rate.toFixed(2)}/BTC`
      );

      // Reload main account accumulation
      await loadMainAccountAccumulation();

    } catch (err) {
      console.error('Error converting main account BTC:', err);
      alert(`Error: ${err.message || 'Failed to convert BTC'}`);
    } finally {
      // Re-enable button
      btn.disabled = false;
      btn.textContent = 'Convert Now';
      btn.style.opacity = '1';
    }
  }

  /* ========== Customer Onboarding Pipeline Module (Milestone 2) ========== */
  (() => {
    const tableBody = document.querySelector('#prospectsTable tbody');
    const refreshBtn = document.getElementById('prospectsRefreshBtn');
    const searchInput = document.getElementById('prospectsSearchInput');
    const pendingOnlyCheckbox = document.getElementById('prospectsPendingOnlyCheckbox');
    const prospectsMessage = document.getElementById('prospectsMessage');

    if (!tableBody || !refreshBtn) return;

    let allProspects = [];
    let allStrategies = [];

    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/[&<>"']/g, (ch) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch] || ch));
    }

    function showMessage(msg, type) {
      prospectsMessage.textContent = msg;
      prospectsMessage.style.display = 'block';
      prospectsMessage.style.background = type === 'success' ? '#d4edda' : '#f8d7da';
      prospectsMessage.style.color = type === 'success' ? '#155724' : '#721c24';
      prospectsMessage.style.borderLeft = type === 'success' ? '4px solid #28a745' : '4px solid #dc3545';
      
      setTimeout(() => {
        prospectsMessage.style.display = 'none';
      }, 5000);
    }

    async function loadStrategies() {
      try {
        const { data, error } = await supabaseClient
          .from('strategies')
          .select('strategy_code, name, description')
          .order('name');

        if (error) throw error;
        allStrategies = data || [];
      } catch (err) {
        console.error('Error loading strategies:', err);
        allStrategies = [];
      }
    }

    async function loadProspects() {
      if (!supabaseClient) {
        tableBody.innerHTML = '<tr><td colspan="7">Loading Supabase client…</td></tr>';
        return;
      }

      refreshBtn.textContent = 'Loading...';
      refreshBtn.disabled = true;

      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session) {
        tableBody.innerHTML = '<tr><td colspan="7">Not authenticated</td></tr>';
        refreshBtn.textContent = 'Refresh';
        refreshBtn.disabled = false;
        return;
      }

      try {
        // Load strategies if not already loaded
        if (allStrategies.length === 0) {
          await loadStrategies();
        }

        let query = supabaseClient
          .from('customer_details')
          .select('customer_id, first_names, last_name, email, phone_number, phone_country_code, registration_status, created_at')
          .order('created_at', { ascending: false });

        if (pendingOnlyCheckbox.checked) {
          query = query.eq('registration_status', 'prospect');
        }

        const { data, error } = await query;

        if (error) throw error;

        allProspects = data || [];
        renderProspects();
      } catch (err) {
        console.error('Error loading prospects:', err);
        tableBody.innerHTML = `<tr><td colspan="7" style="color:#dc3545;">Error: ${escapeHtml(err.message)}</td></tr>`;
      } finally {
        refreshBtn.textContent = 'Refresh';
        refreshBtn.disabled = false;
      }
    }

    function renderProspects() {
      const searchTerm = searchInput.value.toLowerCase();
      
      const filtered = allProspects.filter(p => {
        const fullName = `${p.first_names} ${p.last_name}`.toLowerCase();
        const email = (p.email || '').toLowerCase();
        return fullName.includes(searchTerm) || email.includes(searchTerm);
      });

      if (filtered.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="7" class="muted">No prospects found</td></tr>';
        return;
      }

      const statusBadges = {
        'prospect': '<span style="background:#ffc107;color:#000;padding:2px 8px;border-radius:4px;font-size:0.85rem;">M1: Prospect</span>',
        'kyc': '<span style="background:#17a2b8;color:#fff;padding:2px 8px;border-radius:4px;font-size:0.85rem;">M3: KYC</span>',
        'setup': '<span style="background:#9c27b0;color:#fff;padding:2px 8px;border-radius:4px;font-size:0.85rem;">M4: Setup</span>',
        'deposit': '<span style="background:#ff9800;color:#fff;padding:2px 8px;border-radius:4px;font-size:0.85rem;">M5: Deposit</span>',
        'active': '<span style="background:#28a745;color:#fff;padding:2px 8px;border-radius:4px;font-size:0.85rem;">M6: Active</span>',
        'inactive': '<span style="background:#6c757d;color:#fff;padding:2px 8px;border-radius:4px;font-size:0.85rem;">Inactive</span>'
      };

      tableBody.innerHTML = filtered.map(p => {
        const phone = p.phone_country_code && p.phone_number 
          ? `${p.phone_country_code} ${p.phone_number}` 
          : '-';
        const submittedDate = p.created_at ? new Date(p.created_at).toLocaleDateString() : '-';
        const statusBadge = statusBadges[p.registration_status] || p.registration_status;
        
        let actionButton = '-';
        if (p.registration_status === 'prospect' && allStrategies.length > 0) {
          const strategyOptions = allStrategies.map(s => 
            `<option value="${escapeHtml(s.strategy_code)}">${escapeHtml(s.name)}</option>`
          ).join('');
          
          actionButton = `
            <div style="display:flex;gap:0.5rem;align-items:center;">
              <select id="strategy_${p.customer_id}" style="padding:0.4rem;border:1px solid #dee2e6;border-radius:4px;font-size:0.9rem;">
                <option value="">Select Strategy...</option>
                ${strategyOptions}
              </select>
              <button class="btn btn-primary-sm" onclick="confirmStrategy(${p.customer_id})">Confirm</button>
            </div>
          `;
        }

        return `
          <tr>
            <td>${escapeHtml(p.customer_id)}</td>
            <td>${escapeHtml(p.first_names)} ${escapeHtml(p.last_name)}</td>
            <td>${escapeHtml(p.email)}</td>
            <td>${escapeHtml(phone)}</td>
            <td>${statusBadge}</td>
            <td>${submittedDate}</td>
            <td>${actionButton}</td>
          </tr>
        `;
      }).join('');
    }

    // Global function for onclick handlers (Milestone 2: Confirm Strategy)
    window.confirmStrategy = async function(customerId) {
      const selectElement = document.getElementById(`strategy_${customerId}`);
      const strategyCode = selectElement?.value;

      if (!strategyCode) {
        showMessage('Please select a strategy first', 'error');
        return;
      }

      const strategyName = selectElement.options[selectElement.selectedIndex].text;

      if (!confirm(`Confirm strategy "${strategyName}" for customer ${customerId}?

This will:
• Create portfolio entry
• Change status to 'kyc'
• Send registration email to customer`)) {
        return;
      }

      try {
        const { data: { session } } = await supabaseClient.auth.getSession();
        const adminEmail = session?.user?.email || 'admin';

        const response = await fetch('https://wqnmxpooabmedvtackji.supabase.co/functions/v1/ef_confirm_strategy', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${supabaseClient.supabaseKey}`
          },
          body: JSON.stringify({
            customer_id: customerId,
            strategy_code: strategyCode,
            admin_email: adminEmail
          })
        });

        const result = await response.json();

        if (response.ok && result.success) {
          showMessage(`Strategy confirmed for customer ${customerId}. Email ${result.email_sent ? 'sent' : 'queued'} to ${result.email}`, 'success');
          await loadProspects();
        } else {
          showMessage(`Failed to confirm strategy: ${result.error || 'Unknown error'}`, 'error');
        }
      } catch (err) {
        console.error('Error confirming strategy:', err);
        showMessage(`Error: ${err.message}`, 'error');
      }
    };

    // Event listeners
    refreshBtn.addEventListener('click', loadProspects);
    searchInput.addEventListener('input', renderProspects);
    pendingOnlyCheckbox.addEventListener('change', loadProspects);

    // Initial load
    document.addEventListener('DOMContentLoaded', () => {
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user) {
            loadProspects();
          }
        });
      }
    });
  })();

  // =================== KYC ID Verification Module (Milestone 3) ===================
  (function() {
    const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';
    const SUPABASE_PUBLISHABLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indxbm14cG9vYWJtZWR2dGFja2ppIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzM0OTc2NzMsImV4cCI6MjA0OTA3MzY3M30.t7YhiLG9j1F1rkipICLbGRFAC3Tl44TqsN3jtv8zOvA';
    
    const refreshBtn = document.getElementById('kycRefreshBtn');
    const searchInput = document.getElementById('kycSearchInput');
    const tableBody = document.querySelector('#kycTable tbody');
    const messageDiv = document.getElementById('kycMessage');

    let allPendingKyc = [];

    // Show message
    function showMessage(text, type) {
      messageDiv.textContent = text;
      messageDiv.style.display = 'block';
      messageDiv.style.backgroundColor = type === 'success' ? '#d1fae5' : '#fee2e2';
      messageDiv.style.color = type === 'success' ? '#065f46' : '#991b1b';
      setTimeout(() => {
        messageDiv.style.display = 'none';
      }, 5000);
    }

    // Load pending KYC verifications
    async function loadPendingKyc() {
      try {
        const { data, error } = await supabaseClient
          .from('customer_details')
          .select('customer_id, first_names, last_name, email, kyc_id_document_url, created_at, registration_status')
          .eq('registration_status', 'kyc')
          .not('kyc_id_document_url', 'is', null)
          .order('created_at', { ascending: false });

        if (error) throw error;

        allPendingKyc = data || [];
        renderPendingKyc();
      } catch (err) {
        console.error('Error loading pending KYC:', err);
        showMessage(`Failed to load pending verifications: ${err.message}`, 'error');
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">Error loading data</td></tr>';
      }
    }

    // Render pending KYC table
    function renderPendingKyc() {
      const searchTerm = searchInput.value.toLowerCase();
      const filtered = allPendingKyc.filter(c => 
        c.first_names.toLowerCase().includes(searchTerm) ||
        c.last_name.toLowerCase().includes(searchTerm) ||
        c.email.toLowerCase().includes(searchTerm)
      );

      if (filtered.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">No pending verifications</td></tr>';
        return;
      }

      tableBody.innerHTML = filtered.map(customer => {
        const uploadDate = customer.created_at 
          ? new Date(customer.created_at).toLocaleString('en-ZA', { 
              dateStyle: 'short', 
              timeStyle: 'short' 
            })
          : 'N/A';

        // Extract filename from URL for display
        const fileName = customer.kyc_id_document_url 
          ? customer.kyc_id_document_url.split('/').pop().split('?')[0]
          : 'N/A';

        return `
          <tr>
            <td>${customer.customer_id}</td>
            <td>${customer.first_names} ${customer.last_name}</td>
            <td>${customer.email}</td>
            <td>${uploadDate}</td>
            <td>
              <a href="${customer.kyc_id_document_url}" target="_blank" 
                 style="color: #3b82f6; text-decoration: none; font-size: 0.85em;"
                 title="${fileName}">
                📄 View Document
              </a>
            </td>
            <td>
              <button class="btn btn-primary-sm" 
                      onclick="window.verifyKycId(${customer.customer_id}, '${customer.first_names}', '${customer.last_name}')"
                      style="padding: 0.4rem 0.8rem; font-size: 0.85em;">
                ✓ Verify
              </button>
            </td>
          </tr>
        `;
      }).join('');
    }

    // Global function for onclick (exposed to window)
    window.verifyKycId = async function(customerId, firstName, lastName) {
      const confirmed = confirm(
        `Verify ID document for ${firstName} ${lastName} (Customer ${customerId})?\n\n` +
        `This will:\n` +
        `• Change status from 'kyc' to 'setup'\n` +
        `• Record verification timestamp and your admin email\n` +
        `• Automatically create VALR subaccount\n` +
        `• Move customer to Milestone 4 (VALR Setup)`
      );

      if (!confirmed) return;

      try {
        // Get current admin user UUID
        const { data: { session } } = await supabaseClient.auth.getSession();
        const adminUserId = session?.user?.id;
        
        if (!adminUserId) {
          throw new Error('Admin session not found. Please log in again.');
        }

        // Update customer record
        const { error } = await supabaseClient
          .from('customer_details')
          .update({
            registration_status: 'setup',
            kyc_id_verified_at: new Date().toISOString(),
            kyc_verified_by: adminUserId
          })
          .eq('customer_id', customerId);

        if (error) throw error;

        // Automatically trigger VALR subaccount creation
        showMessage(`✓ ID verified for ${firstName} ${lastName}. Creating VALR subaccount...`, 'info');
        
        try {
          const { data: { session: authSession } } = await supabaseClient.auth.getSession();
          const response = await fetch(`${SUPABASE_URL}/functions/v1/ef_valr_create_subaccount`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authSession?.access_token || SUPABASE_PUBLISHABLE_KEY}`
            },
            body: JSON.stringify({
              customer_id: customerId,
              force_recreate: false
            })
          });

          const result = await response.json();
          
          if (response.ok && result.success) {
            showMessage(`✓ VALR subaccount created successfully for ${firstName} ${lastName}. Customer moved to Milestone 4.`, 'success');
            // Refresh both KYC table and VALR setup table
            await loadPendingKyc();
            if (typeof window.loadSetupCustomers === 'function') {
              await window.loadSetupCustomers();
            }
          } else if (response.status === 409) {
            // Subaccount already exists - this is OK, customer can proceed
            showMessage(`✓ ID verified for ${firstName} ${lastName}. VALR subaccount already exists (Customer moved to Milestone 4).`, 'success');
            await loadPendingKyc();
            if (typeof window.loadSetupCustomers === 'function') {
              await window.loadSetupCustomers();
            }
          } else {
            // Log error but don't block - admin can manually create later
            console.error('VALR subaccount creation failed:', result);
            showMessage(`⚠️ ID verified but subaccount creation failed: ${result.error || result.message || 'Unknown error'}. You can create it manually in VALR Account Setup.`, 'warning');
            // Refresh to remove from KYC list (moved to 'setup' status)
            await loadPendingKyc();
          }
        } catch (valrError) {
          console.error('VALR subaccount creation error:', valrError);
          showMessage(`⚠️ ID verified but subaccount creation failed: ${valrError.message}. You can create it manually in VALR Account Setup.`, 'warning');
          // Refresh to remove from KYC list (moved to 'setup' status)
          await loadPendingKyc();
        }

        await loadPendingKyc();
      } catch (err) {
        console.error('Error verifying KYC:', err);
        showMessage(`Failed to verify ID: ${err.message}`, 'error');
      }
    };

    // Event listeners
    refreshBtn.addEventListener('click', loadPendingKyc);
    searchInput.addEventListener('input', renderPendingKyc);

    // Initial load
    document.addEventListener('DOMContentLoaded', () => {
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user) {
            loadPendingKyc();
          }
        });
      }
    });
  })();

  // =================== VALR Account Setup Module (Milestone 4) ===================
  (function() {
    const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';
    const SUPABASE_PUBLISHABLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indxbm14cG9vYWJtZWR2dGFja2ppIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzM0OTc2NzMsImV4cCI6MjA0OTA3MzY3M30.t7YhiLG9j1F1rkipICLbGRFAC3Tl44TqsN3jtv8zOvA';
    
    const refreshBtn = document.getElementById('valrRefreshBtn');
    const searchInput = document.getElementById('valrSearchInput');
    const tableBody = document.querySelector('#valrTable tbody');
    const messageDiv = document.getElementById('valrMessage');

    let allSetupCustomers = [];

    // Show message
    function showMessage(text, type) {
      messageDiv.textContent = text;
      messageDiv.style.display = 'block';
      messageDiv.style.backgroundColor = type === 'success' ? '#d1fae5' : '#fee2e2';
      messageDiv.style.color = type === 'success' ? '#065f46' : '#991b1b';
      setTimeout(() => {
        messageDiv.style.display = 'none';
      }, 5000);
    }

    // Load customers in setup status
    // Make globally accessible so KYC verification can trigger refresh
    window.loadSetupCustomers = async function() {
      try {
        // Get customers with status='setup' or 'deposit'
        const { data: customers, error: customerError } = await supabaseClient
          .from('customer_details')
          .select('customer_id, first_names, last_name, email, registration_status')
          .in('registration_status', ['setup', 'deposit'])
          .order('created_at', { ascending: false });

        if (customerError) throw customerError;

        // Get their strategies (portfolios)
        const customerIds = (customers || []).map(c => c.customer_id);
        let portfolios = [];
        if (customerIds.length > 0) {
          const { data: portfolioData, error: portfolioError } = await supabaseClient
            .schema('public')
            .from('customer_strategies')
            .select('customer_id, portfolio_id, exchange_account_id')
            .in('customer_id', customerIds);
          
          if (portfolioError) console.error('Error loading portfolios:', portfolioError);
          portfolios = portfolioData || [];
        }

        // Get exchange accounts for those portfolios
        const exchangeAccountIds = portfolios
          .map(p => p.exchange_account_id)
          .filter(id => id != null);
        
        let exchangeAccounts = [];
        if (exchangeAccountIds.length > 0) {
          const { data: accountData, error: accountError } = await supabaseClient
            .from('exchange_accounts')
            .select('exchange_account_id, subaccount_id, deposit_ref, btc_wallet_address, usdt_wallet_address')
            .in('exchange_account_id', exchangeAccountIds);
          
          if (accountError) console.error('Error loading exchange accounts:', accountError);
          exchangeAccounts = accountData || [];
        }

        // Merge data
        allSetupCustomers = (customers || []).map(customer => {
          const portfolio = portfolios.find(p => p.customer_id === customer.customer_id);
          const account = portfolio ? exchangeAccounts.find(a => a.exchange_account_id === portfolio.exchange_account_id) : null;
          
          return {
            customer_id: customer.customer_id,
            first_names: customer.first_names,
            last_name: customer.last_name,
            email: customer.email,
            registration_status: customer.registration_status,
            subaccount_id: account?.subaccount_id || null,
            deposit_ref: account?.deposit_ref || null,
            btc_wallet_address: account?.btc_wallet_address || null,
            usdt_wallet_address: account?.usdt_wallet_address || null,
            exchange_account_id: account?.exchange_account_id || null
          };
        });

        renderSetupCustomers();
      } catch (err) {
        console.error('Error loading setup customers:', err);
        showMessage(`Failed to load VALR setup queue: ${err.message}`, 'error');
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">Error loading data</td></tr>';
      }
    }

    // Render setup customers table
    function renderSetupCustomers() {
      const searchTerm = searchInput.value.toLowerCase();
      const filtered = allSetupCustomers.filter(c => 
        c.first_names.toLowerCase().includes(searchTerm) ||
        c.last_name.toLowerCase().includes(searchTerm) ||
        c.email.toLowerCase().includes(searchTerm)
      );

      if (filtered.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">No customers in setup status</td></tr>';
        return;
      }

      tableBody.innerHTML = filtered.map(customer => {
        const hasSubaccount = !!customer.subaccount_id;
        const hasDepositRef = !!customer.deposit_ref;
        const hasBtcWallet = !!customer.btc_wallet_address;
        const hasUsdtWallet = !!customer.usdt_wallet_address;
        const hasAllReferences = hasDepositRef && hasBtcWallet && hasUsdtWallet;

        let actionButtons = '';
        
        if (!hasSubaccount) {
          // Show status: Automatic creation in progress or failed
          actionButtons = `
            <div style="color: #f59e0b; font-size: 0.85em;">
              ⏳ Auto-creating...
            </div>
            <button class="btn btn-secondary-sm" 
                    onclick="window.manualCreateValrSubaccount(${customer.customer_id}, '${customer.first_names}', '${customer.last_name}')"
                    style="padding: 0.4rem 0.8rem; font-size: 0.85em; margin-top: 0.3rem;">
              🔄 Retry Manually
            </button>
          `;
        } else if (!hasAllReferences) {
          // Show wallet address inputs + save button
          actionButtons = `
            <button class="btn btn-primary-sm" 
                    onclick="window.showWalletAddressModal(${customer.customer_id}, '${customer.first_names}', '${customer.last_name}', '${customer.deposit_ref || ''}', '${customer.btc_wallet_address || ''}', '${customer.usdt_wallet_address || ''}')"
                    style="padding: 0.4rem 0.8rem; font-size: 0.85em;">
              💳 ${hasDepositRef ? 'Add Wallet Addresses' : 'Enter All References'}
            </button>
          `;
        } else {
          // Show "Resend Email" button
          actionButtons = `
            <button class="btn btn-secondary-sm" 
                    onclick="window.resendDepositEmail(${customer.customer_id}, '${customer.email}')"
                    style="padding: 0.4rem 0.8rem; font-size: 0.85em;">
              📧 Resend Email
            </button>
          `;
        }

        return `
          <tr>
            <td>${customer.customer_id}</td>
            <td>${customer.first_names} ${customer.last_name}</td>
            <td>${customer.email}</td>
            <td style="font-family: monospace; font-size: 0.8em;">
              ${hasSubaccount ? customer.subaccount_id : '<span style="color: #999;">Not created</span>'}
            </td>
            <td style="font-family: monospace; font-size: 0.85em;">
              <div>${hasDepositRef ? customer.deposit_ref : '<span style="color: #999;">Pending</span>'}</div>
              <div style="font-size: 0.75em; color: #666; margin-top: 0.2rem;">
                ${hasBtcWallet ? '✓ BTC' : '⚠ BTC'} | ${hasUsdtWallet ? '✓ USDT' : '⚠ USDT'}
              </div>
            </td>
            <td>${actionButtons}</td>
          </tr>
        `;
      }).join('');
    }

    // Global function: Manual retry for VALR subaccount creation (when automatic fails)
    window.manualCreateValrSubaccount = async function(customerId, firstName, lastName) {
      const confirmed = confirm(
        `Manually create VALR subaccount for ${firstName} ${lastName}?\n\n` +
        `Use this if automatic creation failed during KYC verification.\n` +
        `This will call the VALR API to create a new subaccount.`
      );

      if (!confirmed) return;

      try {
        showMessage('Creating VALR subaccount...', 'info');

        const { data: { session } } = await supabaseClient.auth.getSession();
        const response = await fetch(`${SUPABASE_URL}/functions/v1/ef_valr_create_subaccount`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${session?.access_token || SUPABASE_PUBLISHABLE_KEY}`
          },
          body: JSON.stringify({ 
            customer_id: customerId,
            force_recreate: true  // Allow retry even if previous attempt logged
          })
        });

        const result = await response.json();

        if (response.ok && result.success) {
          showMessage(`✓ Subaccount created successfully: ${result.subaccount_id}`, 'success');
          await loadSetupCustomers();
        } else {
          showMessage(`Failed to create subaccount: ${result.message || result.error || 'Unknown error'}`, 'error');
        }
      } catch (err) {
        console.error('Error creating subaccount:', err);
        showMessage(`Error: ${err.message}`, 'error');
      }
    };

    // Global function: Show wallet address modal
    window.showWalletAddressModal = function(customerId, firstName, lastName, currentDepositRef, currentBtc, currentUsdt) {
      const modalHtml = `
        <div id="walletModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
          <div style="background: white; padding: 30px; border-radius: 8px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
            <h3 style="margin: 0 0 20px 0; color: #1e3a8a;">💳 Enter Deposit References for ${firstName} ${lastName}</h3>
            
            <div style="background: #dbeafe; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-left: 4px solid #3b82f6;">
              <strong style="color: #1e40af;">Step 1: Create Wallets in VALR Portal</strong>
              <ol style="font-size: 0.9em; color: #1e3a8a; margin: 10px 0 0 0; padding-left: 20px;">
                <li>Log into VALR: <a href="https://www.valr.com/" target="_blank" style="color: #3b82f6;">valr.com</a></li>
                <li>Navigate to: <strong>Subaccounts → [Customer Name] → Wallets</strong></li>
                <li>Create <strong>BTC wallet</strong> → Copy deposit address</li>
                <li>Create <strong>USDT wallet</strong> (select TRON network) → Copy deposit address</li>
              </ol>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label style="display: block; font-weight: 600; margin-bottom: 5px;">ZAR Deposit Reference:</label>
              <input type="text" id="modal_deposit_ref" value="${currentDepositRef}" 
                     placeholder="BWDEP7K2M9" maxlength="20"
                     style="width: 100%; padding: 10px; border: 1px solid #cbd5e0; border-radius: 4px; font-size: 0.95em;">
              <small style="color: #6b7280;">Unique reference for ZAR bank transfers</small>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label style="display: block; font-weight: 600; margin-bottom: 5px;">BTC Wallet Address:</label>
              <input type="text" id="modal_btc_wallet" value="${currentBtc}" 
                     placeholder="bc1q..." pattern="^(bc1|1|3)[a-zA-HJ-NP-Z0-9]{25,62}$"
                     style="width: 100%; padding: 10px; border: 1px solid #cbd5e0; border-radius: 4px; font-family: monospace; font-size: 0.85em;">
              <small style="color: #6b7280;">Bitcoin deposit address from VALR portal</small>
            </div>
            
            <div style="margin-bottom: 20px;">
              <label style="display: block; font-weight: 600; margin-bottom: 5px;">USDT Wallet Address (TRON Network):</label>
              <input type="text" id="modal_usdt_wallet" value="${currentUsdt}" 
                     placeholder="T..." pattern="^T[a-zA-Z0-9]{33}$"
                     style="width: 100%; padding: 10px; border: 1px solid #cbd5e0; border-radius: 4px; font-family: monospace; font-size: 0.85em;">
              <small style="color: #6b7280;">USDT-TRC20 address from VALR portal (TRON network for low fees)</small>
            </div>
            
            <div style="background: #fee2e2; padding: 12px; border-radius: 4px; margin-bottom: 20px; border-left: 4px solid #ef4444;">
              <strong style="color: #991b1b;">⚠️ Important:</strong> Verify addresses are correct. Incorrect addresses may result in permanent loss of funds.
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
              <button onclick="document.getElementById('walletModal').remove()" 
                      style="padding: 10px 20px; border: 1px solid #cbd5e0; background: white; border-radius: 4px; cursor: pointer;">
                Cancel
              </button>
              <button onclick="window.saveWalletAddresses(${customerId}, '${firstName}', '${lastName}')" 
                      style="padding: 10px 20px; border: none; background: #10b981; color: white; border-radius: 4px; cursor: pointer; font-weight: 600;">
                💾 Save All & Send Email
              </button>
            </div>
          </div>
        </div>
      `;
      document.body.insertAdjacentHTML('beforeend', modalHtml);
    };

    // Global function: Save wallet addresses
    window.saveWalletAddresses = async function(customerId, firstName, lastName) {
      const depositRef = document.getElementById('modal_deposit_ref')?.value?.trim();
      const btcWallet = document.getElementById('modal_btc_wallet')?.value?.trim();
      const usdtWallet = document.getElementById('modal_usdt_wallet')?.value?.trim();

      if (!depositRef || !btcWallet || !usdtWallet) {
        alert('Please enter all three deposit references (ZAR ref, BTC wallet, USDT wallet)');
        return;
      }

      // Basic validation
      if (btcWallet && !btcWallet.match(/^(bc1|1|3)[a-zA-HJ-NP-Z0-9]{25,62}$/)) {
        alert('Invalid BTC wallet address format. Should start with bc1, 1, or 3.');
        return;
      }

      if (usdtWallet && !usdtWallet.match(/^T[a-zA-Z0-9]{33}$/)) {
        alert('Invalid USDT-TRC20 wallet address format. Should start with T and be 34 characters.');
        return;
      }

      const confirmed = confirm(
        `Save deposit references for ${firstName} ${lastName}?\n\n` +
        `ZAR Ref: ${depositRef}\n` +
        `BTC Wallet: ${btcWallet.substring(0, 10)}...${btcWallet.substring(btcWallet.length - 6)}\n` +
        `USDT Wallet: ${usdtWallet.substring(0, 10)}...${usdtWallet.substring(usdtWallet.length - 6)}\n\n` +
        `This will:\n` +
        `• Update exchange_accounts with all references\n` +
        `• Change status to 'deposit'\n` +
        `• Send deposit instructions email with ALL THREE options`
      );

      if (!confirmed) return;

      try {
        // Find customer in current list
        const customer = allSetupCustomers.find(c => c.customer_id === customerId);
        if (!customer || !customer.exchange_account_id) {
          showMessage('Exchange account not found. Create subaccount first.', 'error');
          return;
        }

        // Update exchange_accounts with all wallet addresses
        const { error: updateError } = await supabaseClient
          .from('exchange_accounts')
          .update({ 
            deposit_ref: depositRef,
            btc_wallet_address: btcWallet,
            btc_wallet_created_at: new Date().toISOString(),
            usdt_wallet_address: usdtWallet,
            usdt_deposit_network: 'TRON',
            usdt_wallet_created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .eq('exchange_account_id', customer.exchange_account_id);

        if (updateError) throw updateError;

        // Update customer status to 'deposit'
        const { error: statusError } = await supabaseClient
          .from('customer_details')
          .update({ registration_status: 'deposit' })
          .eq('customer_id', customerId);

        if (statusError) throw statusError;

        // Send deposit instructions email with all three options
        const websiteUrl = SUPABASE_URL.replace('supabase.co', 'supabase.co');
        const emailResponse = await fetch(`${SUPABASE_URL}/functions/v1/ef_send_email`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${supabaseClient.supabaseKey}`
          },
          body: JSON.stringify({
            template_key: 'deposit_instructions',
            to_email: customer.email,
            data: {
              first_name: firstName,
              deposit_ref: depositRef,
              btc_wallet_address: btcWallet,
              usdt_wallet_address: usdtWallet,
              website_url: websiteUrl
            }
          })
        });

        const emailSent = emailResponse.ok;

        showMessage(
          `✓ All deposit references saved. Customer moved to Milestone 5. Email ${emailSent ? 'sent' : 'queued'}.`,
          'success'
        );
        
        // Close modal
        document.getElementById('walletModal')?.remove();
        
        await loadSetupCustomers();
      } catch (err) {
        console.error('Error saving wallet addresses:', err);
        showMessage(`Failed to save: ${err.message}`, 'error');
      }
    };

    // Global function: Resend deposit email
    window.resendDepositEmail = async function(customerId, email) {
      const customer = allSetupCustomers.find(c => c.customer_id === customerId);
      if (!customer || !customer.deposit_ref) {
        showMessage('Customer or deposit ref not found', 'error');
        return;
      }

      try {
        const websiteUrl = SUPABASE_URL.replace('supabase.co', 'supabase.co');
        const response = await fetch(`${SUPABASE_URL}/functions/v1/ef_send_email`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${supabaseClient.supabaseKey}`
          },
          body: JSON.stringify({
            template_key: 'deposit_instructions',
            to_email: email,
            data: {
              first_name: customer.first_names,
              deposit_ref: customer.deposit_ref,
              btc_wallet_address: customer.btc_wallet_address || 'Not yet configured',
              usdt_wallet_address: customer.usdt_wallet_address || 'Not yet configured',
              website_url: websiteUrl
            }
          })
        });

        if (response.ok) {
          showMessage('✓ Email resent successfully', 'success');
        } else {
          showMessage('Failed to resend email', 'error');
        }
      } catch (err) {
        console.error('Error resending email:', err);
        showMessage(`Error: ${err.message}`, 'error');
      }
    };

    // Event listeners
    refreshBtn.addEventListener('click', loadSetupCustomers);
    searchInput.addEventListener('input', renderSetupCustomers);

    // Initial load
    document.addEventListener('DOMContentLoaded', () => {
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user) {
            loadSetupCustomers();
          }
        });
      }
    });
  })();

  /* ========== Active Customers Module (Milestone 6) ========== */
  (() => {
    const tableBody = document.querySelector('#activeTable tbody');
    const refreshBtn = document.getElementById('activeRefreshBtn');
    const searchInput = document.getElementById('activeSearchInput');
    const activeMessage = document.getElementById('activeMessage');

    if (!tableBody || !refreshBtn) return;

    let allActiveCustomers = [];

    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/[&<>"']/g, (ch) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch] || ch));
    }

    function showMessage(msg, type) {
      activeMessage.textContent = msg;
      activeMessage.className = type === 'error' ? 'bg-danger-subtle text-danger' : 'bg-success-subtle text-success';
      activeMessage.style.display = 'block';
      setTimeout(() => { activeMessage.style.display = 'none'; }, 5000);
    }

    async function loadActiveCustomers() {
      if (!supabaseClient) {
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">Supabase not loaded</td></tr>';
        return;
      }

      try {
        // Get all active customers with portfolio info
        const { data: customers, error } = await supabaseClient
          .from('customer_details')
          .select(`
            customer_id,
            first_names,
            last_name,
            email,
            registration_status,
            customer_strategies (
              customer_strategy_id,
              portfolio_id,
              strategy_code,
              status,
              created_at
            )
          `)
          .eq('registration_status', 'active')
          .order('customer_id', { ascending: true });

        if (error) throw error;

        allActiveCustomers = customers || [];
        renderActiveCustomers();
      } catch (err) {
        console.error('Error loading active customers:', err);
        tableBody.innerHTML = `<tr><td colspan="6" class="text-danger">Error: ${escapeHtml(err.message)}</td></tr>`;
      }
    }

    function renderActiveCustomers() {
      const query = searchInput.value.toLowerCase().trim();
      
      let filtered = allActiveCustomers;
      if (query) {
        filtered = allActiveCustomers.filter(c => {
          const fullName = `${c.first_names || ''} ${c.last_name || ''}`.toLowerCase();
          const email = (c.email || '').toLowerCase();
          return fullName.includes(query) || email.includes(query);
        });
      }

      if (filtered.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">No active customers found</td></tr>';
        return;
      }

      const rows = filtered.map(customer => {
        const portfolio = customer.customer_strategies?.[0];
        const strategy = portfolio?.strategy_code || 'N/A';
        const activated = portfolio?.created_at 
          ? new Date(portfolio.created_at).toLocaleDateString()
          : 'N/A';

        return `
          <tr>
            <td>${escapeHtml(customer.customer_id)}</td>
            <td>${escapeHtml(customer.first_names)} ${escapeHtml(customer.last_name)}</td>
            <td>${escapeHtml(customer.email)}</td>
            <td><span class="badge badge-info">${escapeHtml(strategy)}</span></td>
            <td>${escapeHtml(activated)}</td>
            <td>
              <button 
                class="btn btn-sm btn-warning"
                onclick="window.setCustomerInactive(${customer.customer_id}, '${escapeHtml(customer.first_names)}', '${escapeHtml(customer.last_name)}')"
                title="Pause trading for this customer"
              >
                ⏸ Set Inactive
              </button>
            </td>
          </tr>
        `;
      }).join('');

      tableBody.innerHTML = rows;
    }

    // Global function: Set customer inactive
    window.setCustomerInactive = async function(customerId, firstName, lastName) {
      const fullName = `${firstName} ${lastName}`;
      
      if (!confirm(`⚠️ Set ${fullName} to INACTIVE?\n\nThis will:\n• Pause all trading for this customer\n• Exclude customer from daily pipeline\n• Customer can be reactivated later\n\nContinue?`)) {
        return;
      }

      try {
        // Get customer's portfolio ID
        const customer = allActiveCustomers.find(c => c.customer_id === customerId);
        if (!customer || !customer.customer_strategies?.[0]) {
          showMessage('Customer or portfolio not found', 'error');
          return;
        }

        const portfolioId = customer.customer_strategies[0].portfolio_id || customer.customer_strategies[0].customer_strategy_id;

        // Update customer status
        const { error: customerError } = await supabaseClient
          .from('customer_details')
          .update({ 
            registration_status: 'inactive'
          })
          .eq('customer_id', customerId);

        if (customerError) throw customerError;

        // Update strategy (portfolio) status
        const { error: portfolioError } = await supabaseClient
          .schema('public')
          .from('customer_strategies')
          .update({ 
            status: 'inactive'
          })
          .eq('portfolio_id', portfolioId);

        if (portfolioError) throw portfolioError;

        showMessage(`✓ ${fullName} set to inactive. Trading paused.`, 'success');
        
        // Remove from list
        allActiveCustomers = allActiveCustomers.filter(c => c.customer_id !== customerId);
        renderActiveCustomers();

      } catch (err) {
        console.error('Error setting customer inactive:', err);
        showMessage(`Error: ${err.message}`, 'error');
      }
    };

    // Event listeners
    refreshBtn.addEventListener('click', loadActiveCustomers);
    searchInput.addEventListener('input', renderActiveCustomers);

    // Initial load
    document.addEventListener('DOMContentLoaded', () => {
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user) {
            loadActiveCustomers();
          }
        });
      }
    });
  })();

  /* ========== Fee Management Module ========== */
  (() => {
    const tableBody = document.querySelector('#feeTable tbody');
    const refreshBtn = document.getElementById('feeRefreshBtn');
    const searchInput = document.getElementById('feeSearchInput');
    const feeMessage = document.getElementById('feeMessage');

    if (!tableBody || !refreshBtn) return;

    let allCustomers = [];

    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/[&<>"']/g, (ch) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch] || ch));
    }

    function showMessage(msg, type) {
      feeMessage.textContent = msg;
      feeMessage.style.display = 'block';
      feeMessage.style.background = type === 'success' ? '#d4edda' : '#f8d7da';
      feeMessage.style.color = type === 'success' ? '#155724' : '#721c24';
      feeMessage.style.borderLeft = type === 'success' ? '4px solid #28a745' : '4px solid #dc3545';
      
      setTimeout(() => {
        feeMessage.style.display = 'none';
      }, 5000);
    }

    async function loadCustomerFees() {
      if (!supabaseClient) {
        tableBody.innerHTML = '<tr><td colspan="6">Loading Supabase client…</td></tr>';
        return;
      }

      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">Please sign in via Administration tab to manage fees.</td></tr>';
        return;
      }

      tableBody.innerHTML = '<tr><td colspan="6">Loading customers...</td></tr>';

      try {
        // Get all customers with registration_status = setup or active
        const { data: customers, error: custError } = await supabaseClient
          .from('customer_details')
          .select('customer_id, first_names, last_name, email, registration_status')
          .in('registration_status', ['setup', 'active'])
          .order('customer_id', { ascending: true });

        if (custError) throw custError;

        // Get latest fee configs using RPC (to access lth_pvr schema)
        const customerIds = customers.map(c => c.customer_id);
        
        // Use RPC to get fee configs from customer_strategies
        let feeConfigs = null;
        try {
          const { data, error: feeError } = await supabaseClient
            .rpc('get_customer_fee_rates', { p_customer_ids: customerIds });
          
          if (feeError) {
            console.warn('Could not load fee configs:', feeError);
          } else {
            feeConfigs = data;
          }
        } catch (err) {
          console.warn('RPC function get_customer_fee_rates not found or failed, using defaults');
        }

        // Map latest fee rates per customer (both performance and platform)
        const feeMap = new Map();
        (feeConfigs || []).forEach(fc => {
          feeMap.set(fc.customer_id, {
            performance_fee_rate: fc.performance_fee_rate ?? 0.10,
            platform_fee_rate: fc.platform_fee_rate ?? 0.0075
          });
        });

        allCustomers = customers.map(c => {
          const fees = feeMap.get(c.customer_id) || { performance_fee_rate: 0.10, platform_fee_rate: 0.0075 };
          return {
            customer_id: c.customer_id,
            name: `${c.first_names || ''} ${c.last_name || ''}`.trim() || '—',
            email: c.email || '—',
            status: c.registration_status,
            performance_fee_rate: fees.performance_fee_rate,
            platform_fee_rate: fees.platform_fee_rate
          };
        });

        renderCustomers(allCustomers);
      } catch (err) {
        console.error('loadCustomerFees error:', err);
        tableBody.innerHTML = `<tr><td colspan="6" class="error">Failed to load customers: ${escapeHtml(err.message)}</td></tr>`;
      }
    }

    function renderCustomers(customers) {
      if (!customers || customers.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="6" class="muted">No customers found.</td></tr>';
        return;
      }

      const rowsHtml = customers.map(c => {
        const perfPercent = (c.performance_fee_rate * 100).toFixed(2);
        const platPercent = (c.platform_fee_rate * 100).toFixed(3);
        return `
          <tr data-customer-id="${c.customer_id}">
            <td>${escapeHtml(c.customer_id)}</td>
            <td>${escapeHtml(c.name)}</td>
            <td>${escapeHtml(c.email)}</td>
            <td class="performance-fee-cell">
              <span class="fee-display">${perfPercent}%</span>
              <input type="number" class="fee-input" value="${perfPercent}" min="0" max="100" step="0.01" style="display:none;width:80px;padding:4px;">
            </td>
            <td class="platform-fee-cell">
              <span class="fee-display">${platPercent}%</span>
              <input type="number" class="fee-input" value="${platPercent}" min="0" max="10" step="0.001" style="display:none;width:80px;padding:4px;">
            </td>
            <td>
              <button type="button" class="btn btn-secondary-sm js-edit-fee">Edit</button>
              <button type="button" class="btn btn-secondary-sm js-save-fee" style="display:none;">Save</button>
              <button type="button" class="btn btn-secondary-sm js-cancel-fee" style="display:none;">Cancel</button>
            </td>
          </tr>
        `;
      }).join('');

      tableBody.innerHTML = rowsHtml;
    }

    function filterCustomers() {
      const searchTerm = searchInput.value.toLowerCase().trim();
      if (!searchTerm) {
        renderCustomers(allCustomers);
        return;
      }

      const filtered = allCustomers.filter(c => 
        c.name.toLowerCase().includes(searchTerm) ||
        c.email.toLowerCase().includes(searchTerm)
      );
      renderCustomers(filtered);
    }

    async function handleFeeActions(ev) {
      const target = ev.target;
      if (!(target instanceof HTMLElement)) return;

      const tr = target.closest('tr');
      if (!tr) return;

      const customerId = tr.getAttribute('data-customer-id');
      if (!customerId) return;

      const perfCell = tr.querySelector('.performance-fee-cell');
      const platCell = tr.querySelector('.platform-fee-cell');
      const perfDisplay = perfCell.querySelector('.fee-display');
      const perfInput = perfCell.querySelector('.fee-input');
      const platDisplay = platCell.querySelector('.fee-display');
      const platInput = platCell.querySelector('.fee-input');
      const editBtn = tr.querySelector('.js-edit-fee');
      const saveBtn = tr.querySelector('.js-save-fee');
      const cancelBtn = tr.querySelector('.js-cancel-fee');

      // Edit button clicked
      if (target.classList.contains('js-edit-fee')) {
        perfDisplay.style.display = 'none';
        perfInput.style.display = 'inline-block';
        platDisplay.style.display = 'none';
        platInput.style.display = 'inline-block';
        perfInput.focus();
        editBtn.style.display = 'none';
        saveBtn.style.display = 'inline-block';
        cancelBtn.style.display = 'inline-block';
        return;
      }

      // Cancel button clicked
      if (target.classList.contains('js-cancel-fee')) {
        const origPerf = perfDisplay.textContent.replace('%', '');
        const origPlat = platDisplay.textContent.replace('%', '');
        perfInput.value = origPerf;
        platInput.value = origPlat;
        perfDisplay.style.display = 'inline-block';
        perfInput.style.display = 'none';
        platDisplay.style.display = 'inline-block';
        platInput.style.display = 'none';
        editBtn.style.display = 'inline-block';
        saveBtn.style.display = 'none';
        cancelBtn.style.display = 'none';
        return;
      }

      // Save button clicked
      if (target.classList.contains('js-save-fee')) {
        const newPerfPercent = parseFloat(perfInput.value);
        const newPlatPercent = parseFloat(platInput.value);
        
        if (isNaN(newPerfPercent) || newPerfPercent < 0 || newPerfPercent > 100) {
          showMessage('Performance fee rate must be between 0% and 100%', 'error');
          return;
        }
        
        if (isNaN(newPlatPercent) || newPlatPercent < 0 || newPlatPercent > 10) {
          showMessage('Platform fee rate must be between 0% and 10%', 'error');
          return;
        }

        const newPerfRate = newPerfPercent / 100;
        const newPlatRate = newPlatPercent / 100;

        saveBtn.setAttribute('disabled', 'true');
        saveBtn.textContent = 'Saving…';

        try {
          const { data, error } = await supabaseClient.rpc('update_customer_fee_rates', {
            p_customer_id: parseInt(customerId),
            p_performance_fee_rate: newPerfRate,
            p_platform_fee_rate: newPlatRate
          });

          if (error) throw error;

          // Update UI
          perfDisplay.textContent = `${newPerfPercent.toFixed(2)}%`;
          platDisplay.textContent = `${newPlatPercent.toFixed(3)}%`;
          perfDisplay.style.display = 'inline-block';
          perfInput.style.display = 'none';
          platDisplay.style.display = 'inline-block';
          platInput.style.display = 'none';
          editBtn.style.display = 'inline-block';
          saveBtn.style.display = 'none';
          cancelBtn.style.display = 'none';

          // Update in-memory data
          const customer = allCustomers.find(c => c.customer_id == customerId);
          if (customer) {
            customer.performance_fee_rate = newPerfRate;
            customer.platform_fee_rate = newPlatRate;
          }

          showMessage(
            `Fees updated successfully for customer ${customerId}.\n` +
            `Performance: ${(data.previous_performance_fee_rate * 100).toFixed(2)}% → ${(data.new_performance_fee_rate * 100).toFixed(2)}%\n` +
            `Platform: ${(data.previous_platform_fee_rate * 100).toFixed(3)}% → ${(data.new_platform_fee_rate * 100).toFixed(3)}%`,
            'success'
          );
        } catch (err) {
          console.error('update fee error:', err);
          showMessage(`Failed to update fees: ${err.message}`, 'error');
        } finally {
          saveBtn.removeAttribute('disabled');
          saveBtn.textContent = 'Save';
        }
      }
    }

    refreshBtn.addEventListener('click', loadCustomerFees);
    searchInput.addEventListener('input', filterCustomers);
    tableBody.addEventListener('click', handleFeeActions);

    // Load fees when authenticated
    document.addEventListener('DOMContentLoaded', () => {
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user) {
            loadCustomerFees();
          }
        });
      }
    });

    // Expose globally for auth handler
    window.loadCustomerFees = loadCustomerFees;
  })();

  /* ========== Pipeline Control Module ========== */
  (function() {
    const refreshBtn = document.getElementById('pipelineRefreshBtn');
    const resumeBtn = document.getElementById('pipelineResumeBtn');
    const statusText = document.getElementById('pipelineStatusText');
    const tradeDateEl = document.getElementById('pipelineTradeDate');
    const signalDateEl = document.getElementById('pipelineSignalDate');
    const ciStatusEl = document.getElementById('pipelineCIStatus');
    const windowStatusEl = document.getElementById('pipelineWindowStatus');
    const resumeMessageEl = document.getElementById('pipelineResumeMessage');
    const executionLog = document.getElementById('pipelineExecutionLog');
    const logContent = document.getElementById('pipelineLogContent');
    
    const stepIcons = {
      ci_bands: document.getElementById('stepCIBands'),
      decisions: document.getElementById('stepDecisions'),
      intents: document.getElementById('stepIntents'),
      orders: document.getElementById('stepOrders'),
      poll_orders: document.getElementById('stepPollOrders'),
      ledger: document.getElementById('stepLedger')
    };

    function formatDate(dateStr) {
      if (!dateStr) return '—';
      try {
        const d = new Date(dateStr + 'T00:00:00Z');
        if (isNaN(d.getTime())) return '—';
        return d.toLocaleDateString('en-ZA', { year: 'numeric', month: 'short', day: 'numeric' });
      } catch (e) {
        console.warn('Invalid date format:', dateStr);
        return '—';
      }
    }

    function formatTimestamp(ts) {
      if (!ts) return '—';
      const d = new Date(ts);
      return d.toLocaleString('en-ZA', { 
        year: 'numeric', month: 'short', day: 'numeric',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
      });
    }

    function updateStepIcon(step, done) {
      if (stepIcons[step]) {
        stepIcons[step].textContent = done ? '✅' : '⏸️';
      }
    }

    function logMessage(msg, type = 'info') {
      const timestamp = new Date().toLocaleTimeString('en-ZA');
      const prefix = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';
      logContent.textContent += `[${timestamp}] ${prefix} ${msg}\n`;
      executionLog.style.display = 'block';
    }

    function clearLog() {
      logContent.textContent = '';
      executionLog.style.display = 'none';
    }

    async function loadPipelineStatus() {
      if (!supabaseClient) return;

      try {
        refreshBtn.disabled = true;
        statusText.textContent = 'Loading...';

        const { data, error } = await supabaseClient.functions.invoke('ef_resume_pipeline', {
          body: { check_status: true }
        });

        if (error) {
          console.warn('[Pipeline Status] Error:', error);
          statusText.textContent = 'Error loading status';
          refreshBtn.disabled = false;
          return;
        }

        if (!data) {
          console.warn('[Pipeline Status] No data returned');
          statusText.textContent = 'No data';
          refreshBtn.disabled = false;
          return;
        }

        // Update UI with status
        tradeDateEl.textContent = formatDate(data.trade_date);
        signalDateEl.textContent = formatDate(data.signal_date);
        
        ciStatusEl.textContent = data.ci_bands_available ? '✅ Available' : '❌ Not Available';
        ciStatusEl.style.color = data.ci_bands_available ? '#28a745' : '#dc3545';
        
        if (data.window_valid) {
          const closes = new Date(data.window_closes);
          const now = new Date();
          const hoursLeft = Math.max(0, (closes - now) / (1000 * 60 * 60));
          windowStatusEl.textContent = hoursLeft > 0 
            ? `✅ Open (${hoursLeft.toFixed(1)}h left)`
            : '⏰ Closing soon';
          windowStatusEl.style.color = hoursLeft > 0 ? '#28a745' : '#ffc107';
        } else {
          windowStatusEl.textContent = '❌ Expired';
          windowStatusEl.style.color = '#dc3545';
        }

        // Update step icons
        updateStepIcon('ci_bands', data.steps?.ci_bands);
        updateStepIcon('decisions', data.steps?.decisions);
        updateStepIcon('intents', data.steps?.intents);
        updateStepIcon('orders', data.steps?.orders);
        updateStepIcon('poll_orders', data.steps?.poll_orders);
        updateStepIcon('ledger', data.steps?.ledger);

        // Update resume button and message
        resumeBtn.disabled = !data.can_resume;
        resumeMessageEl.textContent = data.resume_reason || '';
        
        if (data.can_resume) {
          statusText.textContent = '⚠️ Pipeline paused - ready to resume';
          statusText.style.color = '#ffc107';
          resumeBtn.classList.add('btn-primary');
        } else if (data.steps?.decisions_generated) {
          statusText.textContent = '✅ Pipeline already executed';
          statusText.style.color = '#28a745';
          resumeBtn.classList.remove('btn-primary');
        } else if (!data.ci_bands_available) {
          statusText.textContent = '⏳ Waiting for CI bands data';
          statusText.style.color = '#6c757d';
          resumeBtn.classList.remove('btn-primary');
        } else if (!data.window_valid) {
          statusText.textContent = '❌ Trade window expired';
          statusText.style.color = '#dc3545';
          resumeBtn.classList.remove('btn-primary');
        } else {
          statusText.textContent = '✅ System ready';
          statusText.style.color = '#28a745';
          resumeBtn.classList.remove('btn-primary');
        }

      } catch (err) {
        console.error('Pipeline status error:', err);
        statusText.textContent = '⚠️ Error loading status';
        statusText.style.color = '#dc3545';
        resumeMessageEl.textContent = err.message || 'Failed to load pipeline status';
      } finally {
        refreshBtn.disabled = false;
      }
    }

    async function resumePipeline() {
      if (!supabaseClient) return;
      if (!confirm('Resume the LTH_PVR pipeline? This will execute all remaining steps in sequence.')) {
        return;
      }

      try {
        resumeBtn.disabled = true;
        resumeBtn.textContent = 'Resuming...';
        statusText.textContent = '🔄 Pipeline running...';
        statusText.style.color = '#007bff';
        clearLog();
        logMessage('Starting pipeline resume...');

        const { data, error } = await supabaseClient.functions.invoke('ef_resume_pipeline', {
          body: {}
        });

        if (error) throw error;

        if (data.success) {
          logMessage('Pipeline completed successfully!', 'success');
          
          // Log each step result
          if (data.results && Array.isArray(data.results)) {
            data.results.forEach(step => {
              if (step.skipped) {
                logMessage(`${step.step}: SKIPPED (${step.reason})`, 'info');
              } else {
                const status = step.success ? 'SUCCESS' : 'FAILED';
                const type = step.success ? 'success' : 'error';
                const response = step.response ? ` - ${step.response}` : '';
                logMessage(`${step.step}: ${status}${response}`, type);
              }
            });
          }

          statusText.textContent = '✅ Pipeline completed';
          statusText.style.color = '#28a745';
          
          // Refresh alerts to show any new issues
          if (typeof window.loadAlerts === 'function') {
            window.loadAlerts();
          }
        } else {
          throw new Error(data.error || data.message || 'Pipeline failed');
        }

      } catch (err) {
        console.error('Pipeline resume error:', err);
        logMessage(`Error: ${err.message}`, 'error');
        statusText.textContent = '❌ Pipeline failed';
        statusText.style.color = '#dc3545';
        alert(`Pipeline failed: ${err.message}`);
      } finally {
        resumeBtn.disabled = false;
        resumeBtn.textContent = 'Resume Pipeline';
        
        // Reload status after execution
        setTimeout(loadPipelineStatus, 2000);
      }
    }

    // Event listeners
    if (refreshBtn) refreshBtn.addEventListener('click', loadPipelineStatus);
    if (resumeBtn) resumeBtn.addEventListener('click', resumePipeline);

    // Expose globally for auth handler
    window.loadPipelineStatus = loadPipelineStatus;

    // Auto-refresh every 30 seconds
    let autoRefreshInterval = null;
    
    function startAutoRefresh() {
      if (autoRefreshInterval) clearInterval(autoRefreshInterval);
      autoRefreshInterval = setInterval(() => {
        // Only refresh if currently on admin module
        if (location.hash === '#admin-module') {
          loadPipelineStatus();
          console.log('Pipeline status auto-refreshed');
        }
      }, 30000); // 30 seconds
    }

    function stopAutoRefresh() {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
    }

    // Load status on authentication (only if on admin module)
    document.addEventListener('DOMContentLoaded', () => {
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user && location.hash === '#admin-module') {
            loadPipelineStatus();
            startAutoRefresh();
          }
        });
      }
    });
    
    // Stop auto-refresh when leaving admin module
    document.querySelectorAll('nav a').forEach(link => {
      link.addEventListener('click', (e) => {
        if (!e.target.href.includes('#admin-module')) {
          stopAutoRefresh();
        }
      });
    });

    // Handle hash changes to start/stop auto-refresh
    window.addEventListener('hashchange', () => {
      if (location.hash === '#admin-module') {
        // Entering admin module - load status and start auto-refresh
        if (supabaseClient) {
          supabaseClient.auth.getSession().then(({ data: { session } }) => {
            if (session?.user) {
              loadPipelineStatus();
              startAutoRefresh();
            }
          });
        }
      } else {
        // Leaving admin module - stop auto-refresh
        stopAutoRefresh();
      }
    });
  })();

  // --- Pending ZAR Conversions (Administration module) ---
  (() => {
    const zarListEl = document.getElementById('zarConversionsList');
    const zarSyncNowBtn = document.getElementById('zarSyncNowBtn');
    const zarRefreshMessage = document.getElementById('zarRefreshMessage');

    if (!zarListEl || !zarSyncNowBtn) return;

    // Helper function to escape HTML
    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    async function loadPendingZarConversions() {
      if (!supabaseClient) {
        zarListEl.innerHTML = '<div style="color:#6c757d;font-size:.9rem;">Loading Supabase client…</div>';
        return;
      }

      const { data: { session } } = await supabaseClient.auth.getSession();
      if (!session?.user) {
        zarListEl.innerHTML = '<div style="color:#6c757d;font-size:.9rem;">Please sign in to view pending conversions.</div>';
        return;
      }

      try {
        zarRefreshMessage.textContent = 'Loading...';
        zarRefreshMessage.style.color = '#6c757d';

        const { data, error } = await supabaseClient
          .schema('lth_pvr')
          .from('v_pending_zar_conversions')
          .select('*')
          .order('occurred_at', { ascending: true });

        if (error) {
          console.error('Error loading pending ZAR conversions:', error);
          zarListEl.innerHTML = `<div style="color:#dc3545;font-size:.9rem;">Error: ${error.message}</div>`;
          zarRefreshMessage.textContent = 'Error loading conversions';
          zarRefreshMessage.style.color = '#dc3545';
          return;
        }

        if (!data || data.length === 0) {
          zarListEl.innerHTML = '<div style="color:#6c757d;font-size:.9rem;">✅ No pending conversions</div>';
          zarRefreshMessage.textContent = 'All conversions complete';
          zarRefreshMessage.style.color = '#28a745';
          return;
        }

        // Render pending conversions
        zarListEl.innerHTML = data.map(conv => {
          const hoursAgo = Math.floor(conv.hours_pending);
          const timeColor = hoursAgo > 24 ? '#dc3545' : hoursAgo > 4 ? '#ffc107' : '#28a745';
          
          return `
            <div style="background:#f8f9fa;border:1px solid #e9ecef;border-radius:8px;padding:.75rem;display:flex;align-items:center;justify-content:space-between;gap:1rem;">
              <div style="flex:1;min-width:0;">
                <div style="font-weight:500;margin-bottom:.25rem;">
                  ${escapeHtml(conv.first_names)} ${escapeHtml(conv.last_name)}
                  ${conv.conversion_status === 'partial' ? '<span style="background:#ffc107;color:#000;font-size:.7rem;padding:.1rem .3rem;border-radius:3px;margin-left:.5rem;">PARTIAL</span>' : ''}
                </div>
                <div style="font-size:.85rem;color:#4b5563;margin-bottom:.25rem;">
                  <strong>Deposited:</strong> R${Number(conv.original_zar_amount).toFixed(2)}
                  <span style="margin:0 .5rem;">•</span>
                  <strong>Remaining:</strong> <span style="color:#059669;font-weight:600;">R${Number(conv.remaining_amount).toFixed(2)}</span>
                </div>
                <div style="font-size:.8rem;color:#6c757d;">
                  <span style="color:${timeColor};font-weight:500;">${hoursAgo}h ago</span>
                  · ${new Date(conv.occurred_at).toLocaleString()}
                  · Balance: ${Number(conv.current_usdt_balance).toFixed(2)} USDT
                </div>
              </div>
            </div>
          `;
        }).join('');

        zarRefreshMessage.textContent = `${data.length} pending conversion${data.length === 1 ? '' : 's'}`;
        zarRefreshMessage.style.color = '#6c757d';

      } catch (err) {
        console.error('Error in loadPendingZarConversions:', err);
        zarListEl.innerHTML = `<div style="color:#dc3545;font-size:.9rem;">Unexpected error</div>`;
        zarRefreshMessage.textContent = 'Error';
        zarRefreshMessage.style.color = '#dc3545';
      }
    }

    // Sync Now button - triggers immediate transaction sync
    async function syncNowAndRefresh() {
      try {
        zarRefreshMessage.textContent = 'Syncing transactions...';
        zarRefreshMessage.style.color = '#6c757d';

        // Trigger transaction sync to capture conversions
        const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';
        const syncResponse = await fetch(`${SUPABASE_URL}/functions/v1/ef_sync_valr_transactions`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${window.SUPABASE_ANON_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({})
        });

        if (!syncResponse.ok) {
          throw new Error(`Sync failed: ${syncResponse.statusText}`);
        }

        const syncResult = await syncResponse.json();
        console.log('Transaction sync result:', syncResult);

        zarRefreshMessage.textContent = 'Synced! Refreshing...';
        zarRefreshMessage.style.color = '#28a745';

        // Wait for database triggers to process
        setTimeout(() => {
          loadPendingZarConversions();
        }, 2000);

      } catch (err) {
        console.error('Error syncing transactions:', err);
        zarRefreshMessage.textContent = `Error: ${err.message}`;
        zarRefreshMessage.style.color = '#dc3545';
      }
    }

    // Sync Now button
    zarSyncNowBtn.addEventListener('click', syncNowAndRefresh);

    // Expose for external calls
    window.loadPendingZarConversions = loadPendingZarConversions;

    // Load on authentication
    document.addEventListener('DOMContentLoaded', () => {
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user) {
            loadPendingZarConversions();
          }
        });
      }
    });

    // Auto-refresh every 5 minutes
    setInterval(() => {
      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data: { session } }) => {
          if (session?.user) {
            loadPendingZarConversions();
          }
        });
      }
    }, 5 * 60 * 1000);
  })();

  // =================== Strategy Maintenance Module ===================
  (function() {
    const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';
    const SUPABASE_PUBLISHABLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indxbm14cG9vYWJtZWR2dGFja2ppIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzM0OTc2NzMsImV4cCI6MjA0OTA3MzY3M30.t7YhiLG9j1F1rkipICLbGRFAC3Tl44TqsN3jtv8zOvA';

    // State
    let currentVariations = [];
    let currentVariationId = null;
    let currentSimulationResult = null; // Store current simulation for CSV export

    // DOM elements
    const variationCardsContainer = document.getElementById('variationCardsContainer');
    const simulationControls = document.getElementById('simulationControls');
    const simulationResultsPanel = document.getElementById('simulationResultsPanel');
    const optimizationControls = document.getElementById('optimizationControls');
    const optimizationResultsPanel = document.getElementById('optimizationResultsPanel');

    // Note: Strategy panels are now controlled by data-strategy attributes and the global
    // currentStrategyCode variable (set via context bar), just like Customer Transactions.

    // Load LTH PVR variations from database
    async function loadLthPvrVariations() {
      try {
        console.log('📊 loadLthPvrVariations() called');
        variationCardsContainer.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:2rem;color:var(--muted);">Loading variations...</div>';

        // Get org_id from context bar
        const orgSelect = document.getElementById('orgSelect');
        const orgId = orgSelect?.value;
        console.log('Org ID from selector:', orgId);

        // Check if org_id is valid (not empty, not "Loading...", looks like UUID)
        if (!orgId || orgId === 'Loading...' || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(orgId)) {
          console.log('⚠️ Invalid org_id:', orgId);
          variationCardsContainer.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:2rem;color:#ef4444;">Please select an organization first</div>';
          return;
        }

        const { data, error } = await supabaseClient
          .schema('lth_pvr')
          .from('strategy_variation_templates')
          .select('*')
          .eq('org_id', orgId)
          .eq('is_active', true)
          .order('sort_order');

        console.log('Supabase query result:', { data, error, orgId });

        if (error) {
          console.error('Error loading variations:', error);
          variationCardsContainer.innerHTML = `<div style="grid-column:1/-1;text-align:center;padding:2rem;color:#ef4444;">Error: ${error.message}</div>`;
          return;
        }

        if (!data || data.length === 0) {
          console.log('No variations found for org:', orgId);
          variationCardsContainer.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:2rem;color:var(--muted);">No variations found</div>';
          return;
        }

        console.log('✅ Loaded', data.length, 'variations');
        currentVariations = data;
        renderVariationCards(data);

      } catch (err) {
        console.error('Error in loadLthPvrVariations:', err);
        variationCardsContainer.innerHTML = `<div style="grid-column:1/-1;text-align:center;padding:2rem;color:#ef4444;">Unexpected error: ${err.message}</div>`;
      }
    }

    // Render variation cards
    function renderVariationCards(variations) {
      variationCardsContainer.innerHTML = variations.map(v => {
        const config = v.strategy_config || {};
        const B = config.B || {};
        
        return `
          <div class="variation-card" data-variation-id="${v.id}" style="background:#f8f9fa;border:1px solid var(--border);border-radius:12px;padding:1.5rem;position:relative;">
            <div class="card-header" style="display:flex;justify-content:space-between;align-items:start;margin-bottom:1rem;">
              <h4 style="margin:0;text-transform:capitalize;">${escapeHtml(v.variation_name)}</h4>
              ${v.is_production ? '<span class="badge-production" style="background:#10b981;color:#fff;padding:2px 8px;font-size:11px;border-radius:999px;">PRODUCTION</span>' : ''}
            </div>
            <div class="card-body">
              <p style="color:var(--muted);font-size:.9rem;margin-bottom:1rem;">${v.description || 'No description'}</p>
              <div class="metrics-grid" style="display:grid;grid-template-columns:repeat(2,1fr);gap:.5rem;margin-bottom:1rem;font-size:.85rem;">
                <div>
                  <span style="color:var(--muted);">Bear Pause Entry:</span>
                  <strong style="float:right;">${v.bear_pause_enter_sigma > 0 ? '+' : ''}${v.bear_pause_enter_sigma?.toFixed(1) || 'N/A'}σ</strong>
                </div>
                <div>
                  <span style="color:var(--muted);">Bear Pause Exit:</span>
                  <strong style="float:right;">${v.bear_pause_exit_sigma > 0 ? '+' : ''}${v.bear_pause_exit_sigma?.toFixed(1) || 'N/A'}σ</strong>
                </div>
                <div>
                  <span style="color:var(--muted);">B1 (Buy Tier 1):</span>
                  <strong style="float:right;">${((B.B1 || 0) * 100).toFixed(2)}%</strong>
                </div>
                <div>
                  <span style="color:var(--muted);">B6 (Sell Tier 1):</span>
                  <strong style="float:right;">${((B.B6 || 0) * 100).toFixed(3)}%</strong>
                </div>
              </div>
              <div style="display:flex;gap:.5rem;flex-wrap:wrap;">
                <button onclick="window.strategyMaintenance.viewVariationDetails('${v.id}')" type="button" style="flex:1;padding:.5rem;background:#fff;border:1px solid var(--border);border-radius:6px;cursor:pointer;font:inherit;font-size:.85rem;">View Details</button>
                <button onclick="window.strategyMaintenance.loadParameterHistory('${v.id}', '${escapeHtml(v.variation_name)}')" type="button" style="flex:1;padding:.5rem;background:#fff;border:1px solid var(--border);border-radius:6px;cursor:pointer;font:inherit;font-size:.85rem;">📅 History</button>
                <button onclick="window.strategyMaintenance.showSimulationControls('${v.id}')" type="button" style="flex:1;padding:.5rem;background:#3b82f6;color:#fff;border:none;border-radius:6px;cursor:pointer;font:inherit;font-size:.85rem;">Run Simulation</button>
                <button onclick="window.strategyMaintenance.optimizeVariation('${v.id}')" type="button" style="flex:1;padding:.5rem;background:#10b981;color:#fff;border:none;border-radius:6px;cursor:pointer;font:inherit;font-size:.85rem;">Optimize</button>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // View variation details
    function viewVariationDetails(variationId) {
      const variation = currentVariations.find(v => v.id === variationId);
      if (!variation) return;

      const config = variation.strategy_config || {};
      const B = config.B || {};

      alert(`Variation: ${variation.variation_name}

Description: ${variation.description}

Bear Pause Configuration:
  Entry Sigma: ${variation.bear_pause_enter_sigma}
  Exit Sigma: ${variation.bear_pause_exit_sigma}

Buy Tiers (B1-B5):
  B1: ${((B.B1 || 0) * 100).toFixed(2)}%
  B2: ${((B.B2 || 0) * 100).toFixed(2)}%
  B3: ${((B.B3 || 0) * 100).toFixed(2)}%
  B4: ${((B.B4 || 0) * 100).toFixed(2)}%
  B5: ${((B.B5 || 0) * 100).toFixed(2)}%

Sell Tiers (B6-B11):
  B6: ${((B.B6 || 0) * 100).toFixed(3)}%
  B7: ${((B.B7 || 0) * 100).toFixed(3)}%
  B8: ${((B.B8 || 0) * 100).toFixed(3)}%
  B9: ${((B.B9 || 0) * 100).toFixed(3)}%
  B10: ${((B.B10 || 0) * 100).toFixed(3)}%
  B11: ${((B.B11 || 0) * 100).toFixed(3)}%

Momentum:
  Length: ${config.momentum?.length || 'N/A'}
  Threshold: ${config.momentum?.threshold || 'N/A'}`);
    }

    // Show simulation controls
    function showSimulationControls(variationId) {
      currentVariationId = variationId;
      const variation = currentVariations.find(v => v.id === variationId);
      
      if (!variation) return;

      // Set default dates (last 5 years)
      const endDate = new Date();
      const startDate = new Date();
      startDate.setFullYear(endDate.getFullYear() - 5);
      
      document.getElementById('simStartDate').value = startDate.toISOString().split('T')[0];
      document.getElementById('simEndDate').value = endDate.toISOString().split('T')[0];

      // Show simulation controls
      simulationControls.style.display = 'block';
      simulationResultsPanel.style.display = 'none';

      // Scroll to controls
      simulationControls.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Run simulation
    async function runSimulation() {
      if (!currentVariationId) return;

      try {
        const startDate = document.getElementById('simStartDate').value;
        const endDate = document.getElementById('simEndDate').value;
        const upfront = parseFloat(document.getElementById('simUpfront').value);
        const monthly = parseFloat(document.getElementById('simMonthly').value);

        if (!startDate || !endDate || isNaN(upfront) || isNaN(monthly)) {
          alert('Please fill in all simulation parameters');
          return;
        }

        // Show loading
        simulationResultsPanel.style.display = 'block';
        simulationResultsPanel.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--muted);">Running simulation...</div>';
        simulationResultsPanel.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // Call simulator edge function
        const response = await fetch(`${SUPABASE_URL}/functions/v1/ef_run_lth_pvr_simulator`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            start_date: startDate,
            end_date: endDate,
            upfront_usd: upfront,
            monthly_usd: monthly,
            variation_ids: [currentVariationId]
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Simulation failed: ${errorText}`);
        }

        const data = await response.json();
        
        console.log('Simulation response:', data);
        
        // Check for success and results array
        if (!data.success || !data.results || !Array.isArray(data.results)) {
          throw new Error('Invalid response format from simulator');
        }
        
        // Find result for current variation
        const result = data.results.find(r => r.variation_id === currentVariationId);
        
        if (!result) {
          throw new Error(`No simulation result found for variation ${currentVariationId}`);
        }
        
        // Store result for CSV export
        currentSimulationResult = result;
        
        // Display results
        displaySimulationResults(result);

      } catch (err) {
        console.error('Error running simulation:', err);
        simulationResultsPanel.innerHTML = `<div style="text-align:center;padding:2rem;color:#ef4444;">Error: ${err.message}</div>`;
      }
    }

    // Display simulation results
    function displaySimulationResults(result) {
      const variation = currentVariations.find(v => v.id === currentVariationId);
      if (!variation || !result) {
        simulationResultsPanel.innerHTML = '<div style="text-align:center;padding:2rem;color:#ef4444;">No results found</div>';
        return;
      }
      
      simulationResultsPanel.innerHTML = `
        <h3>Simulation Results: ${escapeHtml(variation.variation_name)}</h3>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-bottom:1.5rem;">
          <div style="background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
            <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Final NAV</div>
            <div style="font-size:1.75rem;font-weight:600;color:var(--ink);">$${result.final_nav_usd?.toLocaleString() || '0'}</div>
          </div>
          <div style="background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
            <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Total ROI</div>
            <div style="font-size:1.75rem;font-weight:600;color:#10b981;">${result.final_roi_percent?.toFixed(2) || '0'}%</div>
          </div>
          <div style="background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
            <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">CAGR</div>
            <div style="font-size:1.75rem;font-weight:600;color:#3b82f6;">${result.final_cagr_percent?.toFixed(2) || '0'}%</div>
          </div>
          <div style="background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
            <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Sharpe Ratio</div>
            <div style="font-size:1.75rem;font-weight:600;color:var(--ink);">${result.sharpe_ratio?.toFixed(2) || '0'}</div>
          </div>
        </div>
        <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:.75rem;font-size:.9rem;margin-bottom:1.5rem;">
          <div><span style="color:var(--muted);">Max Drawdown:</span> <strong>${result.max_drawdown_percent?.toFixed(2) || '0'}%</strong></div>
          <div><span style="color:var(--muted);">Total Invested:</span> <strong>$${result.total_contrib_net_usdt?.toLocaleString() || '0'}</strong></div>
          <div><span style="color:var(--muted);">Final BTC:</span> <strong>${result.final_btc_balance?.toFixed(8) || '0'} BTC</strong></div>
          <div><span style="color:var(--muted);">Cash Drag:</span> <strong>${result.cash_drag_percent?.toFixed(2) || '0'}%</strong></div>
        </div>
        <div style="background:#fff;border:1px solid var(--border);border-radius:8px;padding:1rem;margin-bottom:1.5rem;">
          <h4 style="margin:0 0 1rem;">NAV Over Time</h4>
          <canvas id="simResultsChart" style="max-height:400px;"></canvas>
        </div>
        <div style="display:flex;gap:.75rem;justify-content:center;">
          <button onclick="window.strategyMaintenance.exportSimulationToCSV()" type="button" style="padding:.75rem 1.5rem;background:#10b981;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;">📄 Export to CSV</button>
          <button onclick="window.strategyMaintenance.hideSimulationResults()" type="button" style="padding:.75rem 1.5rem;background:#6b7280;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;">Close</button>
        </div>
      `;

      // Render Chart.js chart with NAV over time
      renderSimulationChart(result.daily || []);
    }

    // Render simulation chart
    function renderSimulationChart(dailyResults) {
      const canvas = document.getElementById('simResultsChart');
      if (!canvas || !dailyResults || dailyResults.length === 0) return;

      const ctx = canvas.getContext('2d');
      
      // Destroy existing chart if any
      if (window.simResultsChartInstance) {
        window.simResultsChartInstance.destroy();
      }

      // Prepare data
      const labels = dailyResults.map(d => d.trade_date || d.close_date);
      const navData = dailyResults.map(d => d.nav_usd);
      const investedData = dailyResults.map(d => d.contrib_net_usdt_cum);

      // Create chart
      window.simResultsChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'NAV',
              data: navData,
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.1
            },
            {
              label: 'Total Invested',
              data: investedData,
              borderColor: '#6b7280',
              backgroundColor: 'rgba(107, 116, 128, 0.1)',
              borderWidth: 1,
              borderDash: [5, 5],
              pointRadius: 0,
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  if (context.parsed.y !== null) {
                    label += '$' + context.parsed.y.toLocaleString(undefined, {
                      minimumFractionDigits: 2,
                      maximumFractionDigits: 2
                    });
                  }
                  return label;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'category',
              ticks: {
                maxTicksLimit: 12,
                autoSkip: true
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return '$' + value.toLocaleString();
                }
              }
            }
          }
        }
      });
    }

    // Hide simulation results
    function hideSimulationResults() {
      simulationControls.style.display = 'none';
      simulationResultsPanel.style.display = 'none';
      currentVariationId = null;
    }

    // Export simulation results to CSV
    function exportSimulationToCSV() {
      try {
        if (!currentSimulationResult || !currentVariationId) {
          alert('No simulation results available to export');
          return;
        }

        const variation = currentVariations.find(v => v.id === currentVariationId);
        if (!variation) {
          alert('Variation not found');
          return;
        }

        const result = currentSimulationResult;
        if (!result || !result.daily || result.daily.length === 0) {
          alert('No daily results available to export');
          return;
        }

        // Create CSV header
        const header = [
          'date', 'btc_balance', 'usdt_balance', 'nav', 'btc_price',
          'action', 'amount_pct', 'rule', 'tier',
          'platform_fee', 'performance_fee', 'exchange_fee',
          'cumulative_contrib', 'cumulative_fees', 'roi'
        ].join(',');

        // Create CSV rows from daily results
        const rows = result.daily.map(day => {
          // Calculate cumulative fees
          const cumulativeFees = (day.platform_fees_paid_usdt || 0) + 
                                  (day.performance_fees_paid_usdt || 0) + 
                                  (day.exchange_fees_paid_usdt || 0);
          
          return [
            day.trade_date || '',
            (day.btc_balance !== undefined ? day.btc_balance.toFixed(8) : ''),
            (day.usdt_balance !== undefined ? day.usdt_balance.toFixed(2) : ''),
            (day.nav_usd !== undefined ? day.nav_usd.toFixed(2) : ''),
            (day.price_usd !== undefined ? day.price_usd.toFixed(2) : ''),
            day.action || '',
            (day.amount_pct !== undefined ? day.amount_pct : ''),
            day.rule || '',
            day.band_bucket || '',
            (day.platform_fees_paid_usdt !== undefined ? day.platform_fees_paid_usdt.toFixed(2) : '0'),
            (day.performance_fees_paid_usdt !== undefined ? day.performance_fees_paid_usdt.toFixed(2) : '0'),
            (day.exchange_fees_paid_usdt !== undefined ? day.exchange_fees_paid_usdt.toFixed(2) : '0'),
            (day.contrib_net_usdt_cum !== undefined ? day.contrib_net_usdt_cum.toFixed(2) : ''),
            cumulativeFees.toFixed(2),
            (day.total_roi_percent !== undefined ? day.total_roi_percent.toFixed(4) : '')
          ].join(',');
        });

        // Combine header + rows
        const csv = [header, ...rows].join('\\n');

        // Create download
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        
        // Sanitize variation name for filename
        const sanitizedName = variation.variation_name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const dateStr = new Date().toISOString().split('T')[0];
        link.download = `lth_pvr_simulation_${sanitizedName}_${dateStr}.csv`;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        console.log('✅ CSV exported:', link.download);

      } catch (err) {
        console.error('Error exporting CSV:', err);
        alert(`Error exporting CSV: ${err.message}`);
      }
    }

    // Optimize variation - show optimization modal
    function optimizeVariation(variationId) {
      currentVariationId = variationId;
      const variation = currentVariations.find(v => v.id === variationId);
      
      if (!variation) return;

      // Populate modal
      document.getElementById('optVariationId').value = variationId;
      document.getElementById('optVariationName').value = variation.variation_name;

      // Set default dates (last 5 years)
      const endDate = new Date();
      const startDate = new Date();
      startDate.setFullYear(endDate.getFullYear() - 5);
      
      document.getElementById('optStartDate').value = startDate.toISOString().split('T')[0];
      document.getElementById('optEndDate').value = endDate.toISOString().split('T')[0];

      // Get current config
      const config = variation.strategy_config || {};
      const B = config.B || {};

      // Populate smart ranges (±20% from current values)
      if (document.getElementById('optUseSmartRanges').checked) {
        const b1Range = generateSmartRange(B.B1 || 0.22, 0.2, 3);
        const b2Range = generateSmartRange(B.B2 || 0.21, 0.2, 3);
        
        document.getElementById('optB1Range').value = b1Range;
        document.getElementById('optB2Range').value = b2Range;
      }

      // Show modal
      document.getElementById('optimizationModal').style.display = 'block';
      optimizationResultsPanel.style.display = 'none';

      // Scroll to modal
      document.getElementById('optimizationModal').scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Generate smart range string (min, max, step)
    function generateSmartRange(currentValue, variancePercent, gridSize) {
      const variance = currentValue * variancePercent;
      const min = currentValue - variance;
      const max = currentValue + variance;
      const step = (max - min) / (gridSize - 1);
      
      return `${min.toFixed(4)}, ${max.toFixed(4)}, ${step.toFixed(4)}`;
    }

    // Parse range string to object
    function parseRange(rangeStr) {
      if (!rangeStr || rangeStr.trim() === '') return null;
      
      const parts = rangeStr.split(',').map(s => parseFloat(s.trim()));
      if (parts.length !== 3 || parts.some(isNaN)) return null;
      
      return {
        min: parts[0],
        max: parts[1],
        step: parts[2]
      };
    }

    // Close optimization modal
    function closeOptimizationModal() {
      document.getElementById('optimizationModal').style.display = 'none';
      currentVariationId = null;
    }

    // Run optimization
    async function runOptimization() {
      if (!currentVariationId) return;

      try {
        const variationId = document.getElementById('optVariationId').value;
        const objective = document.getElementById('optObjective').value;
        const startDate = document.getElementById('optStartDate').value;
        const endDate = document.getElementById('optEndDate').value;
        const upfront = parseFloat(document.getElementById('optUpfront').value);
        const monthly = parseFloat(document.getElementById('optMonthly').value);

        if (!startDate || !endDate || isNaN(upfront) || isNaN(monthly)) {
          alert('Please fill in all optimization parameters');
          return;
        }

        // Parse parameter ranges
        const b1Range = parseRange(document.getElementById('optB1Range').value);
        const b2Range = parseRange(document.getElementById('optB2Range').value);

        if (!b1Range && !b2Range) {
          alert('Please specify at least one parameter range to optimize');
          return;
        }

        // Show loading
        optimizationResultsPanel.style.display = 'block';
        optimizationResultsPanel.innerHTML = `
          <div style="text-align:center;padding:3rem;color:var(--muted);">
            <div style="font-size:1.2rem;margin-bottom:1rem;">🔍 Optimizing parameters...</div>
            <div style="font-size:.9rem;">This may take 1-5 minutes depending on the date range and number of parameter combinations.</div>
            <div style="margin-top:1rem;font-size:.85rem;color:#6b7280;">
              Estimated combinations: ${estimateCombinations(b1Range, b2Range)}
            </div>
          </div>
        `;
        optimizationResultsPanel.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // Build request body
        const requestBody = {
          variation_id: variationId,
          start_date: startDate,
          end_date: endDate,
          upfront_usd: upfront,
          monthly_usd: monthly,
          objective: objective
        };

        // Add ranges if specified
        if (b1Range || b2Range) {
          requestBody.b_ranges = {};
          if (b1Range) requestBody.b_ranges.b1 = b1Range;
          if (b2Range) requestBody.b_ranges.b2 = b2Range;
        }

        // Call optimizer edge function
        const response = await fetch(`${SUPABASE_URL}/functions/v1/ef_optimize_lth_pvr_strategy`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Optimization failed: ${errorText}`);
        }

        const results = await response.json();
        
        // Hide modal and display results
        document.getElementById('optimizationModal').style.display = 'none';
        displayOptimizationResults(results);

      } catch (err) {
        console.error('Error running optimization:', err);
        optimizationResultsPanel.innerHTML = `<div style="text-align:center;padding:2rem;color:#ef4444;">Error: ${err.message}</div>`;
      }
    }

    // Estimate number of combinations
    function estimateCombinations(b1Range, b2Range) {
      let count = 1;
      
      if (b1Range) {
        const steps = Math.ceil((b1Range.max - b1Range.min) / b1Range.step) + 1;
        count *= steps;
      }
      
      if (b2Range) {
        const steps = Math.ceil((b2Range.max - b2Range.min) / b2Range.step) + 1;
        count *= steps;
      }
      
      return count;
    }

    // Display optimization results
    function displayOptimizationResults(results) {
      const variation = currentVariations.find(v => v.id === currentVariationId);
      if (!variation) {
        optimizationResultsPanel.innerHTML = '<div style="text-align:center;padding:2rem;color:#ef4444;">Variation not found</div>';
        return;
      }

      const best = results.best;
      const topResults = results.top_results || [];
      
      optimizationResultsPanel.innerHTML = `
        <h3>Optimization Results: ${escapeHtml(variation.variation_name)}</h3>
        
        <!-- Summary Stats -->
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:1rem;margin-bottom:1.5rem;background:#f8f9fa;padding:1rem;border-radius:8px;border:1px solid var(--border);">
          <div>
            <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Combinations Tested</div>
            <div style="font-size:1.5rem;font-weight:600;color:var(--ink);">${results.combinations_tested || 0}</div>
          </div>
          <div>
            <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Combinations Skipped</div>
            <div style="font-size:1.5rem;font-weight:600;color:#6b7280;">${results.combinations_skipped || 0}</div>
          </div>
          <div>
            <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Execution Time</div>
            <div style="font-size:1.5rem;font-weight:600;color:var(--ink);">${results.execution_time_seconds?.toFixed(2) || '0'}s</div>
          </div>
          <div>
            <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Objective</div>
            <div style="font-size:1.5rem;font-weight:600;color:#10b981;text-transform:uppercase;">${results.objective || 'N/A'}</div>
          </div>
        </div>

        <!-- Best Configuration -->
        <div style="background:#f0fdf4;border:2px solid #10b981;border-radius:12px;padding:1.5rem;margin-bottom:1.5rem;">
          <h4 style="margin:0 0 1rem;color:#065f46;">🏆 Best Configuration (Rank #${best?.rank || 1})</h4>
          
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-bottom:1rem;">
            <div style="background:#fff;padding:1rem;border-radius:8px;">
              <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Final NAV</div>
              <div style="font-size:1.75rem;font-weight:600;color:var(--ink);">$${best?.simulation?.final_nav_usd?.toLocaleString() || '0'}</div>
            </div>
            <div style="background:#fff;padding:1rem;border-radius:8px;">
              <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">CAGR</div>
              <div style="font-size:1.75rem;font-weight:600;color:#3b82f6;">${best?.simulation?.final_cagr_percent?.toFixed(2) || '0'}%</div>
            </div>
            <div style="background:#fff;padding:1rem;border-radius:8px;">
              <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">ROI</div>
              <div style="font-size:1.75rem;font-weight:600;color:#10b981;">${best?.simulation?.final_roi_percent?.toFixed(2) || '0'}%</div>
            </div>
            <div style="background:#fff;padding:1rem;border-radius:8px;">
              <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted);margin-bottom:.25rem;">Sharpe Ratio</div>
              <div style="font-size:1.75rem;font-weight:600;color:var(--ink);">${best?.simulation?.sharpe_ratio?.toFixed(2) || '0'}</div>
            </div>
          </div>

          <div style="background:#fff;padding:1rem;border-radius:8px;margin-bottom:1rem;">
            <strong style="display:block;margin-bottom:.5rem;">Optimized Parameters:</strong>
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:.5rem;font-size:.9rem;">
              ${Object.entries(best?.config?.B || {}).slice(0, 11).map(([key, val]) => `
                <div><span style="color:var(--muted);">${key}:</span> <strong>${(val * 100).toFixed(3)}%</strong></div>
              `).join('')}
            </div>
          </div>

          <button onclick="window.strategyMaintenance.applyOptimizedConfig('${best?.config ? JSON.stringify(best.config).replace(/'/g, "\\'") : ''}')" type="button" style="padding:.75rem 1.5rem;background:#10b981;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;font-weight:600;">Apply This Configuration</button>
        </div>

        <!-- Top Results Table -->
        <div style="background:#fff;border:1px solid var(--border);border-radius:8px;padding:1rem;margin-bottom:1.5rem;">
          <h4 style="margin:0 0 1rem;">Top ${topResults.length} Configurations</h4>
          <div style="overflow-x:auto;">
            <table style="width:100%;border-collapse:collapse;font-size:.9rem;">
              <thead>
                <tr style="background:#f8f9fa;border-bottom:2px solid var(--border);">
                  <th style="padding:.5rem;text-align:left;">Rank</th>
                  <th style="padding:.5rem;text-align:right;">B1</th>
                  <th style="padding:.5rem;text-align:right;">B2</th>
                  <th style="padding:.5rem;text-align:right;">NAV</th>
                  <th style="padding:.5rem;text-align:right;">CAGR</th>
                  <th style="padding:.5rem;text-align:right;">ROI</th>
                  <th style="padding:.5rem;text-align:right;">Sharpe</th>
                </tr>
              </thead>
              <tbody>
                ${topResults.map(r => `
                  <tr style="border-bottom:1px solid var(--border);">
                    <td style="padding:.5rem;">#${r.rank}</td>
                    <td style="padding:.5rem;text-align:right;">${((r.config?.B?.B1 || 0) * 100).toFixed(2)}%</td>
                    <td style="padding:.5rem;text-align:right;">${((r.config?.B?.B2 || 0) * 100).toFixed(2)}%</td>
                    <td style="padding:.5rem;text-align:right;">$${r.simulation?.final_nav_usd?.toLocaleString() || '0'}</td>
                    <td style="padding:.5rem;text-align:right;">${r.simulation?.final_cagr_percent?.toFixed(2) || '0'}%</td>
                    <td style="padding:.5rem;text-align:right;">${r.simulation?.final_roi_percent?.toFixed(2) || '0'}%</td>
                    <td style="padding:.5rem;text-align:right;">${r.simulation?.sharpe_ratio?.toFixed(2) || '0'}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        </div>

        <!-- Actions -->
        <div style="display:flex;gap:.75rem;justify-content:center;">
          <button onclick="window.strategyMaintenance.closeOptimizationResults()" type="button" style="padding:.75rem 1.5rem;background:#6b7280;color:#fff;border:none;border-radius:var(--control-radius);cursor:pointer;font:inherit;">Close</button>
        </div>
      `;
    }

    // Apply optimized configuration
    async function applyOptimizedConfig(configJson) {
      try {
        // Parse config if it's a string
        let config;
        try {
          config = typeof configJson === 'string' ? JSON.parse(configJson) : configJson;
        } catch (e) {
          alert('Error parsing configuration data. Please try again.');
          return;
        }

        // Get the current variation
        const variation = currentVariations.find(v => v.id === currentVariationId);
        if (!variation) {
          alert('Error: Variation not found. Please reload the page and try again.');
          return;
        }

        // Confirmation dialog
        const confirmed = confirm(
          `Are you sure you want to apply these optimized parameters to the "${variation.variation_name}" variation?\n\n` +
          `This will update the variation template and affect ALL customers using this variation.\n\n` +
          `Changes take effect at the next trading cycle (03:00 UTC).`
        );

        if (!confirmed) return;

        // Show loading state
        const applyBtn = event?.target;
        const originalText = applyBtn?.textContent;
        if (applyBtn) {
          applyBtn.disabled = true;
          applyBtn.textContent = 'Applying...';
        }

        // Get org_id from context bar
        const orgSelect = document.getElementById('orgSelect');
        const orgId = orgSelect?.value;

        if (!orgId) {
          alert('Error: Organization not selected');
          if (applyBtn) {
            applyBtn.disabled = false;
            applyBtn.textContent = originalText;
          }
          return;
        }

        // Build update object with all B1-B11 parameters
        const updateData = {
          bear_pause_enter_sigma: Number(config.bearPauseEnterSigma ?? variation.bear_pause_enter_sigma),
          bear_pause_exit_sigma: Number(config.bearPauseExitSigma ?? variation.bear_pause_exit_sigma),
          momentum_length: Number(config.momentumLength ?? variation.momentum_length),
          momentum_threshold: Number(config.momentumThreshold ?? variation.momentum_threshold),
          enable_retrace: config.enableRetrace ?? variation.enable_retrace,
          retrace_base: Number(config.retraceBase ?? variation.retrace_base),
          updated_at: new Date().toISOString()
        };

        // Add all B1-B11 values
        if (config.B) {
          for (let i = 1; i <= 11; i++) {
            const key = `B${i}`;
            const dbKey = `b${i}`;
            if (config.B[key] !== undefined) {
              updateData[dbKey] = Number(config.B[key]);
            }
          }
        }

        // Build old/new config for history logging
        const oldConfig = {
          B: {}
        };
        for (let i = 1; i <= 11; i++) {
          oldConfig.B[`B${i}`] = variation[`b${i}`];
        }
        oldConfig.bearPauseEnterSigma = variation.bear_pause_enter_sigma;
        oldConfig.bearPauseExitSigma = variation.bear_pause_exit_sigma;
        oldConfig.momentumLength = variation.momentum_length;
        oldConfig.momentumThreshold = variation.momentum_threshold;
        oldConfig.enableRetrace = variation.enable_retrace;
        oldConfig.retraceBase = variation.retrace_base;

        const newConfig = {
          B: config.B || oldConfig.B,
          bearPauseEnterSigma: updateData.bear_pause_enter_sigma,
          bearPauseExitSigma: updateData.bear_pause_exit_sigma,
          momentumLength: updateData.momentum_length,
          momentumThreshold: updateData.momentum_threshold,
          enableRetrace: updateData.enable_retrace,
          retraceBase: updateData.retrace_base
        };

        // Update via Supabase client
        const { data, error } = await supabaseClient
          .schema('lth_pvr')
          .from('strategy_variation_templates')
          .update(updateData)
          .eq('id', currentVariationId)
          .eq('org_id', orgId)
          .select();

        if (error) {
          console.error('Error applying configuration:', error);
          alert(`Failed to apply parameters: ${error.message}`);
          if (applyBtn) {
            applyBtn.disabled = false;
            applyBtn.textContent = originalText;
          }
          return;
        }

        if (!data || data.length === 0) {
          alert('Error: No variation was updated. Please check permissions.');
          if (applyBtn) {
            applyBtn.disabled = false;
            applyBtn.textContent = originalText;
          }
          return;
        }

        // Log parameter change to history table
        try {
          const { data: userData } = await supabaseClient.auth.getUser();
          const userId = userData?.user?.id;

          await supabaseClient
            .schema('lth_pvr')
            .from('variation_parameter_history')
            .insert({
              variation_id: currentVariationId,
              org_id: orgId,
              changed_by: userId,
              change_type: 'optimization',
              change_reason: 'Applied optimized configuration from grid search',
              old_config: oldConfig,
              new_config: newConfig
            });
        } catch (historyErr) {
          console.error('Error logging history (non-fatal):', historyErr);
        }

        // Success!
        alert(`Parameters applied successfully to "${variation.variation_name}"!\n\nChanges will take effect at the next trading cycle (03:00 UTC tomorrow).`);

        // Reload variation cards to show updated values
        await loadLthPvrVariations();

        // Hide optimization results panel
        optimizationResultsPanel.style.display = 'none';
        currentVariationId = null;

      } catch (err) {
        console.error('Error in applyOptimizedConfig:', err);
        alert(`Error applying configuration: ${err.message}`);
      }
    }

    // Close optimization results
    function closeOptimizationResults() {
      optimizationResultsPanel.style.display = 'none';
      currentVariationId = null;
    }

    // Load parameter history for a variation
    async function loadParameterHistory(variationId, variationName) {
      try {
        // Display modal
        document.getElementById('historyVariationName').textContent = variationName;
        document.getElementById('parameterHistoryModal').style.display = 'block';
        
        // Show loading state
        const tbody = document.getElementById('historyTableBody');
        tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;padding:2rem;color:var(--muted);">Loading history...</td></tr>';

        // Get org_id from context
        const orgSelect = document.getElementById('orgSelect');
        const orgId = orgSelect?.value;

        if (!orgId) {
          tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;padding:2rem;color:#ef4444;">Error: Organization not selected</td></tr>';
          return;
        }

        // Query history (with LEFT JOIN to auth.users for email)
        const { data: history, error } = await supabaseClient
          .schema('lth_pvr')
          .from('variation_parameter_history')
          .select('*')
          .eq('variation_id', variationId)
          .eq('org_id', orgId)
          .order('changed_at', { ascending: false })
          .limit(50);

        if (error) {
          console.error('Error loading history:', error);
          tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:2rem;color:#ef4444;">Error: ${error.message}</td></tr>`;
          return;
        }

        if (!history || history.length === 0) {
          tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;padding:2rem;color:var(--muted);">No parameter history found for this variation</td></tr>';
          return;
        }

        // Get user emails separately (since cross-schema joins not supported in client)
        const userIds = [...new Set(history.map(h => h.changed_by).filter(id => id))];
        let userEmails = {};
        
        if (userIds.length > 0) {
          try {
            const { data: users } = await supabaseClient.auth.admin.listUsers();
            users?.users?.forEach(u => {
              userEmails[u.id] = u.email;
            });
          } catch (e) {
            console.warn('Could not fetch user emails:', e);
          }
        }

        // Render history table
        tbody.innerHTML = history.map(h => {
          const config = h.new_config || {};
          const changedBy = h.changed_by ? (userEmails[h.changed_by] || 'User') : 'System';
          const changeTypeColors = {
            'initial': '#6b7280',
            'manual': '#3b82f6',
            'optimization': '#10b981',
            'rollback': '#f59e0b'
          };
          
          return `
            <tr>
              <td style="padding:.5rem;border:1px solid var(--border);white-space:nowrap;">${new Date(h.changed_at).toLocaleString()}</td>
              <td style="padding:.5rem;border:1px solid var(--border);">${changedBy}</td>
              <td style="padding:.5rem;border:1px solid var(--border);">
                <span style="display:inline-block;padding:2px 8px;border-radius:4px;font-size:0.8rem;background:${changeTypeColors[h.change_type] || '#6b7280'};color:#fff;">
                  ${h.change_type || 'unknown'}
                </span>
              </td>
              <td style="padding:.5rem;border:1px solid var(--border);text-align:right;">${config.B?.B1 ? (config.B.B1 * 100).toFixed(3) + '%' : 'N/A'}</td>
              <td style="padding:.5rem;border:1px solid var(--border);text-align:right;">${config.B?.B6 ? (config.B.B6 * 100).toFixed(3) + '%' : 'N/A'}</td>
              <td style="padding:.5rem;border:1px solid var(--border);text-align:right;">${config.bearPauseExitSigma !== undefined ? (config.bearPauseExitSigma > 0 ? '+' : '') + config.bearPauseExitSigma + 'σ' : 'N/A'}</td>
              <td style="padding:.5rem;border:1px solid var(--border);text-align:right;">${config.momentumLength !== undefined ? config.momentumLength + ' days' : 'N/A'}</td>
              <td style="padding:.5rem;border:1px solid var(--border);text-align:center;">
                <button onclick="window.strategyMaintenance.rollbackToConfig('${h.id}', '${variationId}')" 
                        type="button"
                        style="padding:4px 12px;background:#f59e0b;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:0.85rem;">
                  ↺ Rollback
                </button>
              </td>
            </tr>
          `;
        }).join('');

      } catch (err) {
        console.error('Error in loadParameterHistory:', err);
        const tbody = document.getElementById('historyTableBody');
        if (tbody) {
          tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:2rem;color:#ef4444;">Error: ${err.message}</td></tr>`;
        }
      }
    }

    // Rollback to a historical configuration
    async function rollbackToConfig(historyId, variationId) {
      try {
        // Confirmation
        const confirmed = confirm(
          "Are you sure you want to rollback to this configuration?\n\n" +
          "This will revert all parameters to this historical point.\n\n" +
          "Changes take effect at the next trading cycle (03:00 UTC tomorrow)."
        );

        if (!confirmed) return;

        // Get org_id from context
        const orgSelect = document.getElementById('orgSelect');
        const orgId = orgSelect?.value;

        if (!orgId) {
          alert('Error: Organization not selected');
          return;
        }

        // Load historical record
        const { data: historyRecord, error: historyError } = await supabaseClient
          .schema('lth_pvr')
          .from('variation_parameter_history')
          .select('*')
          .eq('id', historyId)
          .single();

        if (historyError) {
          console.error('Error loading history record:', historyError);
          alert(`Error loading history: ${historyError.message}`);
          return;
        }

        if (!historyRecord) {
          alert('Error: History record not found');
          return;
        }

        // Load current variation for old_config
        const { data: variation, error: varError } = await supabaseClient
          .schema('lth_pvr')
          .from('strategy_variation_templates')
          .select('*')
          .eq('id', variationId)
          .eq('org_id', orgId)
          .single();

        if (varError) {
          console.error('Error loading variation:', varError);
          alert(`Error loading variation: ${varError.message}`);
          return;
        }

        // Build old config for history logging
        const oldConfig = {
          B: {}
        };
        for (let i = 1; i <= 11; i++) {
          oldConfig.B[`B${i}`] = variation[`b${i}`];
        }
        oldConfig.bearPauseEnterSigma = variation.bear_pause_enter_sigma;
        oldConfig.bearPauseExitSigma = variation.bear_pause_exit_sigma;
        oldConfig.momentumLength = variation.momentum_length;
        oldConfig.momentumThreshold = variation.momentum_threshold;
        oldConfig.enableRetrace = variation.enable_retrace;
        oldConfig.retraceBase = variation.retrace_base;

        // Build update data from historical config
        const targetConfig = historyRecord.new_config;
        const updateData = {
          bear_pause_enter_sigma: Number(targetConfig.bearPauseEnterSigma),
          bear_pause_exit_sigma: Number(targetConfig.bearPauseExitSigma),
          momentum_length: Number(targetConfig.momentumLength),
          momentum_threshold: Number(targetConfig.momentumThreshold),
          enable_retrace: targetConfig.enableRetrace,
          retrace_base: Number(targetConfig.retraceBase),
          updated_at: new Date().toISOString()
        };

        // Add B1-B11 values
        if (targetConfig.B) {
          for (let i = 1; i <= 11; i++) {
            const key = `B${i}`;
            const dbKey = `b${i}`;
            if (targetConfig.B[key] !== undefined) {
              updateData[dbKey] = Number(targetConfig.B[key]);
            }
          }
        }

        // Update variation
        const { error: updateError } = await supabaseClient
          .schema('lth_pvr')
          .from('strategy_variation_templates')
          .update(updateData)
          .eq('id', variationId)
          .eq('org_id', orgId);

        if (updateError) {
          console.error('Error updating variation:', updateError);
          alert(`Rollback failed: ${updateError.message}`);
          return;
        }

        // Log rollback to history
        try {
          const { data: userData } = await supabaseClient.auth.getUser();
          const userId = userData?.user?.id;

          await supabaseClient
            .schema('lth_pvr')
            .from('variation_parameter_history')
            .insert({
              variation_id: variationId,
              org_id: orgId,
              changed_by: userId,
              change_type: 'rollback',
              change_reason: `Rolled back to configuration from ${new Date(historyRecord.changed_at).toLocaleString()}`,
              old_config: oldConfig,
              new_config: targetConfig
            });
        } catch (historyErr) {
          console.error('Error logging rollback (non-fatal):', historyErr);
        }

        // Success
        alert(`✅ Parameters rolled back successfully to ${new Date(historyRecord.changed_at).toLocaleString()}!`);

        // Reload variations and close modal
        closeHistoryModal();
        await loadLthPvrVariations();

      } catch (err) {
        console.error('Error in rollbackToConfig:', err);
        alert(`Rollback failed: ${err.message}`);
      }
    }

    // Close parameter history modal
    function closeHistoryModal() {
      document.getElementById('parameterHistoryModal').style.display = 'none';
    }

    // Cancel simulation
    document.getElementById('cancelSimBtn')?.addEventListener('click', hideSimulationResults);
    
    // Run simulation button
    document.getElementById('runSimBtn')?.addEventListener('click', runSimulation);

    // Run optimization button
    document.getElementById('runOptBtn')?.addEventListener('click', runOptimization);

    // Toggle "no strategy selected" message visibility
    function updateNoStrategyMessage() {
      const noStrategyMsg = document.getElementById('noStrategyMessage');
      if (noStrategyMsg && location.hash === '#strategy-maintenance-module') {
        const hasStrategy = window.currentStrategyCode && window.currentStrategyCode.trim() !== '';
        noStrategyMsg.style.display = hasStrategy ? 'none' : 'block';
      }
    }

    // Load variations when strategy is selected via context bar
    // Listen for portfolio/strategy changes in the context bar
    document.getElementById('portfolioSelect')?.addEventListener('change', (e) => {
      console.log('🔍 Portfolio change detected in Strategy Maintenance handler');
      
      // Only load variations if we're on the Strategy Maintenance module
      if (location.hash === '#strategy-maintenance-module') {
        // Get strategy code directly from the select element (don't rely on window.currentStrategyCode timing)
        const strategyCode = (e.target.value || '').toUpperCase();
        console.log('Strategy code from select element:', strategyCode);
        
        // Use setTimeout to ensure context bar handler runs first and sets window.currentStrategyCode
        setTimeout(() => {
          // Don't reload variations if context is being updated programmatically
          if (window.programmaticallyUpdatingContext) {
            console.log('⏸️ Skipping loadLthPvrVariations - programmatic context update');
            return;
          }
          
          updateNoStrategyMessage();
          console.log('Strategy code check:', strategyCode, 'equals LTH_PVR?', strategyCode === 'LTH_PVR');
          if (strategyCode === 'LTH_PVR') {
            console.log('✅ Calling loadLthPvrVariations()');
            loadLthPvrVariations();
          } else {
            console.log('❌ Not calling loadLthPvrVariations, strategy is:', strategyCode);
          }
        }, 50);
      }
    });

    // Load variations when navigating to Strategy Maintenance module
    window.addEventListener('hashchange', () => {
      if (location.hash === '#strategy-maintenance-module') {
        updateNoStrategyMessage();
        const strategyCode = window.currentStrategyCode;
        if (strategyCode === 'LTH_PVR') {
          loadLthPvrVariations();
        }
      }
    });

    // Load variations on initial page load if already on Strategy Maintenance
    // (wait for context bar to populate first)
    setTimeout(() => {
      if (location.hash === '#strategy-maintenance-module') {
        updateNoStrategyMessage();
        const strategyCode = window.currentStrategyCode;
        if (strategyCode === 'LTH_PVR') {
          loadLthPvrVariations();
        }
      }
    }, 500);

    // Expose functions globally for onclick handlers
    window.strategyMaintenance = {
      viewVariationDetails,
      showSimulationControls,
      optimizeVariation,
      hideSimulationResults,
      loadLthPvrVariations,
      closeOptimizationModal,
      closeOptimizationResults,
      applyOptimizedConfig,
      updateNoStrategyMessage,
      exportSimulationToCSV,
      loadParameterHistory,
      rollbackToConfig,
      closeHistoryModal
    };

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

  })();

  </script>
</body>
</html>
