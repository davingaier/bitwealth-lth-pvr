<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BitWealth</title>

  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css"/>

  <style>
    :root{
      --border:#e7e7e7; --ink:#111827; --muted:#6b7280; --grid:#F2F2F2;
      --control-height:44px; --control-radius:8px; --control-pad-x:12px; --control-caret-offset:12px; --control-width:340px;

      --series-btc-price:#ff8c00;
      --series-invested:#000000;
      --series-adv-value:#22c55e;
      --series-usd-balance:#60a5fa;
      --series-btc-balance:#ef4444;
      --series-comp-adv:#032C48;
      --series-comp-std:#BEBEBE;
    }

    body{font-family:'Aptos',system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:0;color:var(--ink);background:#fff}
    header{display:flex;align-items:center;padding:1em 2em;border-bottom:1px solid var(--border);background:#fff}
    header img{height:60px}

    nav{padding:.5em 2em;background:#f8f8f8;border-bottom:1px solid var(--border);white-space:nowrap;overflow-x:auto;position:relative;z-index:5}
    nav a{display:inline-block;text-decoration:none;color:inherit;padding:.5em 1em;margin-right:1em;border-radius:6px}
    nav a:hover{background:#efefef}

    /* Org / portfolio context bar
       - Only visible for strategy-sensitive modules
       - Hidden for Import, Finance, Administration, etc.
    */
    .context-bar{
      display:none;
      flex-wrap:wrap;
      gap:1.5rem;
      align-items:flex-end;
      padding:.25rem 2rem .75rem;
      background:#f8f8f8;
      border-bottom:1px solid var(--border);
    }
    /* Show the context bar only when a strategy module is active */
    body:has(#balance-maintenance-module:target) .context-bar,
    body:has(#transactions-module:target) .context-bar,
    body:has(#reports-module:target) .context-bar{
      display:flex;
    }

    /* Customer Transactions is multi-customer: hide the customer selector in the global context bar */
    body:has(#transactions-module:target) #ctxCustomerGroup{
      display:none;
    }
    .context-group{
      display:flex;
      flex-direction:column;
      gap:.25rem;
      min-width:220px;
    }
    .context-label{
      font-size:.75rem;
      text-transform:uppercase;
      letter-spacing:.05em;
      color:var(--muted);
    }
    .context-select{
      height:var(--control-height);
      border-radius:var(--control-radius);
      border:1px solid var(--border);
      padding:0 var(--control-pad-x);
      background:#fff;
      font:inherit;
      min-width:220px;
    }
    .context-select:disabled{
      background:#f3f4f6;
      color:var(--muted);
      cursor:not-allowed;
    }

    /* Global context bar: Customer Transactions is multi-customer */
    body:has(#transactions-module:target) #ctxCustomerGroup{
      display:none;
    }

    /* Generic helper for strategy-specific cards */
    .strategy-hidden{
      display:none !important;
    }

    /* Active tab strictly matches visible :target (uniform style for all modules) */
    body:not(:has(.module:target)) nav a[href="#import-module"],
    body:has(#maintenance-module:target) nav a[href="#maintenance-module"],
    body:has(#strategy-maintenance-module:target) nav a[href="#strategy-maintenance-module"],
    body:has(#import-module:target) nav a[href="#import-module"],
    body:has(#balance-maintenance-module:target) nav a[href="#balance-maintenance-module"],
    body:has(#transactions-module:target) nav a[href="#transactions-module"],
    body:has(#reports-module:target) nav a[href="#reports-module"],
    body:has(#backtest-module:target) nav a[href="#backtest-module"],
    body:has(#finance-module:target) nav a[href="#finance-module"],
    body:has(#admin-module:target) nav a[href="#admin-module"]{
      border-bottom:2px solid var(--series-btc-price);
      color:var(--series-btc-price);
    }

    main{padding:2em}

    .executed-collapsible summary { cursor:pointer; user-select:none }
    .executed-list .row { display:flex; gap:.5rem; padding:.25rem 0; border-bottom:1px solid #eee; font:12px system-ui }
    .executed-list .row:last-child { border-bottom:none }
    .executed-list .side-buy { color:#15803d }  /* green */
    .executed-list .side-sell { color:#b91c1c } /* red */

    .bmBadge {
      display:inline-block; margin-right:.5rem;
      padding:2px 6px; font-size:11px; border-radius:10px;
      color:#155724; background:#d4edda; border:1px solid #c3e6cb;
      vertical-align:middle;
    }

    .bmBadge--muted{ color:#374151; background:#f3f4f6; border:1px solid #e5e7eb; }

    /* --- Status pill badges (orders) --- */
    .status-pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #e5e7eb;    /* light gray border */
      font-size:12px;
      line-height:1.2;
      vertical-align:middle;
      white-space:nowrap;
      user-select:none;
    }

    /* queued/created but not yet active */
    .status-pill.submitted{
      background:#fff7ed;          /* amber-50 */
      color:#9a3412;               /* amber-800 */
      border-color:#fed7aa;        /* amber-200 */
    }

    /* actively working / polling */
    .status-pill.executing{
      background:#f3f4f6;          /* gray-100 */
      color:#374151;               /* gray-700 */
      border-color:#e5e7eb;        /* gray-200 */
    }

    /* exchange shows partial fill */
    .status-pill.partially_filled{
      background:#e0f2fe;          /* sky-100 */
      color:#075985;               /* sky-800 */
      border-color:#bae6fd;        /* sky-200 */
    }

    /* terminal: filled */
    .status-pill.filled{
      background:#d1fae5;          /* emerald-100 */
      color:#065f46;               /* emerald-900 */
      border-color:#a7f3d0;        /* emerald-200 */
    }

    /* terminal: cancelled */
    .status-pill.cancelled{
      background:#fee2e2;          /* rose-100 */
      color:#991b1b;               /* rose-900 */
      border-color:#fecaca;        /* rose-200 */
    }

    /* terminal: error */
    .status-pill.error{
      background:#fee2e2;          /* rose-100 */
      color:#991b1b;               /* rose-900 */
      border-color:#fecaca;        /* rose-200 */
    }

    /* non-actioned / below min etc. */
    .status-pill.skipped{
      background:#e5e7eb;          /* gray-200 */
      color:#374151;               /* gray-700 */
      border-color:#e5e7eb;        /* gray-200 */
    }

    /* optional: “preview” badge styling if you show it */
    .status-pill.preview{
      background:#eef2ff;          /* indigo-50 */
      color:#3730a3;               /* indigo-800 */
      border-color:#c7d2fe;        /* indigo-200 */
    }

    @keyframes pillPulse { 0%{opacity:.85} 50%{opacity:1} 100%{opacity:.85} }
    .status-pill.executing{ animation:pillPulse 1.2s ease-in-out infinite; }

    /* Router: show current :target; default to Import */
    .module{display:none}
    .module:target{display:block}
    body:not(:has(.module:target)) #import-module{display:block}

    #inlineError,#reportsError,#balancesError{color:#b91c1c;background:#fee2e2;padding:.75em 1em;border:1px solid #fecaca;border-radius:10px;display:none;margin-bottom:1em}

    table{border-collapse:collapse;width:100%;margin-top:1em}
    th,td{border:1px solid #ccc;padding:.5em;text-align:center}
    th{background:#f0f0f0}
    #importBtn{margin-top:1em}
    .status-duplicate{color:#d97706}.status-ready{color:#16a34a}

    /* ===== CENTER the dropdown row (outer flex + inner grid) ===== */
    .reports-controls-outer{
      display:flex;
      justify-content:center;
      align-items:center;
      width:100%;
    }
    .reports-controls{
      display:grid;
      grid-template-columns:max-content var(--control-width) max-content var(--control-width);
      align-items:center;
      gap:0.75rem 1rem;
      width:auto;
    }
    .reports-controls label{justify-self:end;}

    /* Native select base (report type before Choices attaches) */
    .reports-controls select{
      font-family:inherit;font-size:1rem;color:var(--ink);
      width:var(--control-width);min-width:var(--control-width);height:var(--control-height);
      background:#fff;border:1px solid var(--border)!important;border-radius:var(--control-radius);
      padding:0 calc(2.2rem) 0 var(--control-pad-x);line-height:1.25;
      appearance:none;-webkit-appearance:none;-moz-appearance:none;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 6'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%236b7280' stroke-width='1.5' fill='none' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
      background-repeat:no-repeat;background-size:10px 6px;background-position:right var(--control-caret-offset) center;box-shadow:none;outline:0;
      text-align:left;
    }

    /* Choices.js size normalization & left text */
    .choices__list--dropdown{z-index:9999}
    .reports-controls .choices{
      width:var(--control-width);min-width:var(--control-width);
      font-family:inherit;margin:0 !important;
    }
    .choices[data-type*="select-one"] .choices__inner{
      border:1px solid var(--border);border-radius:var(--control-radius);
      background:#fff;min-height:var(--control-height);height:var(--control-height);
      padding:0;display:flex;align-items:center;text-align:left
    }
    .choices__list--single{
      padding:0 calc(2.2rem) 0 var(--control-pad-x);
      width:100%;display:flex;align-items:center;justify-content:flex-start;text-align:left
    }
    .choices__list--dropdown,.choices__list[aria-expanded]{border:1px solid var(--border);border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,.08)}
    .choices__list--dropdown .choices__item--selectable{padding:10px 12px}
    .choices__item--selectable.is-highlighted{background:#f8fafc}
    .choices.is-open .choices__inner,.choices.is-focused .choices__inner{border-color:#032C48;box-shadow:0 0 0 3px rgba(3,44,72,.08)}
    .choices__input{padding:8px 10px!important;margin-bottom:6px;border-bottom:1px solid var(--border)!important}

    /* Mobile stack */
    @media (max-width:760px){
      .reports-controls{grid-template-columns:1fr;justify-items:center}
      .reports-controls label{justify-self:center}
    }

    .card{max-width:1200px;margin:1rem auto 0;background:#fff;border:1px solid var(--border);border-radius:16px;box-shadow:0 1px 3px rgba(0,0,0,.05);padding:14px 16px 10px}
    .chart-title{text-align:center;margin:8px 0 6px}
    .chart-notice{display:none;text-align:center;color:var(--muted);margin:.75rem 0}
    .chart-toolbar{display:flex;justify-content:center;gap:.5rem;margin:4px 0 8px}
    .chart-toolbar button{padding:.35rem .7rem;font-size:.9rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
    canvas{max-width:100%}
    .chart-range{display:none;margin-top:6px}
    .chart-range .sliders{display:flex;gap:.5rem;align-items:center}
    .chart-range input[type=range]{width:100%}
    .chart-range .labels{display:flex;justify-content:space-between;font-size:.85rem;color:var(--muted);margin-top:.25rem}
    .chart-footer{display:none;justify-content:center;gap:.5rem;flex-wrap:wrap;margin-top:.5rem}
    .badge{display:flex;align-items:center;gap:.5rem;font-size:.9rem;background:#fafafa;border:1px solid var(--border);border-radius:999px;padding:.25rem .6rem}
    .badge .dot{width:10px;height:10px;border-radius:50%}
    .badge small{color:var(--muted);font-size:.8rem}
    .chart-actions{margin-top:.5rem;text-align:center}
    .chart-actions button{padding:.45rem .8rem;font-size:.95rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
    .chart-actions button:disabled{opacity:.5;cursor:not-allowed}

    /* --- Transactions module buttons --- */
    .tx-toolbar{display:flex;justify-content:center;gap:.5rem;margin:8px 0}
    .tx-toolbar button{padding:.45rem .8rem;font-size:.95rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}

    /* ===== Customer Maintenance styles ===== */
    .cm-tab{padding:.45rem .8rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
    .cm-tab--active{border-color:#032C48;box-shadow:0 0 0 3px rgba(3,44,72,.08)}
    .cm-form label{display:flex;flex-direction:column;gap:.35rem;font-size:.95rem}
    .cm-form input,.cm-form select{
      font:inherit;height:var(--control-height);border:1px solid var(--border);border-radius:var(--control-radius);
      padding:0 var(--control-pad-x);background:#fff;min-width:0;
    }
    .cm-grid{display:grid;grid-template-columns:repeat(2,minmax(260px,1fr));gap:.75rem}
    @media (max-width:760px){.cm-grid{grid-template-columns:1fr}}
    .req{color:#dc2626;margin-left:.25rem}
    .label-line{display:inline-flex;align-items:center;gap:.25rem}

    /* Small sub-section heading + separators inside Transactions */
    .subhead{
      font-size:1.05rem;
      color:var(--muted);
      font-weight:600;
      margin:1rem auto .5rem;
      max-width:1200px;
    }
    .section-sep{
      border:0;
      border-top:1px solid var(--border);
      margin:1rem auto;
      max-width:1200px;
      height:0;
    }

    /* Center the Run Daily Rules controls */
    #transactions-module #daily-rules-runner{max-width:1200px;margin:.25rem auto 1rem;}
    #transactions-module #daily-rules-runner .run-toolbar{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
      gap:.75rem 1rem;
      text-align:center;
    }
    #transactions-module #daily-rules-runner .run-toolbar label{
      display:inline-flex;
      align-items:center;
      gap:.5rem;
      margin:0;
    }
    #transactions-module #daily-rules-runner .run-status{
      display:flex;
      justify-content:center;
      margin-top:.5rem;
      color:var(--muted);
    }
    #transactions-module #daily-rules-runner #rulesStatus{color:var(--muted);}
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
    if (window.Chart) {
      const css = getComputedStyle(document.documentElement);
      const ink  = css.getPropertyValue('--ink').trim()  || '#111827';
      const grid = css.getPropertyValue('--grid').trim() || '#F2F2F2';
      Chart.defaults.font.family = 'Aptos, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      Chart.defaults.color = ink;
      Chart.defaults.borderColor = grid;
    }
  </script>
</head>
<body>
  <header>
    <img src="assets/bitwealth-logo.png" alt="BitWealth Logo" crossorigin="anonymous" />
    <img id="pdfLogo" src="assets/bitwealth-logo.png" alt="BitWealth Logo" style="display:none" />
  </header>

  <nav id="topnav">
    <a href="#maintenance-module">Customer Maintenance</a>
    <a href="#strategy-maintenance-module">Strategy Maintenance</a>
    <a href="#import-module">Import Daily Data</a>
    <a id="nav-cbm" class="top-tab" href="#balance-maintenance-module">Customer Balance Maintenance</a>
    <a href="#transactions-module">Customer Transactions</a>
    <a href="#reports-module">Portfolio Performance Reporting</a>
    <a href="#backtest-module">Strategy Back-Testing</a>
    <a href="#finance-module">Finance</a>
    <a href="#admin-module">Administration</a>
  </nav>

  <!-- Org / portfolio context (shared across modules) -->
  <section id="contextBar" class="context-bar">
    <div class="context-group">
      <span class="context-label">Organisation</span>
      <select id="orgSelect" class="context-select" disabled>
        <option>Loading…</option>
      </select>
    </div>
    <div class="context-group" id="ctxCustomerGroup">
      <span class="context-label">Customer</span>
      <select id="customerSelect" class="context-select" disabled>
        <option>Loading customers…</option>
      </select>
    </div>
    <div class="context-group">
      <span class="context-label">Active portfolio / strategy</span>
      <select id="portfolioSelect" class="context-select" disabled>
        <option>Loading…</option>
      </select>
    </div>
  </section>

  <main>

    <!-- ===================== Customer Maintenance ===================== -->
    <div id="maintenance-module" class="module">
      <h2>Customer Maintenance</h2>

      <div class="card" style="max-width:980px">
        <nav style="display:flex;gap:.5rem;margin-bottom:.75rem;">
          <button id="cmTabNew"  type="button" class="cm-tab cm-tab--active">Create New Client</button>
          <button id="cmTabEdit" type="button" class="cm-tab">Edit Existing Client</button>
        </nav>

        <div id="cmAlert" style="display:none;margin:.5rem 0;padding:.7rem 1rem;border-radius:10px;border:1px solid"></div>

        <!-- ===== New Client ===== -->
        <form id="cmFormNew" class="cm-form">
          <h3 style="margin:.25rem 0 1rem">New Client Details</h3>

          <div class="cm-grid">
            <label>
              <span class="label-line">First names <span class="req">*</span></span>
              <input name="first_names" required />
            </label>
            <label>
              <span class="label-line">Last name <span class="req">*</span></span>
              <input name="last_name" required />
            </label>
            <label>
              <span class="label-line">Email address <span class="req">*</span></span>
              <input name="email_address" type="email" required />
            </label>
            <label>
              <span class="label-line">Cellphone number <span class="req">*</span></span>
              <input name="cellphone_number" required />
            </label>
            <label>
              <span class="label-line">ID number <span class="req">*</span></span>
              <input name="id_number" inputmode="numeric" pattern="\d{13}" title="13-digit SA ID number" required />
            </label>

            <label>
              <span class="label-line">Trade start date</span>
              <input name="trade_start_date" type="date" />
            </label>

            <label>
              <span class="label-line">Recurrence <span class="req">*</span></span>
              <select name="recurring_contribution_frequency" required>
                <option value="None">None</option>
                <option value="Weekly">Weekly</option>
                <option value="Monthly" selected>Monthly</option>
                <option value="Annually">Annually</option>
              </select>
            </label>

            <label>
              <span class="label-line">Recurring contribution (ZAR) <span class="req" data-cm-req="freq">*</span></span>
              <input name="recurring_contribution_zar" type="number" min="0" step="0.01" />
            </label>
            <label>
              <span class="label-line">Upfront contribution (ZAR)</span>
              <input name="upfront_contribution_zar" type="number" min="0" step="0.01" value="0" />
            </label>
            <label>
              <span class="label-line">Upfront contribution (BTC)</span>
              <input name="upfront_contribution_btc" type="number" min="0" step="0.00000001" value="0" />
            </label>

            <label>
              <span class="label-line">Exchange name</span>
              <select name="exchange_api_name">
                <option value="">None</option>
                <option value="VALR">VALR</option>
                <option value="Binance">Binance</option>
                <option value="Luno">Luno</option>
              </select>
            </label>
            <label><span class="label-line">Exchange username</span> <input name="exchange_username" /></label>
            <label><span class="label-line">Exchange password</span> <input name="exchange_password" type="password" /></label>
            <label><span class="label-line">API key</span> <input name="exchange_api_key" /></label>
            <label><span class="label-line">API secret</span> <input name="exchange_api_secret" type="password" /></label>
            <label><span class="label-line">BTC wallet address</span> <input name="exchange_btc_wallet_address" /></label>

            <label>
              <span class="label-line">Status <span class="req">*</span></span>
              <select name="customer_status" required>
                <option value="Active" selected>Active</option>
                <option value="Inactive">Inactive</option>
                <option value="Suspended">Suspended</option>
              </select>
            </label>
          </div>

          <div style="display:flex;gap:.5rem;margin-top:.75rem;">
            <button type="submit">Create Client</button>
            <button type="reset">Reset</button>
          </div>
        </form>

        <!-- ===== Edit Client ===== -->
        <form id="cmFormEdit" class="cm-form" style="display:none;">
          <h3 style="margin:.25rem 0 1rem">Edit Client Details</h3>

          <div style="margin-bottom:.75rem;">
            <label><strong>Select client:</strong>
              <select id="cmEditSelect"><option value="">Loading customers…</option></select>
            </label>
          </div>

          <div class="cm-grid">
            <label><span class="label-line">First names <span class="req">*</span></span> <input name="first_names" required /></label>
            <label><span class="label-line">Last name <span class="req">*</span></span> <input name="last_name" required /></label>
            <label><span class="label-line">Email address <span class="req">*</span></span> <input name="email_address" type="email" required /></label>
            <label><span class="label-line">Cellphone number <span class="req">*</span></span> <input name="cellphone_number" required /></label>
            <label>
              <span class="label-line">ID number <span class="req">*</span></span>
              <input name="id_number" inputmode="numeric" pattern="\d{13}" title="13-digit SA ID number" required />
            </label>

            <label><span class="label-line">Trade start date</span> <input name="trade_start_date" type="date" /></label>

            <label>
              <span class="label-line">Recurrence <span class="req">*</span></span>
              <select name="recurring_contribution_frequency" required>
                <option value="None">None</option>
                <option value="Weekly">Weekly</option>
                <option value="Monthly" selected>Monthly</option>
                <option value="Annually">Annually</option>
              </select>
            </label>

            <label>
              <span class="label-line">Recurring contribution (ZAR) <span class="req" data-cm-req="freq">*</span></span>
              <input name="recurring_contribution_zar" type="number" min="0" step="0.01" />
            </label>
            <label><span class="label-line">Upfront contribution (ZAR)</span> <input name="upfront_contribution_zar" type="number" min="0" step="0.01" /></label>
            <label><span class="label-line">Upfront contribution (BTC)</span> <input name="upfront_contribution_btc" type="number" min="0" step="0.00000001" /></label>

            <label>
              <span class="label-line">Exchange name</span>
              <select name="exchange_api_name">
                <option value="">None</option>
                <option value="VALR">VALR</option>
                <option value="Binance">Binance</option>
                <option value="Luno">Luno</option>
              </select>
            </label>
            <label><span class="label-line">Exchange username</span> <input name="exchange_username" /></label>
            <label><span class="label-line">Exchange password</span> <input name="exchange_password" type="password" /></label>
            <label><span class="label-line">API key</span> <input name="exchange_api_key" /></label>
            <label><span class="label-line">API secret</span> <input name="exchange_api_secret" type="password" /></label>
            <label><span class="label-line">BTC wallet address</span> <input name="exchange_btc_wallet_address" /></label>

            <label>
              <span class="label-line">Status <span class="req">*</span></span>
              <select name="customer_status" required>
                <option value="Active">Active</option>
                <option value="Inactive">Inactive</option>
                <option value="Suspended">Suspended</option>
              </select>
            </label>
          </div>

          <div style="display:flex;gap:.5rem;margin-top:.75rem;">
            <button type="submit">Save Changes</button>
            <button type="button" id="cmDeleteBtn" style="margin-left:auto;">Delete Client</button>
          </div>
        </form>
      </div>
    </div>

    <div id="strategy-maintenance-module" class="module">
      <h2>Strategy Maintenance</h2><p>This module is under construction.</p>
    </div>

    <!-- ===================== Import Daily Data ===================== -->
    <div id="import-module" class="module">
      <h2>Import Daily Data</h2>
      <div id="inlineError"></div>
      <p>
        <label>Select CSV file:
          <input type="file" id="csvFileInput" accept=".csv" />
        </label>
        <button id="previewBtn" type="button">Preview</button>
      </p>
      <div id="preview"></div>
      <button id="importBtn" type="button" style="display:none;">Confirm Import</button>
      <div id="report"></div>
    </div>

    <!-- ===================== Customer Balance Maintenance ===================== -->
    <div id="balance-maintenance-module" class="module">
      <h2>Customer Balance Maintenance</h2>

      <!-- Exchange Balances (uses GLOBAL customer selection in the context bar) -->
      <hr class="section-sep">
      <h3 class="subhead">Exchange Balances</h3>

      <div class="reports-controls-outer">
        <div class="reports-controls">
          <div style="grid-column:1 / -1; color:#6b7280; font-size:12px;">
            Using the <strong>Customer</strong> selected in the top context bar.
          </div>

          <label for="retFrom"><strong>From:</strong></label>
          <button id="fetchBalancesBtn" type="button">Show exchange balances</button>
        </div>
      </div>

      <div class="card" id="balancesCard" style="display:none;max-width:1000px;margin:0 auto;">
        <h3>Exchange Balances</h3>
        <table class="details-table">
          <thead><tr><th>Asset</th><th>Available</th><th>Reserved</th></tr></thead>
          <tbody id="balancesTbody"></tbody>
        </table>
        <div style="display:flex;gap:.5rem;justify-content:center;margin-top:.75rem;flex-wrap:wrap;">
          <button id="refreshBalancesBtn" type="button">Refresh</button>
          <button id="hideBalancesBtn" type="button">Hide</button>
          <button id="convertZarBtn" type="button" disabled>Convert ZAR → USDT</button>
        </div>
      </div>

      <div id="balancesError"></div>

      <div class="card" data-strategy="ADV_DCA" style="max-width:1200px">
        <h3 class="chart-title">Real Exchange Transactions</h3>

        <div class="reports-controls-outer">
          <div class="reports-controls">
            <label for="retFrom"><strong>From:</strong></label>
            <input id="retFrom" type="date" />
            <label for="retTo"><strong>To:</strong></label>
            <input id="retTo" type="date" />
          </div>
        </div>

        <div class="tx-toolbar" style="justify-content:center;gap:.5rem;margin-top:.5rem;">
          <button id="retSyncBtn"  type="button">Sync trades from exchange</button>
          <button id="retLoadBtn"  type="button">Load from DB</button>
          <label style="display:inline-flex;align-items:center;gap:.4rem;">
            <input id="retOnlyUnalloc" type="checkbox"> Only unallocated USDT deposits
          </label>
          <select id="retAllocMonth" title="Allocate selected deposits to month (YYYY-MM)" disabled></select>
          <button id="retAllocBtn" type="button" disabled>Allocate selected</button>
        </div>

        <div class="run-status" style="text-align:center;margin-top:.35rem;color:#6b7280">
          <span id="retStatus">Idle</span>
        </div>

        <div id="retWrap" style="display:none;margin-top:.75rem;max-height:360px;overflow:auto;border:1px solid #eee;border-radius:8px">
          <table style="width:100%;border-collapse:collapse;font:12px system-ui">
            <thead>
              <tr>
                <th style="text-align:left;padding:6px;">Date (UTC)</th>
                <th>Type</th>
                <th>Pair</th>
                <th>Debit</th>
                <th>Debit value</th>
                <th>Credit</th>
                <th>Credit value</th>
                <th>Fee</th>
                <th>Price</th>
                <th>Order id</th>
                <th>Classification</th>
                <th>Allocated</th>
                <th><input type="checkbox" id="retCheckAll"></th>
              </tr>
            </thead>
            <tbody id="retBody"></tbody>
          </table>
        </div>
        <div class="tx-toolbar" style="justify-content:center;gap:.5rem;margin-top:.5rem;">
          <button id="retDriftBtn" type="button">Load balance drift (ledger vs snapshots)</button>
        </div>

        <div id="retDriftWrap" style="display:none;margin-top:.5rem;max-height:260px;overflow:auto;border:1px solid #eee;border-radius:8px">
          <table style="width:100%;border-collapse:collapse;font:12px system-ui">
            <thead>
              <tr>
                <th style="text-align:left;padding:6px;">Day (UTC)</th>
                <th>Observed USDT Δ</th>
                <th>Expected USDT Δ</th>
                <th>Drift USDT</th>
                <th>Observed BTC Δ</th>
                <th>Expected BTC Δ</th>
                <th>Drift BTC</th>
                <th>Observed ZAR Δ</th>
                <th>Expected ZAR Δ</th>
                <th>Drift ZAR</th>
              </tr>
            </thead>
            <tbody id="retDriftBody"></tbody>
          </table>
        </div>
      </div>

      <!-- LTH PVR BTC DCA – Ledger & Balances (skeleton for future wiring) -->
      <div class="card strategy-hidden" data-strategy="LTH_PVR" style="max-width:1200px; margin-top:14px">
        <h3 class="chart-title">LTH PVR – Ledger &amp; Balances</h3>

        <div class="reports-controls-outer">
          <div class="reports-controls">
            <label for="lthFrom"><strong>From:</strong></label>
            <input id="lthFrom" type="date" />
            <label for="lthTo"><strong>To:</strong></label>
            <input id="lthTo" type="date" />
          </div>
        </div>

        <div class="tx-toolbar" style="justify-content:center; gap:.5rem; margin-top:.5rem;">
          <button id="lthLoadBtn" type="button">
            Load from DB
          </button>
          <button id="lthRecalcBtn" type="button">
            Recalculate balances
          </button>
        </div>

        <div class="run-status" style="text-align:center; margin-top:.35rem; color:#6b7280">
          <span id="lthStatus">Idle</span>
        </div>

        <div id="lthTableWrap" style="display:none;margin-top:.75rem;max-height:360px;overflow:auto;border:1px solid #eee;border-radius:8px">
          <table style="width:100%;border-collapse:collapse;font:12px system-ui">
            <thead>
              <tr>
                <th style="text-align:left;padding:6px;">Date (UTC)</th>
                <th>Event type</th>
                <th>BTC Δ</th>
                <th>USDT Δ</th>
                <th>Note</th>
              </tr>
            </thead>
            <tbody id="lthBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- ===================== Customer Transactions ===================== -->
    <div id="transactions-module" class="module">
      <h2>Customer Transactions</h2>

      <div id="txAdvDcaBlock" data-strategy="ADV_DCA">

      <hr class="section-sep">
      <h3 class="subhead">Run Daily Rules</h3>

      <section id="daily-rules-runner" data-strategy="ADV_DCA" style="max-width:980px;margin:0 auto;">
        <div class="card">
          <h3>Create Daily Rules</h3>
          <p class="muted">Generate today’s buy/sell rules for all customers.</p>

          <div class="run-toolbar">
            <button id="runRulesBtn" type="button">Run Daily Rules</button>

            <label>
              <input id="dryRunChk" type="checkbox" checked> Dry run
            </label>

            <label>
              Preview limit
              <input id="previewLimit" type="number" value="100" min="1" max="5000" style="width:6rem">
            </label>

            <label>
              Force from date
              <input id="forceFrom" type="date" style="width:10rem">
            </label>

            <span id="rulesStatus">Idle</span>
          </div>

          <pre id="rulesSummary" style="margin-top:.5rem;white-space:pre-wrap;font:12px ui-monospace"></pre>

          <div id="rulesPreview" style="display:none;margin-top:.5rem;max-height:300px;overflow:auto;border:1px solid #eee;border-radius:8px">
            <table style="width:100%;border-collapse:collapse;font:12px system-ui">
              <thead id="rulesHead"></thead>
              <tbody id="rulesBody"></tbody>
            </table>
          </div>
        </div>
      </section>

      <hr class="section-sep">

      <h3 class="subhead">Create Real Orders (VALR)</h3>
      <div class="card" id="realOrdersCard">
        <div class="tx-toolbar" style="justify-content:center; gap:.75rem; flex-wrap:wrap;">
          <button id="previewIntentsBtn" type="button">Preview Orders</button>
          <button id="executeIntentsBtn" type="button" disabled>Execute Orders</button>
        </div>

        <div class="run-status"><span id="intentsStatus">Idle</span></div>

        <div id="intentsTableWrap" style="display:none;margin-top:.5rem;max-height:360px;overflow:auto;border:1px solid #eee;border-radius:8px">
          <table style="width:100%;border-collapse:collapse;font:12px system-ui">
            <thead id="intentsHead"></thead>
            <tbody id="intentsBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Executed orders (collapsible) -->
      <details id="executedDetails" class="executed-collapsible">
        <summary>
          Already executed in the last 7 days <span class="count">(0)</span>
        </summary>
        <div id="executedList" class="executed-list">No executed orders in the last 7 days.</div>
      </details>

      <!-- Placed orders (collapsible) -->
      <details id="placedDetails" class="executed-collapsible" style="margin-top:.5rem;">
        <summary>
          Placed orders (last 24h) <span class="count">(0)</span>
        </summary>
        <div id="placedList" class="executed-list">No placed orders yet.</div>
      </details>

      </div> <!-- /#txAdvDcaBlock -->

      <div class="card" id="livePreviewCard" data-strategy="LTH_PVR">
        <h3 class="chart-title">Preview Live Customer Transactions</h3>
        <p class="chart-notice" style="display:block">
          Coming soon — we’ll show the latest executed buys/sells and balance changes for the selected customer.
        </p>
      </div>
    </div>
    <script>
    (() => {

      // ---- Configure once ----
      const SUPABASE_URL = "https://wqnmxpooabmedvtackji.supabase.co";
      const EDGE_FUNCTION = "create-daily-rules";
      const AUTH_HEADERS = {}; // add anon key headers here only if your function requires JWT

      // ---- Scope to the Customer Transactions module only ----
      const root = document.querySelector('#transactions-module #daily-rules-runner');
      if (!root) return; // not on this view or DOM not rendered yet

      // Query ONLY inside this module (no global lookups)
      const q = (s) => root.querySelector(s);
      const runBtn         = q('#runRulesBtn');
      if (!runBtn) return; // safety
      const dryRunChk      = q('#dryRunChk');
      const previewLimitEl = q('#previewLimit');
      const forceFromEl    = q('#forceFrom');
      const statusEl       = q('#rulesStatus');
      const summaryEl      = q('#rulesSummary');
      const theadEl        = q('#rulesHead');
      const tbodyEl        = q('#rulesBody');
      const previewWrap    = q('#rulesPreview');

      async function callCreateDailyRules({ dryRun, previewLimit, forceFromDate }) {
        // If your function expects snake_case, map them here:
        const payload = {
          dry_run: dryRun,
          preview_limit: previewLimit,
          force_from_date: forceFromDate || null
        };

        const { data, error } = await window.supabaseClient.functions.invoke('create-daily-rules', {
          body: payload
        });
        if (error) throw new Error(error.message || 'Edge Function error');
        return data;
      }

      function renderPreview(rows) {
        if (!rows || !rows.length) { previewWrap.style.display = 'none'; return; }

        // Build columns from the union of keys across all rows
        let cols = Array.from(
          rows.reduce((set, r) => {
            Object.keys(r || {}).forEach(k => set.add(k));
            return set;
          }, new Set())
        );
        const HIDE = new Set(['opening_balance_btc','opening_balance_usdt']);
        cols = cols.filter(c => !HIDE.has(c));

        // Optional: keep sab_price_below_buy_signal next to sab_buy_signal
        const moveAfter = (list, key, after) => {
          const i = list.indexOf(key), j = list.indexOf(after);
          if (i > -1 && j > -1) { list.splice(i, 1); list.splice(j + 1, 0, key); }
        };
        moveAfter(cols, 'sab_price_below_buy_signal', 'sab_buy_signal');

        theadEl.innerHTML =
          '<tr>' +
          cols.map(c => `<th style="border-bottom:1px solid #eee;text-align:left;padding:6px 8px;background:#f8fafc">${c}</th>`).join('') +
          '</tr>';

        tbodyEl.innerHTML =
          rows.map(r =>
            '<tr>' +
            cols.map(c => `<td style="border-bottom:1px solid #f1f5f9;padding:6px 8px">${(r[c] ?? '')}</td>`).join('') +
            '</tr>'
          ).join('');

        previewWrap.style.display = 'block';
      }

      runBtn.addEventListener('click', async () => {
        summaryEl.textContent = '';
        renderPreview([]);
        statusEl.textContent = 'Running…';

        const dryRun   = !!dryRunChk?.checked;
        const limitVal = Number(previewLimitEl?.value) || 100;
        const fromVal  = forceFromEl?.value || null;

        try {
          const j = await callCreateDailyRules({ dryRun, previewLimit: limitVal, forceFromDate: fromVal });

          const lines = [];
          lines.push(`customers: ${j.customers ?? 0}`);
          if ('eligible' in j)     lines.push(`eligible daily rows: ${j.eligible}`);
          if ('to_insert' in j)    lines.push(`rules to insert: ${j.to_insert}`);
          if ('inserted' in j)     lines.push(`inserted: ${j.inserted}`);
          if (j.preview_truncated) lines.push(`preview truncated: true`);
          if (j.debug?.globalFrom) lines.push(`globalFrom: ${j.debug.globalFrom}`);

          summaryEl.textContent = lines.join('\n');
          renderPreview(j.preview);
          statusEl.textContent = dryRun ? 'Dry run complete' : 'Completed';
          document.dispatchEvent(new CustomEvent('daily-rules:completed'));

          if (!dryRun) {
            const yday = (()=>{
              const d=new Date(Date.now()-86400000); return d.toISOString().slice(0,10);
            })();

            // Build ADVANCED (sim)
            statusEl.textContent = 'Rules done — building ADV transactions…';
            try {
              const { data, error } = await supabaseClient.functions.invoke('adv-build-transactions', {
                body: { for_date: yday }
              });
              if (error || data?.error) {
                const msg = data?.error || error?.message || (error && JSON.stringify(error)) || 'Unknown error';
                throw new Error(msg);
              }

              statusEl.textContent = `ADV transactions built (${data?.totalRows ?? 0}).`;
            } catch (e) {
              console.error(e);
              statusEl.textContent = `ADV build failed: ${e.message || e}`;
            }

            // Build STANDARD DCA benchmark (sim)
            statusEl.textContent = 'Building STANDARD DCA benchmark…';
            try {
              const { data, error } = await supabaseClient.functions.invoke('std-build-transactions', {
                body: { for_date: yday }
              });
              if (error || data?.error) {
                const msg = data?.error || error?.message || (error && JSON.stringify(error)) || 'Unknown error';
                throw new Error(msg);
              }
              statusEl.textContent = `STANDARD DCA built (${data?.totalRows ?? 0}).`;
            } catch (e) {
              console.error(e);
              statusEl.textContent = `STANDARD DCA build failed: ${e.message || e}`;
            }
          }

        } catch (e) {
          statusEl.textContent = 'Error';
          summaryEl.textContent = String(e.message || e);
        }
      });
    })();
    </script>

    <!-- ANCHOR: Real Orders (VALR) JS START -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
      const sb = () => {
        const c = window.supabaseClient;
        if (!c) throw new Error('Supabase not ready');
        return c;
    };

    // shared poll state across runs (so resume listeners always see the latest)
    window._valrPollState = window._valrPollState || {
      polling: false,
      lastPollBody: null,
      resume: null,          // set to the latest pollLoop function each execution
    };
    
    // refresh Placed (last 24h) on load (wait for Supabase)
    const whenSbReady = async () => {
      const start = Date.now();
      while (!window.supabaseClient) {
        await new Promise(r => setTimeout(r, 50));
        if (Date.now() - start > 8000) return; // give up silently
      }
    };
    whenSbReady().then(() => loadPlaced24h().then(renderPlaced).catch(console.warn));

    const el = (id) => document.getElementById(id);

    const previewBtn = el('previewIntentsBtn');
    const executeBtn = el('executeIntentsBtn');
    if (previewBtn) previewBtn.disabled = false;
    if (executeBtn) executeBtn.disabled = true;
    const statusEl   = el('intentsStatus');
    const tableWrap  = el('intentsTableWrap');
    const headEl     = el('intentsHead');
    const bodyEl     = el('intentsBody');

    // New panels
    const placedWrap = el('placedDetails');
    const placedList = el('placedList');

    // --- Toast (non-blocking) ---
    function showToast(msg, ms = 2200) {
      let box = document.getElementById('toastBox');
      if (!box) {
        box = document.createElement('div');
        box.id = 'toastBox';
        Object.assign(box.style, {
          position: 'fixed', right: '14px', bottom: '14px', zIndex: 99999,
          display: 'flex', flexDirection: 'column', gap: '8px'
        });
        document.body.appendChild(box);
      }
      const t = document.createElement('div');
      t.textContent = msg;
      Object.assign(t.style, {
        background: '#111827', color: 'white', padding: '8px 12px',
        borderRadius: '8px', boxShadow: '0 6px 18px rgba(0,0,0,.18)',
        font: '12px system-ui', maxWidth: '72vw', opacity: '0.98'
      });
      box.appendChild(t);
      setTimeout(() => {
        t.style.transition = 'opacity .25s ease';
        t.style.opacity = '0';
        setTimeout(() => t.remove(), 260);
      }, ms);
    }

    function ydayUTC() {
      const d = new Date(Date.now() - 86_400_000);
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2,'0');
      const day = String(d.getUTCDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function todayUTC() {
      const d = new Date();
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2,'0');
      const day = String(d.getUTCDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function getForDate() { return ydayUTC(); }

    function pill(status, meta = {}) {
      const s = String(status || '').toLowerCase();
      // Accept both snake_case and camelCase from the EF
      const filled = meta.filled_qty ?? meta.filledQuantity;
      const orig   = meta.orig_qty   ?? meta.originalQuantity;

      if (s === 'partially_filled' && filled != null && orig != null) {
        const f = Number(filled), o = Number(orig);
        if (o > 0 && f >= o) return `<span class="status-pill filled">filled</span>`;
        // show progress: partial f/o
        const fTxt = (''+f);
        const oTxt = (''+o);
        return `<span class="status-pill partially_filled">partial ${fTxt}/${oTxt}</span>`;
      }

      const labelMap = { partially_filled: 'partial', partial: 'partial' };
      const text = labelMap[s] || s || '—';
      const cls  = `status-pill ${s.replace(/\s+/g,'_')}`;
      return `<span class="${cls}">${text}</span>`;
    }

    // ====== PREVIEW TABLE ======
    function renderIntentsTable(rows) {
      tableWrap.style.display = 'block';

      const cols = [
        'intent_id','customer_id','symbol','side',
        'intent_btc','intent_usdt','intent_price',
        'source_signal', 'status', 'live', 'notes'
      ];

      headEl.innerHTML = `<tr>${
        cols.map(c => `<th style="text-align:left;background:#f8fafc;padding:.4rem;border-bottom:1px solid #eee">${c.replace(/_/g,' ')}</th>`).join('')
      }</tr>`;

      if (!Array.isArray(rows) || !rows.length) {
        bodyEl.innerHTML = '<tr><td colspan="11" style="padding:.6rem;color:#6b7280">No orders for this date.</td></tr>';
        return;
      }

      bodyEl.innerHTML = rows.map(r => {
        const id  = r.intent_id ?? '';
        const s   = String(r.status || '').toLowerCase();
        const canCancel = ['submitted','executing','partially_filled'].includes(s);

        return `
          <tr data-id="${id}">
            <td>${id}</td>
            <td>${r.customer_id ?? ''}</td>
            <td>${r.symbol ?? ''}</td>
            <td>${r.side ?? ''}</td>
            <td>${Number(r.intent_btc ?? 0)}</td>
            <td>${Number(r.intent_usdt ?? 0)}</td>
            <td>${Number(r.intent_price ?? 0)}</td>
            <td>${r.source_signal ?? ''}</td>
            <td class="status-cell">${r.status ?? ''}</td>
            <td class="live-cell">
              <span class="pill">${pill(s)}</span>
              ${canCancel ? `<button class="cancel-btn" data-cancel="${id}" style="margin-left:.4rem">Cancel</button>` : ''}
            </td>
            <td>${r.notes ?? ''}</td>
          </tr>
        `;
      }).join('');
    }

    async function loadPreviewRows(forDate) {
      const { data, error } = await sb()
        .from('exchange_order_intents')
        .select('*')
        .eq('date_closing', forDate)
        .order('intent_id', { ascending: true });
      if (error) throw error;
      return data || [];
    }

    // ====== PLACED ORDERS (submitted/executing/filled/cancelled/error) ======
    async function loadPlaced24h() {
      const start = new Date(Date.now() - 24*60*60*1000).toISOString();
      const { data, error } = await sb()
        .from('exchange_order_intents')
        .select('intent_id,created_at,date_closing,symbol,side,intent_btc,intent_usdt,intent_price,status,notes')
        .in('status', ['submitted','executing','partially_filled','filled','cancelled','error'])
        .gte('created_at', start)
        .order('created_at', { ascending: false });
      if (error) { console.warn(error); return []; }
      return data || [];
    }

    function renderPlaced(rows) {
      if (!placedWrap || !placedList) return;
      const cnt = placedWrap.querySelector('.count');
      if (cnt) cnt.textContent = `(${rows.length})`;

      if (!rows.length) {
        placedList.textContent = 'No placed orders yet.';
        return;
      }

      placedList.innerHTML = rows.map(r => {
        const when = new Date(r.created_at);
        const d = when.toISOString().slice(0,10);
        const t = when.toLocaleTimeString([], { hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' });
        const s = String(r.status || '').toLowerCase();
        const canCancel = ['submitted','executing','partially_filled'].includes(s);
        return `
          <div class="row" data-id="${r.intent_id}">
            <div>on <strong>${d}</strong> at <strong>${t}</strong></div>
            <div>${String(r.symbol).toUpperCase()}</div>
            <div>${String(r.side).toUpperCase()}</div>
            <div>qty ₿ ${Number(r.intent_btc ?? 0)}</div>
            <div>qty ₮ ${Number(r.intent_usdt ?? 0)}</div>
            <div>@ ${Number(r.intent_price ?? 0)}</div>
            <div class="pill">${pill(s)}</div>
            ${canCancel ? `<button class="cancel-btn" data-cancel="${r.intent_id}">Cancel</button>` : ''}
            ${r.notes ? `<div class="muted">(${r.notes})</div>` : ''}
          </div>
        `;
      }).join('');
    }

    // Delegate cancel clicks (both in table and placed panel)
    document.addEventListener('click', async (e) => {
      const btn = e.target instanceof Element ? e.target.closest('.cancel-btn') : null;
      if (!btn) return;
      const iid = btn.getAttribute('data-cancel');
      if (!iid) return;
      if (!confirm(`Cancel order for intent ${iid}?`)) return;

      let success = false;
      try {
        // prevent double-submits immediately
        btn.setAttribute('disabled','true');

        const { data, error } = await sb().functions.invoke('valr-execute-orders', {
          body: { cancel_intent_id: iid }
        });
        if (error || data?.error) throw new Error(data?.error || error?.message || 'Cancel failed');
        success = true;

        // remember submitted ids from the execute response for consistent polling/resume
        window._lastSubmittedIds = (data?.submitted_intents || []).map(x => String(x.intent_id));

        // Refresh pills & lists
        const forDate = getForDate();
        const rows = await loadPreviewRows(forDate);
        renderIntentsTable(rows);
        const placed = await loadPlaced24h();
        renderPlaced(placed);
        statusEl.textContent = 'Cancelled';

        // ✅ toast on success (non-blocking)
        showToast('Order cancelled');

        // keep the clicked button disabled to avoid double-cancel; it will
        // disappear on the next render for this row (non-cancellable states)
      } catch (err) {
        console.error(err);
        alert('Cancel failed: ' + (err?.message || err));
      } finally {
        // Only re-enable on failure (so user can retry)
        if (!success) btn.removeAttribute('disabled');
      }
    });

    // ===== PREVIEW =====
    previewBtn?.addEventListener('click', async () => {
      const forDate = getForDate();
      try {
        previewBtn.disabled = true;
        executeBtn.disabled = true;
        statusEl.textContent = 'Building preview…';

        // optional: refresh executed & placed
        const placed = await loadPlaced24h();
        renderPlaced(placed);

        const { data, error } = await sb().functions.invoke('valr-preview-orders', { body: { for_date: forDate } });
        if (error || data?.error) throw new Error(data?.error || error?.message || 'Preview failed');

        const rows = await loadPreviewRows(forDate);
        renderIntentsTable(rows);
        statusEl.textContent = rows.length ? 'Preview ready' : 'No orders for this date';

        const hasPreview = rows.some(r => (String(r.status || '')).toLowerCase() === 'preview');
        executeBtn.disabled = !hasPreview;

        // also refresh executed collapsible (existing function in your file)
        try {
          const now = new Date();
          const start7 = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - 7, 0, 0, 0)).toISOString();
          const { data: executedRows } = await sb()
            .from('exchange_order_intents')
            .select('intent_id,date_closing,created_at,symbol,source_signal,side,intent_btc,intent_usdt,intent_price,status,notes')
            .in('status', ['filled','cancelled','error'])
            .gte('created_at', start7)
            .order('created_at', { ascending: false });
          // reuse your existing renderExecuted from earlier block
          if (window.renderExecuted) window.renderExecuted(executedRows || []);
        } catch {}
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Error: ' + (e?.message || e);
        headEl.innerHTML = '';
        bodyEl.innerHTML = '';
      } finally {
        previewBtn.disabled = false;
      }
    });

    // ===== EXECUTE =====
    executeBtn?.addEventListener('click', async () => {
      try {
        executeBtn.disabled = true;
        previewBtn.disabled  = true;

        const forDate = getForDate();

        // Guard
        const rowsNow = await loadPreviewRows(forDate);
        const hasPreview = rowsNow.some(r => String(r.status || '').toLowerCase() === 'preview');
        if (!hasPreview) {
          const statuses = [...new Set(rowsNow.map(r => String(r.status || '').toLowerCase()))].join(', ');
          statusEl.textContent = rowsNow.length
            ? `Nothing to execute — intents are ${statuses}.`
            : 'Nothing to execute — no intents for this date.';
          previewBtn.disabled = false;
          return;
        }

        statusEl.textContent = 'Submitting orders…';
        // reuse the forDate defined above
        const { data, error } = await sb().functions.invoke('valr-execute-orders', {
          body: { for_date: forDate }
        });
        const rowsAfterExec = await loadPreviewRows(forDate);
        renderIntentsTable(rowsAfterExec);

        if (error || data?.error) throw new Error(data?.error || error?.message || 'Execute failed');

        // Show placed orders panel
        const placed = await loadPlaced24h();
        renderPlaced(placed);
        placedWrap.open = true;

        statusEl.textContent = 'Submitted. Polling…';
        try { await window.loadExecutedOrders(); } catch {}

        // keep last poll request so we can resume on focus/visibility
        let _polling = false;
        let _lastPollBody = null;

        // allow an override body when resuming
        async function pollLoop(pollBodyOverride) {
          // hand the latest loop to global state so resume listeners call THIS run
          window._valrPollState.resume = (override) => pollLoop(override ?? window._valrPollState.lastPollBody);
          if (_polling) return;
          _polling = true;
          window._valrPollState.polling = true;

          const submittedIds = (window._lastSubmittedIds && window._lastSubmittedIds.length)
            ? window._lastSubmittedIds
            : (data?.submitted_intents || []).map(x => String(x.intent_id));

          const pollBody = pollBodyOverride
            ? pollBodyOverride
            : (submittedIds.length ? { intent_ids: submittedIds } : { for_date: forDate });

          // remember for resume
          _lastPollBody = pollBody;
          window._valrPollState.lastPollBody = pollBody;

          let delay = 1500;
          const maxDelay = 10000;
          const deadline = Date.now() + 5 * 60_000;   // 5-minute window

          // lock the first poll body for the whole run so we don't lose intent_ids
          const lockedPollBody = pollBody;

          while (Date.now() < deadline) {
            let polled, pErr;

            try {
              ({ data: polled, error: pErr } =
              await sb().functions.invoke('valr-poll-orders', { body: lockedPollBody }));
              // retry once on token/auth hiccup (401, 403)
              if (pErr && /401|403/.test(String(pErr.status || ''))) {
                try { await sb().auth.refreshSession(); } catch {}
                ({ data: polled, error: pErr } =
                  await sb().functions.invoke('valr-poll-orders', { body: lockedPollBody }));
              }
              if (pErr || polled?.error) throw new Error(polled?.error || pErr?.message || 'Polling failed');
            } catch (e) {
              // don’t kill the loop on transient network/auth errors; wait and try again
              await new Promise(r => setTimeout(r, delay));
              delay = Math.min(maxDelay, delay * 2);
              continue;
            }

            // ---- UI updates (unchanged) ----
            if (polled?.per_intent?.length) {
              for (const rec of polled.per_intent) {
                const row = bodyEl.querySelector(`tr[data-id="${rec.intent_id}"]`);
                if (row) {
                  const pillCell = row.querySelector('.live-cell .pill');
                  if (pillCell) pillCell.outerHTML = pill(
                    String(rec.status || '').toLowerCase(),
                    { filled_qty: rec.filled_quantity, orig_qty: rec.original_quantity }
                  );
                  const statusCell = row.querySelector('.status-cell');
                  if (statusCell) statusCell.textContent = String(rec.status || '').toLowerCase();
                  const btn = row.querySelector('.cancel-btn');
                  if (btn && !['submitted','executing','partially_filled'].includes(String(rec.status||'').toLowerCase())) {
                    btn.remove();
                  }
                }
              }
            }

            const rows = await loadPreviewRows(forDate);
            renderIntentsTable(rows);
            const placedNow = await loadPlaced24h();
            renderPlaced(placedNow);

            // Only consider rows we actually placed (submitted/executing/partial/etc.)
            // Prefer the exact submitted ids if we have them.
            const watchingIds = (window._lastSubmittedIds && window._lastSubmittedIds.length)
              ? window._lastSubmittedIds.map(String)
              : null;

            const relevant = rows.filter(r => {
              const s = String(r.status || '').toLowerCase();
              const isPlacedState = ['submitted','executing','partially_filled','filled','cancelled','error','skipped'].includes(s);
              if (watchingIds) return watchingIds.includes(String(r.intent_id));
              // fallback: if we didn’t capture ids, at least ignore pure previews
              return isPlacedState || r.exchange_order_id;
            });

            const allDone = relevant.length > 0 && relevant.every(r =>
              ['filled','cancelled','error','skipped'].includes(String(r.status || '').toLowerCase())
            );

            statusEl.textContent = allDone ? 'Done' : 'Still working…';
            if (allDone) break;

            await new Promise(r => setTimeout(r, delay));
            // background tabs get throttled—don’t let delay explode forever
            delay = Math.min(maxDelay, delay * 2);
          }

          _polling = false;
          window._valrPollState.polling = false;
        }

        // bind resume-on-focus/visibility exactly once per page
        if (!window._valrPollResumeBound) {
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && !window._valrPollState.polling && window._valrPollState.lastPollBody) {
              window._valrPollState.resume?.();
            }
          });
          window.addEventListener('focus', () => {
            if (!window._valrPollState.polling && window._valrPollState.lastPollBody) {
              window._valrPollState.resume?.();
            }
          });
          window._valrPollResumeBound = true;
        }

        // also resume after a TOKEN_REFRESHED / SIGNED_IN event
        if (!window._valrAuthResumeBound && window.supabaseClient?.auth?.onAuthStateChange) {
          try {
            window.supabaseClient.auth.onAuthStateChange((event) => {
              if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN')
                  && !window._valrPollState.polling
                  && window._valrPollState.lastPollBody) {
                window._valrPollState.resume?.();
              }
            });
          } catch {}
          window._valrAuthResumeBound = true;
        }

        // start the first loop
        pollLoop();

      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Error: ' + (e?.message || e);
        executeBtn.disabled = false;
        previewBtn.disabled  = false;
      }
    });
  });
  </script>
  <!-- ANCHOR: Real Orders (VALR) JS END -->

  <!-- ANCHOR: Balance Maintenance JS START -->
  <script>
  (() => {
    // ----- helpers -----
    const sb = () => {
      const c = window.supabaseClient;
      if (!c) throw new Error('Supabase not ready');
      return c;
    };
    async function untilSupabase(timeoutMs = 8000) {
      const start = Date.now();
      while (!window.supabaseClient) {
        await new Promise(r => setTimeout(r, 50));
        if (Date.now() - start > timeoutMs) throw new Error('Supabase not ready (timeout)');
      }
    }
    const $  = (s,root=document) => root.querySelector(s);
    const $$ = (s,root=document) => Array.from(root.querySelectorAll(s));

    function yyyymmChoices(fromIso) {
      // Only: current month and next month (UTC)
      const base = fromIso ? new Date(fromIso + 'T00:00:00Z') : new Date();
      const curr = new Date(Date.UTC(base.getUTCFullYear(), base.getUTCMonth(), 1));
      const next = new Date(Date.UTC(base.getUTCFullYear(), base.getUTCMonth() + 1, 1));

      const toOpt = (d, isCurrent=false) => {
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, '0');
        return { value: `${y}-${m}`, label: `${y}-${m}${isCurrent ? ' (current)' : ''}` };
      };

      return [toOpt(curr, true), toOpt(next, false)];
    }

    function fillMonthSelect(sel, iso) {
      sel.innerHTML = yyyymmChoices(iso).map(o=>`<option value="${o.value}">${o.label}</option>`).join('');
    }

    const normalizeDay = s => (s ? s.replace(/\//g, '-') : null);

    // ----- elements -----
    const mod = document.getElementById('balance-maintenance-module');
    if (!mod) return;

    // helper for consistent number formatting
    const fmt = (n, d = 6) => (n == null ? 0 : +n).toFixed(d);

    const ctxCustomerSel = document.getElementById('customerSelect');
    function getContextCustomerId(){
      const v = ctxCustomerSel ? (ctxCustomerSel.value || '') : '';
      return Number(v || 0);
    }

    const dFrom = $('#retFrom', mod);
    const dTo   = $('#retTo', mod);
    const bSync = $('#retSyncBtn', mod);
    const bLoad = $('#retLoadBtn', mod);
    const bAlloc= $('#retAllocBtn', mod);
    const onlyU = $('#retOnlyUnalloc', mod);
    const month = $('#retAllocMonth', mod);
    const status= $('#retStatus', mod);
    const wrap  = $('#retWrap', mod);
    const tbody = $('#retBody', mod);
    const chkAll= $('#retCheckAll', mod);
    const bDrift = $('#retDriftBtn', mod);
    const driftWrap = $('#retDriftWrap', mod);
    const driftBody = $('#retDriftBody', mod);


    // set defaults
    (function initDates(){
      const today = new Date();
      const iso = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate())).toISOString().slice(0,10);
      dFrom.value = iso; dTo.value = iso;
      fillMonthSelect(month, iso);
    })();

    function paintRows(rows){
      if (!rows || !rows.length) {
        wrap.style.display='block';
        tbody.innerHTML = `<tr><td colspan="13" style="padding:.7rem;color:#6b7280;text-align:center">No rows.</td></tr>`;
        chkAll.checked = false;
        month.disabled = true; bAlloc.disabled = true;
        return;
      }
      wrap.style.display='block';
      tbody.innerHTML = rows.map(r=>{
        const fee = r['fee currency'] ? `${r['fee value']} ${r['fee currency']}` : '';
        const price = r['trade price']!=null ? `${r['trade price']} ${r['trade price currency']||''}` : '';
        const isDep = r.classification==='USDT_DEPOSIT';
        const alloc = r.allocated_month ? r.allocated_month : (isDep ? '—' : '');
        const canSelect = isDep && !r.allocated_month;
        return `<tr data-id="${r.real_tx_id}">
          <td style="text-align:left;padding:6px;">${String(r.date).slice(0,19).replace('T',' ')}</td>
          <td>${r['transaction type']||''}</td>
          <td>${r['trade currency pair']||''}</td>
          <td>${r['debit currency']||''}</td>
          <td>${Number(r['debit value']||0)}</td>
          <td>${r['credit currency']||''}</td>
          <td>${Number(r['credit value']||0)}</td>
          <td>${fee}</td>
          <td>${price}</td>
          <td>${r['order id']||''}</td>
          <td>${r.classification||''}</td>
          <td>${alloc}</td>
          <td>${canSelect?'<input type="checkbox" class="retRowChk">':''}</td>
        </tr>`;
      }).join('');
      enableAllocUI();
    }

    function enableAllocUI(){
      const anySelectable = !!$('.retRowChk', tbody);
      const anyChecked = $$('.retRowChk:checked', tbody).length>0;
      month.disabled = !anySelectable;
      bAlloc.disabled = !anyChecked;
      chkAll.checked = anySelectable && $$('.retRowChk', tbody).every(x=>x.checked);
    }

    tbody.addEventListener('change', (e)=>{
      if (e.target.matches('.retRowChk')) enableAllocUI();
    });
    chkAll.addEventListener('change', ()=>{
      $$('.retRowChk', tbody).forEach(x=>x.checked = chkAll.checked);
      enableAllocUI();
    });

    async function loadFromDb() {
      const cid = getContextCustomerId();
      if (!cid) return alert('Select a customer in the top context bar');
      status.textContent = 'Loading…';
      const { data, error } = await sb().functions.invoke('real-txs-extract', {
        body: { customer_id: cid, from: normalizeDay(dFrom.value), to: normalizeDay(dTo.value), only_unallocated_deposits: !!onlyU.checked }
      });
      if (error || data?.error) {
        status.textContent = 'Error';
        alert(data?.error || error?.message || 'Load failed');
        return;
      }
      paintRows(data.rows||[]);
      status.textContent = 'Ready';
    }

    async function loadDrift() {
      const cid = getContextCustomerId();
      if (!cid) return alert('Select a customer in the top context bar');
      status.textContent = 'Loading drift…';
      driftWrap.style.display = 'block';
      driftBody.innerHTML = `<tr><td colspan="10" style="padding:.7rem;color:#6b7280;text-align:center">Loading…</td></tr>`;
      const { data, error } = await sb().from('real_balance_drift')
        .select('*')
        .eq('customer_id', cid)
        .gte('day', (normalizeDay(dFrom.value)||'1970-01-01'))
        .lte('day', (normalizeDay(dTo.value)||'2999-12-31'))
        .order('day', { ascending: true });
      if (error) {
        status.textContent = 'Error';
        driftBody.innerHTML = `<tr><td colspan="10" style="padding:.7rem;color:#b91c1c;text-align:center">${error.message}</td></tr>`;
        return;
      }
      const rows = data || [];
      if (!rows.length) {
        driftBody.innerHTML = `<tr><td colspan="10" style="padding:.7rem;color:#6b7280;text-align:center">No drift rows in range.</td></tr>`;
      } else {
        driftBody.innerHTML = (data || []).map(r => `
          <tr>
          <td style="text-align:left;padding:6px;">${String(r.day).slice(0,10)}</td>

          <td>${fmt(r.obs_usdt_delta, 6)}</td>
          <td>${fmt(r.exp_usdt_delta, 6)}</td>
          <td style="font-weight:600;">${fmt(r.drift_usdt ?? ((+r.obs_usdt_delta || 0) - (+r.exp_usdt_delta || 0)), 6)}</td>

          <td>${fmt(r.obs_btc_delta, 8)}</td>
          <td>${fmt(r.exp_btc_delta, 8)}</td>
          <td style="font-weight:600;">${fmt(r.drift_btc ?? ((+r.obs_btc_delta || 0) - (+r.exp_btc_delta || 0)), 8)}</td>

          <td>${fmt(r.obs_zar_delta, 2)}</td>
          <td>${fmt(r.exp_zar_delta, 2)}</td>
          <td style="font-weight:600;">${fmt(r.drift_zar ?? ((+r.obs_zar_delta || 0) - (+r.exp_zar_delta || 0)), 2)}</td>
        </tr>
      `).join('');

      }
      status.textContent = 'Ready';
    }

    bLoad.addEventListener('click', loadFromDb);

    bSync.addEventListener('click', async ()=>{
      const cid = getContextCustomerId();
      if (!cid) return alert('Select a customer in the top context bar');
      status.textContent = 'Syncing…';
      bSync.disabled = true; bLoad.disabled = true;
      try{
        const { data, error } = await sb().functions.invoke('real-txs-sync-valr', {
          body: { customer_id: cid, from: normalizeDay(dFrom.value), to: normalizeDay(dTo.value) }
        });
        if (error || data?.error) throw new Error(data?.error || error?.message);
        status.textContent = `Synced — inserted ${data.inserted||0}`;
        await loadFromDb();
      }catch(e){
        status.textContent = 'Error';
        alert(e?.message || e);
      }finally{
        bSync.disabled = false; bLoad.disabled = false;
      }
    });

    bAlloc.addEventListener('click', async ()=>{
      const ids = $$('.retRowChk:checked', tbody)
        .map(chk => chk.closest('tr')?.getAttribute('data-id'))
        .filter(Boolean);
      if (!ids.length) return;
      const m = month.value;
      if (!m) return alert('Pick allocation month');
      bAlloc.disabled = true;
      status.textContent = 'Allocating…';
      try{
        const { data, error } = await sb().functions.invoke('real-txs-allocate-deposits', {
          body: { tx_ids: ids, allocate_to_month: m }
        });
        if (error || data?.error) throw new Error(data?.error || error?.message);
        status.textContent = `Allocated ${data.updated||0} deposit(s) to ${m}`;
        await loadFromDb();
      }catch(e){
        status.textContent = 'Error';
        alert(e?.message || e);
      }finally{
        bAlloc.disabled = false;
      }
    });

    onlyU.addEventListener('change', loadFromDb);
    bDrift.addEventListener('click', loadDrift);

    // ----- LTH PVR – Ledger & Balances -----
    (function initLthLedgerBalances(){
      const from   = $('#lthFrom', mod);
      const to     = $('#lthTo', mod);
      const btn    = $('#lthLoadBtn', mod);
      const recalc = $('#lthRecalcBtn', mod);
      const status = $('#lthStatus', mod);
      const wrap   = $('#lthTableWrap', mod);
      const body   = $('#lthBody', mod);

      if (!from || !to || !btn || !status || !wrap || !body) return;

      // Default dates: today (UTC), but don’t overwrite if user already picked something
      (function initLthDates(){
        const today = new Date();
        const iso = new Date(Date.UTC(
          today.getUTCFullYear(),
          today.getUTCMonth(),
          today.getUTCDate()
        )).toISOString().slice(0,10);
        if (!from.value) from.value = iso;
        if (!to.value)   to.value   = iso;
      })();

      function ensureLthContext(){
        const sel = document.getElementById('portfolioSelect');
        if (!sel){
          alert('Select an LTH PVR portfolio / strategy in the top context bar first.');
          return false;
        }

        const pid = sel.value || null;
        const opt = sel.selectedIndex >= 0 ? sel.options[sel.selectedIndex] : null;

        const code = (opt?.getAttribute('data-strategy-code') || window.currentStrategyCode || '')
          .toString()
          .trim()
          .toUpperCase();

        if (!pid || !code || code !== 'LTH_PVR'){
          alert('Select an LTH PVR portfolio / strategy in the top context bar first.');
          return false;
        }

        // keep globals in sync with the actual selection
        window.currentPortfolioId = pid;
        window.currentStrategyCode = code;

        return true;
      }

      function paintLthRows(rows){
        const r = Array.isArray(rows) ? rows : [];
        if (!r.length){
          wrap.style.display = 'block';
          body.innerHTML =
            '<tr><td colspan="5" style="padding:.7rem;color:#6b7280;text-align:center">No rows in range.</td></tr>';
          return;
        }
        wrap.style.display = 'block';
        body.innerHTML = r.map(ev => {
          const dt  = ev.event_date || ev.date || ev.day || ev.tx_date || '';
          const typ = ev.event_type || ev.kind || ev.source || '';
          const btc = ev.btc_delta ?? ev.btc_change ?? ev.delta_btc ?? ev.btc ?? 0;
          const usd = ev.usdt_delta ?? ev.usd_delta ?? ev.delta_usd ?? ev.usdt ?? ev.usd ?? 0;
          const note= ev.note || ev.description || ev.label || '';
          return `<tr>
            <td style="text-align:left;padding:6px;">${String(dt).slice(0,19).replace('T',' ')}</td>
            <td>${typ}</td>
            <td style="text-align:right;">${fmt(btc, 8)}</td>
            <td style="text-align:right;">${fmt(usd, 2)}</td>
            <td>${note}</td>
          </tr>`;
        }).join('');
      }

      async function loadLthFromDb(){
        if (!ensureLthContext()) return;
        await untilSupabase();

        const portfolioId = window.currentPortfolioId;
        const fromDate = normalizeDay(from.value) || null;
        const toDate   = normalizeDay(to.value)   || null;

        status.textContent = 'Loading…';
        btn.disabled = true;

        try{
          // Expects a Postgres RPC that returns rows with:
          //   event_date, event_type, btc_delta, usdt_delta, note
          const { data, error } = await sb().rpc('lth_pvr_list_ledger_and_balances', {
            portfolio_id: portfolioId,
            from_date: fromDate,
            to_date: toDate
          });
          if (error) throw error;
          const rows = (data && (data.rows || data)) || [];
          paintLthRows(rows);
          status.textContent = `Loaded ${rows.length} row${rows.length===1 ? '' : 's'}`;
        }catch(e){
          console.error(e);
          status.textContent = 'Error';
          alert(e?.message || e);
        }finally{
          btn.disabled = false;
        }
      }

      async function recalcLthBalances(){
        if (!ensureLthContext()) return;
        await untilSupabase();

        const portfolioId = window.currentPortfolioId;

        status.textContent = 'Recalculating…';
        if (recalc) recalc.disabled = true;

        try{
          // Calls your existing Edge Function that rebuilds ledger_lines + balances_daily
          const { data, error } = await sb().functions.invoke('ef_post_ledger_and_balances', {
            body: {
              portfolio_id: portfolioId,
              from: normalizeDay(from.value) || null,
              to: normalizeDay(to.value) || null
            }
          });
          if (error || data?.error) throw new Error(data?.error || error?.message);
          status.textContent = 'Recalculated — reloading…';
          await loadLthFromDb();
        }catch(e){
          console.error(e);
          status.textContent = 'Error';
          alert(e?.message || e);
        }finally{
          if (recalc) recalc.disabled = false;
        }
      }

      btn.addEventListener('click', loadLthFromDb);
      if (recalc) recalc.addEventListener('click', recalcLthBalances);
    })();

  })();
  </script>
  <!-- ANCHOR: Balance Maintenance JS END -->

    <!-- ===================== Portfolio Performance Reporting ===================== -->
    <div id="reports-module" class="module">
      <h2>Portfolio Performance Reporting</h2>
      <div id="reportsError"></div>

      <div class="reports-controls-outer">
        <div class="reports-controls">
          <label for="reportTypeSelect"><strong>Report type:</strong></label>
          <select id="reportTypeSelect">
            <option value="holdings" selected>Portfolio Holdings</option>
            <option value="comp_value">Comparison - Portfolio Value</option>
            <option value="comp_roi">Comparison - ROI</option>
            <option value="comp_agr">Comparison - Annualised Growth</option>
          </select>
        </div>
      </div>

      <div class="card">
        <h3 id="reportTitle" class="chart-title"></h3>

        <div class="chart-toolbar">
          <button id="showAllBtn" type="button">Show all</button>
          <button id="hideAllBtn" type="button">Hide all</button>
        </div>

        <div id="chartNotice" class="chart-notice"></div>
        <canvas id="perfChart" height="120"></canvas>

        <div id="chartRange" class="chart-range">
          <div class="sliders">
            <input id="rangeStart" type="range" min="0" max="1" value="0">
            <input id="rangeEnd" type="range" min="0" max="1" value="1">
          </div>
          <div class="labels">
            <span id="rangeStartLabel"></span>
            <span id="rangeEndLabel"></span>
          </div>
        </div>

        <div id="chartFooter" class="chart-footer"></div>

        <div class="chart-actions">
          <button id="resetZoomBtn" type="button" disabled>Reset Zoom</button>
        </div>
        <!-- Table renders here under the chart -->
        <section id="report-tables" class="report-tables-wrapper"></section>

        <!-- AI narrative appears here -->
        <div id="chartNarrative"></div>

        <!-- Export button -->
        <div class="chart-actions" style="margin-top:10px">
          <button id="exportPdfBtn" type="button">Export Customer Charts to PDF</button>
        </div>
      </div>
    </div>

    <div id="backtest-module" class="module">
      <h2>Strategy Back-Testing</h2>

      <div id="btReportsError"></div>

      <div class="reports-controls-outer">
        <div class="reports-controls">
          <!-- Strategy selector -->
          <label for="btStrategySelect"><strong>Strategy:</strong></label>
          <select id="btStrategySelect">
            <option value="LTH_PVR" selected>LTH PVR BTC DCA (current strategy)</option>
            <option value="ADV_DCA" disabled>Advanced BTC DCA (coming soon)</option>
          </select>

          <!-- Dates -->
          <label for="btStartDate"><strong>Start Date:</strong></label>
          <input id="btStartDate" type="date">

          <label for="btEndDate"><strong>End Date:</strong></label>
          <input id="btEndDate" type="date">

          <!-- Contributions -->
          <label for="btUpfrontUsdt"><strong>Upfront USDT contribution:</strong></label>
          <input id="btUpfrontUsdt" type="number" min="0" step="0.01" value="0">

          <label for="btMonthlyUsdt"><strong>Monthly USDT contribution:</strong></label>
          <input id="btMonthlyUsdt" type="number" min="0" step="0.01" value="30">

          <!-- Fees -->
          <label for="btBtcFeePct"><strong>BTCUSDT Fee %:</strong></label>
          <input id="btBtcFeePct" type="number" min="0" step="0.01" value="0.08">

          <label for="btContribFeePct"><strong>USDT Contribution Fee %:</strong></label>
          <input id="btContribFeePct" type="number" min="0" step="0.01" value="0.18">

          <!-- Chart type -->
          <label for="btReportTypeSelect"><strong>Chart type:</strong></label>
          <select id="btReportTypeSelect">
            <option value="holdings" selected>Back-test holdings</option>
            <option value="comp_value">Comparison – Portfolio Value</option>
            <option value="comp_roi">Comparison – ROI</option>
            <option value="comp_agr">Comparison – Annualised Growth</option>
          </select>

          <!-- Actions / messages -->
          <div class="bt-form-actions">
            <button id="btRunBtn" type="button">Run back-test</button>
            <div id="btInlineError" class="inline-error"></div>
            <div id="btStrategyNote" class="bt-note">
              Advanced BTC DCA back-testing is coming soon. Currently only the LTH PVR BTC DCA strategy is available.
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3 id="btReportTitle" class="chart-title"></h3>

        <div class="chart-toolbar">
          <button id="btShowAllBtn" type="button">Show all</button>
          <button id="btHideAllBtn" type="button">Hide all</button>
        </div>

        <div id="btChartNotice" class="chart-notice"></div>
        <canvas id="btPerfChart" height="120"></canvas>

        <div id="btChartRange" class="chart-range">
          <div class="sliders">
            <input id="btRangeStart" type="range" min="0" max="1" value="0">
            <input id="btRangeEnd" type="range" min="0" max="1" value="1">
          </div>
          <div class="labels">
            <span id="btRangeStartLabel"></span>
            <span id="btRangeEndLabel"></span>
          </div>
        </div>

        <div id="btChartFooter" class="chart-footer"></div>

        <div class="chart-actions">
          <button id="btResetZoomBtn" type="button" disabled>Reset Zoom</button>
        </div>

        <!-- Table renders here under the chart -->
        <section id="btReportTables" class="report-tables-wrapper">
          <table class="report-table">
            <tbody id="btYearlyTable">
              <!-- Filled dynamically by renderBtPerformanceTable(btRunId, ...) -->
            </tbody>
          </table>
        </section>

        <!-- AI narrative appears here -->
        <div id="btChartNarrative"></div>

        <!-- Export button -->
        <div class="chart-actions" style="margin-top:10px">
          <button id="btExportPdfBtn" type="button">Export Customer Charts to PDF</button>
        </div>
      </div>
    </div>

    <div id="finance-module" class="module">
      <h2>Finance</h2><p>This module is under construction.</p>
    </div>
    
    <!-- ===================== Administration (owner-only) ===================== -->
    <div id="admin-module" class="module">
      <h2>Administration</h2>

      <!-- Sign-in card (shown until you sign in as the admin email) -->
      <div id="adminAuthCard" class="card" style="max-width:980px;">
        <h3>Sign in as Administrator</h3>
        <p class="small muted">Use the same email/password you created in <em>Supabase → Authentication → Users</em>.</p>
      <form id="adminLoginForm" onsubmit="return false;">   <!-- cancel native submit -->
        <label>Email <input id="adminEmail" type="email" required /></label>
        <label>Password <input id="adminPassword" type="password" required /></label>
        <button id="adminSignInBtn" type="button">Sign in</button>
      </form>
      </div>

      <!-- Admin app (only visible to the configured admin email) -->
      <div id="adminApp" class="card" style="display:none;max-width:1200px;">
        <div style="display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;">
          <strong>Organisation:</strong>
          <select id="adminOrgSelect"></select>
          <button id="adminRefresh" type="button">Refresh</button>
          <div style="margin-left:auto;display:flex;gap:.5rem;">
            <span id="adminSignedInAs" style="opacity:.7;"></span>
            <button id="adminSignOut" type="button">Sign out</button>
          </div>
        </div>

        <hr style="margin:1rem 0;">

        <h3>Add / Update Employee</h3>
        <form id="adminAddForm" style="display:flex;gap:.5rem;flex-wrap:wrap;align-items:end;">
          <label>Email <input id="adminAddEmail" type="email" required /></label>
          <label>Role
            <select id="adminAddRole">
              <option value="viewer">viewer</option>
              <option value="editor">editor</option>
              <option value="admin">admin</option>
            </select>
          </label>
          <label>Temp password
            <input id="adminAddPassword" type="text" placeholder="auto-generate if blank" />
          </label>
          <button type="submit">Add / Update</button>
        </form>

        <h3 style="margin-top:1rem;">Employees</h3>
        <table id="adminMembersTable">
          <thead><tr><th>Email</th><th>Role</th><th>Added</th><th></th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </main>

  <script>
    /* ---------- Helpers ---------- */
    function showInlineError(id,msg){const el=document.getElementById(id);el.textContent=msg;el.style.display='block';}
    function clearInlineError(id){const el=document.getElementById(id);el.textContent='';el.style.display='none';}
    function cssVar(n){return getComputedStyle(document.documentElement).getPropertyValue(n).trim();}

    const hasSupabase=typeof window.supabase!=='undefined';
    const hasPapa=typeof window.Papa!=='undefined';
    const hasChart=typeof window.Chart!=='undefined';
    if(!hasSupabase) showInlineError('inlineError','Supabase library did not load.');
    if(!hasPapa)     showInlineError('inlineError','CSV parser (PapaParse) did not load.');
    if(!hasChart)    showInlineError('reportsError','Chart.js did not load.');

    /* ---------- Supabase ---------- */
    let supabaseClient = null;
    if (hasSupabase) {
      const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indxbm14cG9vYWJtZWR2dGFja2ppIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQwNTY3OTksImV4cCI6MjA2OTYzMjc5OX0.kiNGXtYrUoeud-rKav-o2Vs5x7BZdgG_GVF6MLWE-zs';

      try {
        supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        window.supabaseClient = supabaseClient; // expose globally for Admin module
      } catch (e) {
        console.error(e);
        showInlineError('reportsError','Could not initialize Supabase client.');
      }
    }

    /* ---------- Utils ---------- */
    function normalizeDate(val){
      const s = String(val ?? "").trim();
      if (!s) return "";

      // 1) YYYY-MM-DD or YYYY/MM/DD → always return with hyphens
      let m = s.match(/^(\d{4})[-/](\d{2})[-/](\d{2})$/);
      if (m) return `${m[1]}-${m[2]}-${m[3]}`;

      // 2) yyyymmdd (compact)
      m = s.match(/^(\d{4})(\d{2})(\d{2})$/);
      if (m) return `${m[1]}-${m[2]}-${m[3]}`;

      // 3) Excel serial number (days since 1899-12-30)
      if (/^\d+$/.test(s)) {
        const serial = Number(s);
        if (Number.isFinite(serial) && serial >= 25569) {
          const ms = (serial - 25569) * 86400000;
          const d = new Date(ms);              // treat as local-day, not UTC
          const y = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${y}-${mm}-${dd}`;
        }
      }

      // 4) Fallback: parse as LOCAL (avoid UTC toISOString shifts); normalize separators
      const guess = new Date(s.replace(/\//g, "-"));
      if (!isNaN(guess)) {
        const y = guess.getFullYear();
        const mm = String(guess.getMonth() + 1).padStart(2, "0");
        const dd = String(guess.getDate()).padStart(2, "0");
        return `${y}-${mm}-${dd}`;
      }

      // Last resort: return first 10 chars (keeps already-correct values)
      return s.slice(0, 10);
    }

    function numOrNull(v){if(v==null||v==='')return null;const n=Number(String(v).trim());return Number.isFinite(n)?n:null;}
    const FMT_USD=new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
    function pctText(v){ const n = Number(v ?? 0); return (n * 100).toFixed(2) + '%'; }
    function btcText(v){if(v==null){v=0;}return v.toLocaleString('en-US',{maximumFractionDigits:8})+' BTC';}
    function $footer(){return document.getElementById('chartFooter');}
    function clearChartFooter(){const el=$footer();if(el){el.innerHTML='';el.style.display='none';}}
    function setChartFooter(entries){
      const el=$footer(); if(!el) return;
      el.innerHTML='';
      if(!entries||!entries.length){el.style.display='none';return;}
      el.style.display='flex';
      entries.forEach(e=>{
        const b=document.createElement('div'); b.className='badge';
        const d=document.createElement('span'); d.className='dot'; d.style.backgroundColor=e.color||'#ccc';
        const t=document.createElement('span'); t.textContent=e.label+': '+e.value;
        const s=document.createElement('small'); s.textContent=e.date?(' ('+e.date+')'):'';
        b.appendChild(d); b.appendChild(t); b.appendChild(s); el.appendChild(b);
      });
    }
    function lastIndexNonNullInRange(arr,start,end){for(let i=end;i>=start;i--){const v=arr[i];if(v!==null&&v!==undefined&&!Number.isNaN(v))return i;}return-1;}

    /* ---------- Date slider ---------- */
    let chartInstance=null,currentLabels=[];
    const rangeWrap=()=>document.getElementById('chartRange');
    const rangeStartEl=()=>document.getElementById('rangeStart');
    const rangeEndEl=()=>document.getElementById('rangeEnd');
    const rangeStartLbl=()=>document.getElementById('rangeStartLabel');
    const rangeEndLbl=()=>document.getElementById('rangeEndLabel');
    function showRange(show){const el=rangeWrap();if(el)el.style.display=show?'block':'none';}
    function updateRangeUI(s,e){if(!currentLabels.length)return;rangeStartLbl().textContent=currentLabels[s]||'';rangeEndLbl().textContent=currentLabels[e]||'';}
    function applyRangeToChart(s,e){if(!chartInstance)return;chartInstance.options.scales.x.min=s;chartInstance.options.scales.x.max=e;chartInstance.update('none');rebuildFooterForChart(chartInstance);}
    function resetRangeToFull(){if(!currentLabels.length)return;const s=rangeStartEl(),e=rangeEndEl();s.value=0;e.value=currentLabels.length-1;updateRangeUI(0,currentLabels.length-1);applyRangeToChart(0,currentLabels.length-1);}
    function initOrUpdateRange(labels){
      currentLabels=labels||[];
      const s=rangeStartEl(),e=rangeEndEl(); if(!s||!e) return;
      if(currentLabels.length<=1){showRange(false);return;}
      s.min=0; e.min=0; s.max=currentLabels.length-1; e.max=currentLabels.length-1; s.value=0; e.value=currentLabels.length-1;
      showRange(true); updateRangeUI(0,currentLabels.length-1);
      if(!s._bound){ s.addEventListener('input',()=>{let sv=Number(s.value),ev=Number(e.value); if(sv>ev){ev=sv;e.value=ev;} updateRangeUI(sv,ev); applyRangeToChart(sv,ev);}); s._bound=true;}
      if(!e._bound){ e.addEventListener('input',()=>{let sv=Number(s.value),ev=Number(e.value); if(ev<sv){sv=ev;s.value=sv;} updateRangeUI(sv,ev); applyRangeToChart(sv,ev);}); e._bound=true;}
      applyRangeToChart(0,currentLabels.length-1);
    }

    /* ---------- Import logic ---------- */
    let existingDates=new Set(),previewRows=[];
    async function loadExistingDates(){
      if(!supabaseClient){return;}
      const res=await supabaseClient.from('daily_data').select('date_closing');
      if(res.error){console.error(res.error);showInlineError('inlineError','Error loading existing dates: '+res.error.message);return;}
      existingDates=new Set(res.data.map(r=>normalizeDate(r.date_closing)));
    }
    function renderPreview(){
      const c=document.getElementById('preview'); c.innerHTML='';
      const headers=['#','date_closing','btc_closing_price_usd','smoothed_risk_score','omega_score','omega_on_off','sab_below_neg_1sd','sab_below_neg_2sd','Status'];
      const t=document.createElement('table'); const th=t.createTHead().insertRow(); headers.forEach(h=>th.insertCell().textContent=h);
      const tb=t.createTBody();
      previewRows.forEach(r=>{
        const tr=tb.insertRow();
        headers.forEach(h=>{
          const td=tr.insertCell();
          if(h==='#') td.textContent=r.index;
          else if(h==='Status'){ td.textContent=r.isDuplicate?'Duplicate (skip)':'Ready'; td.className=r.isDuplicate?'status-duplicate':'status-ready'; }
          else td.textContent=r[h]||'';
        });
      });
      c.appendChild(t);
      document.getElementById('importBtn').style.display=previewRows.length?'inline-block':'none';
      document.getElementById('report').innerHTML='';
    }
    async function importRows(){
      if(!window.supabaseClient){ showInlineError('inlineError','Supabase not available.'); return; }
      function toBool(v){ if(typeof v==='boolean')return v; const s=String(v==null?'':v).trim().toLowerCase(); return s==='true'||s==='1'||s==='yes'||s==='y'; }
      clearInlineError('inlineError');

      const guard=new Set(existingDates); const finalRows=[];
      previewRows.forEach(r=>{ const d=normalizeDate(r.date_closing); if(!guard.has(d)){ guard.add(d); finalRows.push(r);} });

      const toInsert=finalRows.map(r=>({
        date_closing:normalizeDate(r.date_closing),
        btc_closing_price_usd:numOrNull(r.btc_closing_price_usd),
        smoothed_risk_score:numOrNull(r.smoothed_risk_score),
        omega_score:numOrNull(r.omega_score),
        omega_on_off:toBool(r.omega_on_off),
        sab_below_neg_1sd:numOrNull(r.sab_below_neg_1sd),
        sab_below_neg_2sd:numOrNull(r.sab_below_neg_2sd)
      }));

      const rep=document.getElementById('report'); rep.textContent='Importing…';
      const up=await supabaseClient.from('daily_data')
        .upsert(toInsert, { onConflict:'date_closing', ignoreDuplicates:true })
        .select('date_closing'); // return inserted rows so we can count them
      let html='';
      if(up.error){
        html+='<p style="color:red;">Error: '+up.error.message+'</p>';
      }else{
        const inserted = Array.isArray(up.data) ? up.data.length : 0;
        const skippedClient=previewRows.filter(r=>r.isDuplicate).length;
        const attempted=toInsert.length;
        html+='<p style="color:green;">Inserted '+inserted+' new row'+(inserted!==1?'s':'')+'.</p>';
        html+='<p>Client-side skipped '+skippedClient+' duplicate row'+(skippedClient!==1?'s':'')+'.</p>';
        html+='<p>Ignored by DB (conflict) '+Math.max(0,attempted-inserted)+' row'+((attempted-inserted)!==1?'s':'')+'.</p>';
        await loadExistingDates();
      }
      rep.innerHTML=html;
      document.getElementById('importBtn').style.display='none';
    }

    /* ---------- Reports state & charts ---------- */
    /* ---------- Back-Testing (bt*) state & charts (cloned) ---------- */
    let btCurrentRunId = null;      // latest bt_run_id from ef_bt_execute
    let btAdvData = null;           // LTH PVR results: lth_pvr_bt.bt_results_daily
    let btStdData = null;           // Standard DCA results: lth_pvr_bt.bt_std_dca_balances
    let btCurrentReportType = 'holdings';
    let btChartInstance = null;

    function btDestroyChart() {
      // Destroy our tracked instance
      try {
        if (btChartInstance && typeof btChartInstance.destroy === 'function') {
          btChartInstance.destroy();
        }
      } catch (e) {
        console.warn('btDestroyChart: error destroying btChartInstance', e);
      }
      btChartInstance = null;

      // Extra safety: also destroy any chart still registered on this canvas
      try {
        if (window.Chart) {
          const canvas = document.getElementById('btPerfChart');
          if (canvas && typeof Chart.getChart === 'function') {
            const existing = Chart.getChart(canvas) || Chart.getChart('btPerfChart');
            if (existing && typeof existing.destroy === 'function') {
              existing.destroy();
            }
          }
        }
      } catch (e) {
        console.warn('btDestroyChart: error destroying registry chart', e);
      }
    }

    function btSetChartFooter(entries){
      const el = document.getElementById('btChartFooter');
      if (!el) return;
      el.innerHTML = '';
      if (!entries || !entries.length){ el.style.display='none'; return; }
      el.style.display='flex';
      entries.forEach(e=>{
        const b=document.createElement('div'); b.className='badge';
        const d=document.createElement('span'); d.className='dot'; d.style.backgroundColor=e.color||'#ccc';
        const t=document.createElement('span'); t.textContent=`${e.label}: ${e.value}`;
        const s=document.createElement('small'); s.textContent=e.date?(' ('+e.date+')'):'';
        b.appendChild(d); b.appendChild(t); b.appendChild(s); el.appendChild(b);
      });
    }

    function btApplyRangeToChart(s,e){
      if(!btChartInstance) return;
      btChartInstance.options.scales.x.min = s;
      btChartInstance.options.scales.x.max = e;
      btChartInstance.update('none');
      btRebuildFooterForChart(btChartInstance);
    }

    function btInitOrUpdateRange(labels){
      const wrap = document.getElementById('btChartRange');
      const s = document.getElementById('btRangeStart');
      const e = document.getElementById('btRangeEnd');
      if (!wrap || !s || !e) return;
      if (!labels || labels.length <= 1){ wrap.style.display='none'; return; }
      wrap.style.display='block';

      s.min=0; e.min=0; s.max=labels.length-1; e.max=labels.length-1;
      s.value=0; e.value=labels.length-1;

      const lbS = document.getElementById('btRangeStartLabel');
      const lbE = document.getElementById('btRangeEndLabel');
      const updateLabels = () => {
        if(lbS) lbS.textContent = labels[Number(s.value)] || '';
        if(lbE) lbE.textContent = labels[Number(e.value)] || '';
      };
      updateLabels();

      if(!s._bound){ s.addEventListener('input', ()=>{ if(+s.value > +e.value){ e.value = s.value; } updateLabels(); btApplyRangeToChart(+s.value,+e.value); }); s._bound=true; }
      if(!e._bound){ e.addEventListener('input', ()=>{ if(+e.value < +s.value){ s.value = e.value; } updateLabels(); btApplyRangeToChart(+s.value,+e.value); }); e._bound=true; }

      btApplyRangeToChart(0, labels.length-1);
    }

    // Simple renderer for the bt* block (mirrors your main one)
    function renderBtReportForCurrentState(){
      const noticeEl = document.getElementById('btChartNotice');
      const titleEl  = document.getElementById('btReportTitle');

      if (!btCurrentRunId){
        btDestroyChart();
        btSetCanvasVisible(false);
        btSetResetZoomEnabled(false);
        btClearChartFooter();
        btShowRange(false);

      if (noticeEl){
        noticeEl.textContent = 'Run a back-test to see results.';
        noticeEl.style.display = 'block';
      }
      if (titleEl) titleEl.textContent = '';
        return;
      }

      if (noticeEl){
        noticeEl.style.display = 'none';
      }
      btSetCanvasVisible(true);

      if (btCurrentReportType === 'holdings'){
        if (!btAdvData || !btAdvData.length){
          btDestroyChart();
          btSetCanvasVisible(false);
          btSetResetZoomEnabled(false);
          btClearChartFooter();
          btShowRange(false);

          if (noticeEl){
            noticeEl.textContent = 'No results found for this back-test run.';
            noticeEl.style.display = 'block';
          }
          if (titleEl) titleEl.textContent = '';
          return;
        }
        renderBtHoldingsChart(btAdvData, btCurrentRunId);
      } else if (btCurrentReportType === 'comp_value'){
        renderBTCompPortfolioValueChart(btAdvData || [], btStdData || [], btCurrentRunId);
      } else if (btCurrentReportType === 'comp_roi'){
        renderBTCompROIChart(btAdvData || [], btStdData || [], btCurrentRunId);
      } else if (btCurrentReportType === 'comp_agr'){
        renderBTCompAGRChart(btAdvData || [], btStdData || [], btCurrentRunId);
      }
    }

    function btSetReportTitle(btRunId){
      const el = document.getElementById('btReportTitle');
      if (!el) return;
      el.textContent = btRunId
        ? `LTH PVR BTC DCA Back-Test (Run #${btRunId})`
        : 'LTH PVR BTC DCA Back-Test';
    }

    function btSetResetZoomEnabled(on){const b=document.getElementById('btResetZoomBtn'); if(b) b.disabled=!on;}
    function btSetCanvasVisible(show){const c=document.getElementById('btPerfChart'); if(c) c.style.display=show?'block':'none';}
    function btShowChartNotice(msg){const n=document.getElementById('btChartNotice'); n.textContent=msg; n.style.display='block';}
    function btHideChartNotice(){const n=document.getElementById('btChartNotice'); n.textContent=''; n.style.display='none';}
    function btClearChartFooter(){const f=document.getElementById('btChartFooter'); if(f) f.innerHTML='';}
    function btShowRange(show){
      const box=document.getElementById('btChartRange');
      if(!box) return; box.style.display=show?'block':'none';
    }

    // --- New BT loaders: read from lth_pvr_bt.bt_results_daily / bt_std_dca_balances ---

    async function loadBtLthPvrResults(btRunId){
      if (!supabaseClient) return { data: [], error: { message: 'Supabase not available' } };
      if (!btRunId)        return { data: [], error: null };

      const btDb = supabaseClient.schema('lth_pvr_bt');
      const pageSize = 1000;
      let lastDate = null;
      let all = [];

      while (true) {
        let q = btDb
          .from('bt_results_daily')
          .select('*')
          .eq('bt_run_id', btRunId)
          .order('trade_date', { ascending: true })
          .limit(pageSize);
        if (lastDate) q = q.gt('trade_date', lastDate);

        const res = await q;
        if (res.error) return { data: all, error: res.error };
        if (!res.data || !res.data.length) break;

        all = all.concat(res.data);
        lastDate = res.data[res.data.length - 1].trade_date;
        if (res.data.length < pageSize) break;
      }
      return { data: all, error: null };
    }

    async function loadBtStdDcaResults(btRunId){
      if (!supabaseClient) return { data: [], error: { message: 'Supabase not available' } };
      if (!btRunId)        return { data: [], error: null };

      const btDb = supabaseClient.schema('lth_pvr_bt');
      const pageSize = 1000;
      let lastDate = null;
      let all = [];

      while (true) {
        let q = btDb
          .from('bt_std_dca_balances')
          .select('*')
          .eq('bt_run_id', btRunId)
          .order('trade_date', { ascending: true })
          .limit(pageSize);
        if (lastDate) q = q.gt('trade_date', lastDate);

        const res = await q;
        if (res.error) return { data: all, error: res.error };
        if (!res.data || !res.data.length) break;

        all = all.concat(res.data);
        lastDate = res.data[res.data.length - 1].trade_date;
        if (res.data.length < pageSize) break;
      }
      return { data: all, error: null };
    }

    // Single entry-point: load data for bt_run_id and refresh chart + table
    async function btLoadAndRenderFromRun(btRunId){
      btCurrentRunId = btRunId;
      btAdvData = null;
      btStdData = null;

      btDestroyChart();
      btSetCanvasVisible(false);
      btSetResetZoomEnabled(false);
      btClearChartFooter();
      btShowRange(false);

      if (!supabaseClient || !btRunId){
        renderBtReportForCurrentState();
        return;
      }

      const errId = 'btReportsError';
      clearInlineError(errId);

      try {
        const [lthRes, stdRes] = await Promise.all([
          loadBtLthPvrResults(btRunId),
          loadBtStdDcaResults(btRunId)
        ]);

        if (lthRes.error) {
          showInlineError(errId, lthRes.error.message || 'Could not load LTH PVR back-test results.');
        }
        if (stdRes.error) {
          showInlineError(errId, stdRes.error.message || 'Could not load Standard DCA back-test results.');
        }

        btAdvData = lthRes.data || [];
        btStdData = stdRes.data || [];

      } catch (e) {
        console.error('Error loading back-test results:', e);
        showInlineError(errId, e.message || 'Error loading back-test results.');
      }

      renderBtReportForCurrentState();
      await renderBtPerformanceTable(btRunId, btCurrentReportType);

      // expose for console debugging if needed
      window.btCurrentRunId = btRunId;
      window.btAdvData = btAdvData;
      window.btStdData = btStdData;
    }

    async function loadBtAdvTransactions(customerId){
      if(!supabaseClient) return {data:[],error:{message:'Supabase not available'}};
      const pageSize=1000; let lastDate=null; let all=[];
      while(true){
        let q=supabaseClient.from('adv_dca_customer_transactions')
          .select('transaction_date, btc_closing_price_usd, total_dca_invested_usd, portfolio_value_usd, closing_balance_usd, closing_balance_btc, total_roi_percent, cagr_percent')
          .eq('customer_id',customerId).order('transaction_date',{ascending:true}).limit(pageSize);
        if(lastDate) q=q.gt('transaction_date', lastDate);
        const res=await q; if(res.error) return {data:all,error:res.error};
        if(!res.data||res.data.length===0) break;
        all=all.concat(res.data); lastDate=res.data[res.data.length-1].transaction_date;
        if(res.data.length<pageSize) break;
      }
      return {data:all,error:null};
    }

    // ===== LTH PVR Back-Testing (bt_runs / bt_params / ef_bt_execute) =====

    function btPctToBps(pctStr){
      if (pctStr === null || pctStr === undefined) return 0;
      const n = parseFloat(String(pctStr).replace(',', '.'));
      if (!isFinite(n)) return 0;
      // 1% = 100 bps, so 0.08% => 8 bps
      return Math.round(n * 100);
    }

    function initBtRunForm(){
      const strategySel   = document.getElementById('btStrategySelect');
      const startEl       = document.getElementById('btStartDate');
      const endEl         = document.getElementById('btEndDate');
      const upfrontEl     = document.getElementById('btUpfrontUsdt');
      const monthlyEl     = document.getElementById('btMonthlyUsdt');
      const tradeFeeEl    = document.getElementById('btBtcFeePct');
      const contribFeeEl  = document.getElementById('btContribFeePct');
      const runBtn        = document.getElementById('btRunBtn');

      // Force strategy to LTH PVR for now (ADV DCA is "coming soon")
      if (strategySel) {
        strategySel.value = 'LTH_PVR';
      }

      // Defaults, only if the user hasn’t already typed something
      if (upfrontEl && !upfrontEl.value)       upfrontEl.value    = '0';
      if (monthlyEl && !monthlyEl.value)       monthlyEl.value    = '30';
      if (tradeFeeEl && !tradeFeeEl.value)     tradeFeeEl.value   = '0.08';
      if (contribFeeEl && !contribFeeEl.value) contribFeeEl.value = '0.18';

      if (runBtn && !runBtn._bound){
        runBtn.addEventListener('click', (e)=>{
          e.preventDefault();
          handleBtRunClick();
        });
        runBtn._bound = true;
      }
    }

    async function handleBtRunClick(){
      const errId = 'btInlineError';
      clearInlineError(errId);

      if (!supabaseClient){
        showInlineError(errId, 'Supabase client not available in this environment.');
        return;
      }

      const strategySel   = document.getElementById('btStrategySelect');
      const startEl       = document.getElementById('btStartDate');
      const endEl         = document.getElementById('btEndDate');
      const upfrontEl     = document.getElementById('btUpfrontUsdt');
      const monthlyEl     = document.getElementById('btMonthlyUsdt');
      const tradeFeeEl    = document.getElementById('btBtcFeePct');
      const contribFeeEl  = document.getElementById('btContribFeePct');
      const runBtn        = document.getElementById('btRunBtn');

      const strategy = strategySel ? (strategySel.value || 'LTH_PVR') : 'LTH_PVR';
      if (strategy !== 'LTH_PVR'){
        showInlineError(errId, 'Only "LTH PVR BTC DCA" is supported right now.');
        return;
      }

      const startDate = startEl && startEl.value ? startEl.value : '';
      const endDate   = endEl   && endEl.value   ? endEl.value   : '';

      if (!startDate || !endDate){
        showInlineError(errId, 'Please select both a Start Date and an End Date.');
        return;
      }

      if (new Date(endDate) <= new Date(startDate)){
        showInlineError(errId, 'End Date must be after Start Date.');
        return;
      }

      const upfront  = upfrontEl  ? (parseFloat(upfrontEl.value || '0')  || 0) : 0;
      const monthly  = monthlyEl  ? (parseFloat(monthlyEl.value || '0')  || 0) : 0;
      const tradePct = tradeFeeEl ? (parseFloat(tradeFeeEl.value || '0') || 0) : 0;
      const contrPct = contribFeeEl ? (parseFloat(contribFeeEl.value || '0') || 0) : 0;

      const maker_bps_trade   = btPctToBps(tradePct);
      const maker_bps_contrib = btPctToBps(contrPct);

      // org_id – try customersCache first, then fall back to my_orgs RPC
      let orgId = null;
      try {
        if (Array.isArray(customersCache) && customersCache.length > 0 && customersCache[0].org_id){
          orgId = customersCache[0].org_id;
        }
      } catch(_) { /* ignore */ }

      if (!orgId){
        try {
          const { data, error } = await supabaseClient.rpc('my_orgs');
          if (!error && Array.isArray(data) && data.length > 0 && data[0].id){
            orgId = data[0].id;
          }
        } catch(e){
          console.error('Unable to fetch org via my_orgs', e);
        }
      }

      if (!orgId){
        showInlineError(errId, 'Unable to determine your organisation (org_id). Please ensure you belong to an organisation.');
        return;
      }

      const originalLabel = runBtn ? runBtn.textContent : '';
      if (runBtn){
        runBtn.disabled = true;
        runBtn.textContent = 'Running…';
      }

      try{
        // 1) Create bt_runs row
        // One helper at the top of handleBtRunClick (or outside, reused):
        const btDb = supabaseClient.schema('lth_pvr_bt');

        // Then use btDb for all lth_pvr_bt tables:
        const { data: runRow, error: runErr } = await btDb
          .from('bt_runs')                     // ✅ table name only
          .insert({
            org_id:        orgId,
            status:        'running'
          })
          .select('bt_run_id')
          .single();


        if (runErr) throw runErr;
        const bt_run_id = runRow.bt_run_id;
        if (!bt_run_id){
          throw new Error('Back-test run did not return a bt_run_id.');
        }

        // 2) Create bt_params row for this run (in lth_pvr_bt schema)
        const { error: paramsErr } = await btDb
          .from('bt_params')
          .insert({
          bt_run_id,
          start_date:            startDate,
          end_date:              endDate,
          upfront_contrib_usdt:  upfront,
          monthly_contrib_usdt:  monthly,
          maker_bps_trade,
          maker_bps_contrib
          // B1–B11 + momentum / gating stay on DB defaults for now (aligned with EF / Python)
        });

        if (paramsErr) throw paramsErr;

        // 3) Call ef_bt_execute for this bt_run_id
        const { error: fnErr } = await supabaseClient.functions.invoke('ef_bt_execute', {
          body: { bt_run_id }
        });

        if (fnErr) throw fnErr;

        // 4) Expose bt_run_id and immediately load charts/tables from bt_* tables
        window.btCurrentRunId = bt_run_id;
        btCurrentRunId = bt_run_id;

        await btLoadAndRenderFromRun(bt_run_id);

        showInlineError(errId, `Back-test completed successfully (Run #${bt_run_id}).`);

      }catch(err){
        console.error('Back-test failed:', err);
        showInlineError(errId, err.message || 'Back-test failed. Please check the console for details.');
      }finally{
        if (runBtn){
          runBtn.disabled = false;
          runBtn.textContent = originalLabel || 'Run Back-Test';
        }
      }
    }

    async function loadBtStdPortfolio(customerId){
      if(!supabaseClient) return {data:[],error:{message:'Supabase not available'}};
      const pageSize=1000; let lastDate=null; let all=[];
      while(true){
        let q=supabaseClient.from('std_dca_customer_transactions')
          .select('transaction_date, portfolio_value_usd, total_roi_percent, cagr_percent')
          .eq('customer_id',customerId).order('transaction_date',{ascending:true}).limit(pageSize);
        if(lastDate) q=q.gt('transaction_date', lastDate);
        const res=await q; if(res.error) return {data:all,error:res.error};
        if(!res.data||res.data.length===0) break;
        all=all.concat(res.data); lastDate=res.data[res.data.length-1].transaction_date;
        if(res.data.length<pageSize) break;
      }
      return {data:all,error:null};
    }

    async function handleBtCustomerChange(e){
      if(btChartInstance){ btChartInstance.destroy(); btChartInstance=null; }
      btSetResetZoomEnabled(false); btClearChartFooter(); btShowRange(false);
      btCurrentCustomerId = e.target.value;
      if(!btCurrentCustomerId){
        btCurrentFirst=''; btCurrentLast=''; btAdvData=null; btStdData=null; renderBtReportForCurrentState(); return;
      }
      const found = customersCache.find(c=>String(c.customer_id)===String(btCurrentCustomerId));
      btCurrentFirst = found?.first_names || ''; btCurrentLast = found?.last_name || '';

      const advRes = await loadBtAdvTransactions(btCurrentCustomerId);
      const stdRes = await loadBtStdPortfolio(btCurrentCustomerId);
      if(advRes.error){ showInlineError('btReportsError', advRes.error.message); }
      if(stdRes.error){ showInlineError('btReportsError', stdRes.error.message); }

      btAdvData = advRes.data || [];
      btStdData = stdRes.data || [];
      try { renderBtReportForCurrentState(); }
      catch (e) { console.error('BT chart error:', e); }
      await renderBtPerformanceTable(btCurrentCustomerId, btCurrentReportType);
    }

    (function bindBtReportTypeChange(){
      const sel = document.getElementById('btReportTypeSelect');
      if (!sel || sel._bound) return;
      sel.addEventListener('change', async (e) => {
        btCurrentReportType = e.target.value || 'holdings';
        renderBtReportForCurrentState();
        await renderBtPerformanceTable(btCurrentRunId, btCurrentReportType);
      });
      sel._bound = true;
    })();

    /* Holdings chart (Back-Testing) – LTH PVR vs contributions / balances */
    function renderBtHoldingsChart(rows, btRunId){
      if (!hasChart){
        showInlineError('btReportsError','Chart.js is not available.');
        return;
      }
      btDestroyChart();

      const canvas = document.getElementById('btPerfChart');
      const ctx    = canvas.getContext('2d');

      const labels   = rows.map(r => normalizeDate(r.trade_date));
      const sPrice   = rows.map(r => numOrNull(r.price_usd));
      const sContrib = rows.map(r => numOrNull(r.contrib_gross_usdt_cum));
      const sNav     = rows.map(r => numOrNull(r.nav_usd));
      const sUsd     = rows.map(r => numOrNull(r.usdt_balance));
      const sBtc     = rows.map(r => numOrNull(r.btc_balance));

      btSetReportTitle(btRunId);

      // local formatters for the axes
      const usdFmt = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        maximumFractionDigits: 0
      });
      const btcFmt = new Intl.NumberFormat('en-US', {
        maximumFractionDigits: 8
      });

      // local gradient helper (same pattern as your main holdings chart)
      const grad = (hex, top = 0.18, bottom = 0) => {
        const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, hexToRGBA(hex, top));
        g.addColorStop(1, hexToRGBA(hex, bottom));
        return g;
      };

      // zoom plugin (same pattern as elsewhere)
      let zoomReg = false;
      try {
        const Z = window['chartjs-plugin-zoom'];
        if (Z && !Chart.registry.plugins.get('zoom')) {
          Chart.register(Z);
        }
        zoomReg = !!Chart.registry.plugins.get('zoom');
      } catch (e) {
        zoomReg = false;
      }

      const tickColor = cssVar('--ink-soft') || '#6B7280';
      const gridColor = cssVar('--border-subtle') || '#E5E7EB';

      btChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'BTC Price',
              data: sPrice,
              borderColor: cssVar('--series-btc-price'),
              backgroundColor: 'transparent',
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            },
            {
              label: 'Total Contributions',
              data: sContrib,
              borderColor: cssVar('--series-invested'),
              backgroundColor: 'transparent',
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            },
            {
              label: 'LTH PVR DCA NAV',
              data: sNav,
              borderColor: cssVar('--series-adv-value'),
              backgroundColor: grad(cssVar('--series-adv-value'), 0.14, 0),
              fill: true,
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            },
            {
              label: 'USDT Balance',
              data: sUsd,
              borderColor: cssVar('--series-usd-balance'),
              backgroundColor: grad(cssVar('--series-usd-balance'), 0.12, 0),
              fill: true,
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            },
            {
              label: 'BTC Balance',
              data: sBtc,
              borderColor: cssVar('--series-btc-balance'),
              backgroundColor: 'transparent',
              yAxisID: 'y1',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: .22,
              borderWidth: 2
            }
          ]
        },
        options: {
          responsive: true,
          layout: { padding: { top: 8, right: 14, bottom: 8, left: 12 } },
          interaction: { mode: 'index', intersect: false },
          animation: false,
          scales: {
            x: {
              title: { display: true, text: 'Trade Date' },
              ticks: { color: tickColor, maxRotation: 0, autoSkipPadding: 20 },
              grid: { color: gridColor },
              min: 0,
              max: labels.length - 1
            },
            y: {
              title: { display: true, text: 'USD' },
              position: 'left',
              ticks: {
              color: tickColor,
              callback: (v) => usdFmt.format(v)
            },
            grid: { color: gridColor }
          },
          y1: {
            title: { display: true, text: 'BTC' },
            position: 'right',
            ticks: {
              color: tickColor,
              callback: (v) => btcFmt.format(v) + ' BTC'
            },
            grid: { drawOnChartArea: false, color: gridColor }
          }
        },
        plugins: {
          legend: legendWithFading(),
          title: { display: false },
          decimation: { enabled: true, algorithm: 'lttb', samples: 2000 },
          zoom: {
            pan: { enabled: zoomReg, mode: 'x' },
            zoom: {
              wheel: { enabled: zoomReg },
              pinch: { enabled: zoomReg },
              mode: 'x'
            }
          }
        }
      }
    });

    btInitOrUpdateRange(labels);
    btRebuildFooterForChart(btChartInstance);
    btSetResetZoomEnabled(zoomReg && typeof btChartInstance.resetZoom === 'function');
    }

    /* Comparison – Portfolio Value (LTH PVR vs Standard DCA) */
    function renderBTCompPortfolioValueChart(lthRows, stdRows, btRunId) {
      if (!hasChart) {
        showInlineError('btReportsError', 'Chart.js is not available.');
        return;
      }
      btDestroyChart();

      const canvas = document.getElementById('btPerfChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      // Collect all trade dates from both series
      const dateSet = new Set();
      (lthRows || []).forEach(r => dateSet.add(normalizeDate(r.trade_date)));
      (stdRows || []).forEach(r => dateSet.add(normalizeDate(r.trade_date)));
      const labels = Array.from(dateSet).sort();

      if (!labels.length) {
        btSetChartFooter([]);
        btShowRange(false);
        document.getElementById('btChartNotice').textContent = 'No data to display for this back-test.';
        document.getElementById('btChartNotice').style.display = 'block';
        document.getElementById('btReportTitle').textContent = '';
        return;
      }

      // Map NAV by date
      const lthMap = Object.create(null);
      (lthRows || []).forEach(r => {
        const d = normalizeDate(r.trade_date);
        const v = numOrNull(r.nav_usd);
        if (v != null) lthMap[d] = v;
      });

      const stdMap = Object.create(null);
      (stdRows || []).forEach(r => {
        const d = normalizeDate(r.trade_date);
        const v = numOrNull(r.nav_usd);
        if (v != null) stdMap[d] = v;
      });

      const lthSeries = labels.map(d => (d in lthMap ? lthMap[d] : null));
      const stdSeries = labels.map(d => (d in stdMap ? stdMap[d] : null));

      // ✅ Formatter that was missing
      const usdFmt = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        maximumFractionDigits: 0
      });

      // Title
      btSetReportTitle(btRunId);

      // Enable zoom plugin if available
      let zoomReg = false;
      try {
        const Z = window['chartjs-plugin-zoom'];
        if (Z && !Chart.registry.plugins.get('zoom')) {
          Chart.register(Z);
        }
        zoomReg = !!Chart.registry.plugins.get('zoom');
      } catch (e) {
        zoomReg = false;
      }

      const gridColor = cssVar('--grid') || '#F2F2F2';
      const tickColor = cssVar('--muted') || '#6b7280';

      btChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'LTH PVR BTC DCA NAV',
              data: lthSeries,
              borderColor: cssVar('--series-adv-value') || '#22c55e',
              backgroundColor: 'transparent',
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: 0.22,
              borderWidth: 2
            },
            {
              label: 'Standard DCA NAV',
              data: stdSeries,
              borderColor: cssVar('--series-invested') || '#6366f1',
              backgroundColor: 'transparent',
              yAxisID: 'y',
              pointRadius: 0,
              pointHoverRadius: 3,
              tension: 0.22,
              borderWidth: 2
            }
          ]
        },
        options: {
          responsive: true,
          layout: { padding: { top: 8, right: 14, bottom: 8, left: 12 } },
          interaction: { mode: 'index', intersect: false },
          animation: false,
          scales: {
            x: {
              title: { display: true, text: 'Trade Date' },
              ticks: { color: tickColor, maxRotation: 0, autoSkipPadding: 20 },
              grid: { color: gridColor },
              min: 0,
              max: labels.length - 1
            },
            y: {
              title: { display: true, text: 'Portfolio Value (USD)' },
              position: 'left',
              ticks: {
                color: tickColor,
                callback: v => usdFmt.format(v)
              },
              grid: { color: gridColor }
            }
          },
          plugins: {
            legend: legendWithFading(),
            title: { display: false },
            decimation: { enabled: true, algorithm: 'lttb', samples: 2000 },
            zoom: {
              pan: { enabled: zoomReg, mode: 'x' },
              zoom: {
                wheel: { enabled: zoomReg },
                pinch: { enabled: zoomReg },
                mode: 'x'
              }
            }
          }
        }
      });

      btInitOrUpdateRange(labels);
      btRebuildFooterForChart(btChartInstance);
      btSetResetZoomEnabled(zoomReg && typeof btChartInstance.resetZoom === 'function');
    }

    /* Comparison – ROI (BT) */
    function renderBTCompROIChart(advRows,stdRows,btRunId){
      if (!hasChart){
        showInlineError('btReportsError','Chart.js is not available.');
        return;
      }
      btDestroyChart();

      const canvas = document.getElementById('btPerfChart');
      const ctx    = canvas.getContext('2d');

      const setDates = new Set();
      (advRows || []).forEach(r => setDates.add(normalizeDate(r.trade_date)));
      (stdRows || []).forEach(r => setDates.add(normalizeDate(r.trade_date)));
      const labels = Array.from(setDates).sort();

      const lthMap = new Map();
      const stdMap = new Map();
      (advRows || []).forEach(r => lthMap.set(normalizeDate(r.trade_date), numOrNull(r.total_roi_percent)));
      (stdRows || []).forEach(r => stdMap.set(normalizeDate(r.trade_date), numOrNull(r.total_roi_percent)));

      const sLth = labels.map(d => lthMap.has(d) ? lthMap.get(d) : null);
      const sStd = labels.map(d => stdMap.has(d) ? stdMap.get(d) : null);

      btSetReportTitle(btRunId);

      const tickColor = cssVar('--ink-soft') || '#6B7280';
      const gridColor = cssVar('--border-subtle') || '#E5E7EB';

      btChartInstance = new Chart(ctx,{
        type:'line',
        data:{
          labels,
          datasets:[
            { label:'LTH PVR DCA ROI', data:sLth, borderColor:cssVar('--series-adv-value'), backgroundColor:'transparent', yAxisID:'y', pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2 },
            { label:'Standard DCA ROI', data:sStd, borderColor:cssVar('--series-std-value'), backgroundColor:'transparent', yAxisID:'y', pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2 }
          ]
        },
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{
              title:{display:true,text:'Trade Date'},
              ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},
              grid:{color:gridColor},
              min:0,
              max:labels.length-1
            },
            y:{
              title:{display:true,text:'ROI %'},
              position:'left',
              ticks:{color:tickColor,callback:(v)=> (v==null ? '–' : `${Number(v).toFixed(2)}%`)},
              grid:{color:gridColor}
            }
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:true,text:'ROI – LTH PVR DCA vs Standard DCA'},
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:true,mode:'x'},zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'x'}}
          }
        }
      });

      btInitOrUpdateRange(labels);
      btRebuildFooterForChart(btChartInstance);
      btSetResetZoomEnabled(typeof btChartInstance.resetZoom === 'function');
    }

    /* Comparison – CAGR (BT) */
    function renderBTCompAGRChart(advRows,stdRows,btRunId){
      if (!hasChart){
        showInlineError('btReportsError','Chart.js is not available.');
        return;
      }
      btDestroyChart();

      const canvas = document.getElementById('btPerfChart');
      const ctx    = canvas.getContext('2d');

      const setDates = new Set();
      (advRows || []).forEach(r => setDates.add(normalizeDate(r.trade_date)));
      (stdRows || []).forEach(r => setDates.add(normalizeDate(r.trade_date)));
      const labels = Array.from(setDates).sort();

      const lthMap = new Map();
      const stdMap = new Map();
      (advRows || []).forEach(r => lthMap.set(normalizeDate(r.trade_date), numOrNull(r.cagr_percent)));
      (stdRows || []).forEach(r => stdMap.set(normalizeDate(r.trade_date), numOrNull(r.cagr_percent)));

      const sLth = labels.map(d => lthMap.has(d) ? lthMap.get(d) : null);
      const sStd = labels.map(d => stdMap.has(d) ? stdMap.get(d) : null);

      btSetReportTitle(btRunId);

      const tickColor = cssVar('--ink-soft') || '#6B7280';
      const gridColor = cssVar('--border-subtle') || '#E5E7EB';

      btChartInstance = new Chart(ctx,{
        type:'line',
        data:{
          labels,
          datasets:[
            { label:'LTH PVR DCA CAGR', data:sLth, borderColor:cssVar('--series-adv-value'), backgroundColor:'transparent', yAxisID:'y', pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2 },
            { label:'Standard DCA CAGR', data:sStd, borderColor:cssVar('--series-std-value'), backgroundColor:'transparent', yAxisID:'y', pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2 }
          ]
        },
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{
              title:{display:true,text:'Trade Date'},
              ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},
              grid:{color:gridColor},
              min:0,
              max:labels.length-1
            },
            y:{
              title:{display:true,text:'CAGR %'},
              position:'left',
              ticks:{color:tickColor,callback:(v)=> (v==null ? '–' : `${Number(v).toFixed(2)}%`)},
              grid:{color:gridColor}
            }
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:true,text:'CAGR – LTH PVR DCA vs Standard DCA'},
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:true,mode:'x'},zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'x'}}
          }
        }
      });

      btInitOrUpdateRange(labels);
      btRebuildFooterForChart(btChartInstance);
      btSetResetZoomEnabled(typeof btChartInstance.resetZoom === 'function');
    }

    function btRebuildFooterForChart(chart){
      const labels = chart.data.labels || [];
      if(!labels.length){ btClearChartFooter(); return; }

      const sEl = document.getElementById('btRangeStart');
      const eEl = document.getElementById('btRangeEnd');

      let start = 0, end = labels.length - 1;
      if (sEl && eEl && Number(eEl.max) === labels.length - 1) {
        start = Math.min(Number(sEl.value), Number(eEl.value));
        end   = Math.max(Number(sEl.value), Number(eEl.value));
      }

      const entries = [];
      chart.data.datasets.forEach((d, i) => {
        if(!chart.isDatasetVisible(i)) return;
        const arr = d.data || [];
        for (let ii=end; ii>=start; ii--){
          const v = arr[ii];
          if (v!==null && v!==undefined && !Number.isNaN(v)) {
            const val = d.yAxisID==='y1'
              ? (Number(v).toLocaleString('en-US',{maximumFractionDigits:8})+' BTC')
              : ((/ROI|Growth|%|CAGR/i.test(d.label||''))
                 ? (Number(v).toFixed(2)+'%')
                 : new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0}).format(Number(v)));

            entries.push({ label:d.label, value:val, date:labels[ii]||'', color:d.borderColor });
            break;
          }
        }
      });

      btSetChartFooter(entries);
    }

    let currentCustomerId='',currentFirst='',currentLast='',advData=null,stdData=null,currentReportType='holdings';
    let customersCache=[],customerChoices=null,reportTypeChoices=null,txCustomerChoices=null;

    // Org / portfolio / customer context
    let orgsCache = [];
    let allPortfoliosCache = [];
    let strategiesNameByCode = {}; // { [strategy_code]: strategies.name }
    let currentOrgId = null;
    let currentPortfolioId = null;
    let currentStrategyCode = null;

    /* Track active module in <body data-active-module="..."> so CSS can react */
    function bwSetActiveModuleFlag(){
      const hash = (location.hash || '').replace('#','');
      document.body.setAttribute('data-active-module', hash || '');
    }
    window.addEventListener('hashchange', bwSetActiveModuleFlag);
    bwSetActiveModuleFlag();

    // Strategy-specific UI visibility helper.
    // Any element with data-strategy="CODE[,OTHER]" will only be shown when
    // currentStrategyCode matches one of the codes (case-insensitive).
    function updateStrategyVisibility(){
      const active = (currentStrategyCode || '').toString().toUpperCase();
      const els = document.querySelectorAll('[data-strategy]');
      els.forEach(el => {
        const raw = (el.getAttribute('data-strategy') || '').toUpperCase();
        const allowed = raw.split(',').map(s => s.trim()).filter(Boolean);
        // If an element has data-strategy set, only show it when a strategy is actually selected.
        const show = !allowed.length || (active && allowed.includes(active));
        if (show){
          el.classList.remove('strategy-hidden');
        } else {
          el.classList.add('strategy-hidden');
        }
      });
    }

    // Loads organisation(s) via my_orgs(), then portfolios via list_customer_portfolios()
    // Falls back to one pseudo-portfolio per active customer if the RPC is not present yet.
    async function loadOrgContext(){
      const orgSel  = document.getElementById('orgSelect');
      const portSel = document.getElementById('portfolioSelect');
      const custSel = document.getElementById('customerSelect');
      if(!orgSel || !portSel) return;

      const isTxModule = () => location.hash === '#transactions-module';

      function setPortPlaceholder(txt){
        portSel.innerHTML = `<option value="">${txt}</option>`;
        portSel.disabled = true;
        currentPortfolioId = null;
        currentStrategyCode = null;
        window.currentStrategyCode = null;
        updateStrategyVisibility();
      }

      function buildStrategyOptionsForTransactions(){
        // Build the strategy list dynamically from the portfolios view (preferred),
        // falling back to a small hard-coded map if the view doesn’t provide names.
        const fallbackName = (code) => {
          const map = {
            'ADV_DCA': 'Advanced BTC DCA',
            'LTH_PVR': 'LTH PVR BTC DCA'
          };
          return map[code] || code;
        };

        const byCode = new Map();

        (allPortfoliosCache || []).forEach(p => {
          const code = String(p.strategy_code || '').toUpperCase();
          if (!code) return;

          const name =
            (p.strategy_name || p.strategy_label || p.strategy_display_name || p.strategy_title || '')
              .toString()
              .trim();

          // keep first name we find, but prefer a real name over fallback
          if (!byCode.has(code)) {
            byCode.set(code, name || fallbackName(code));
          } else if (name && byCode.get(code) === fallbackName(code)) {
            byCode.set(code, name);
          }
        });

        const items = Array.from(byCode.entries())
          .map(([code, name]) => ({ code, name: name || fallbackName(code) }))
          .sort((a,b) => a.name.localeCompare(b.name));

        portSel.innerHTML =
          ['<option value="">Select strategy…</option>']
            .concat(items.map(i => `<option value="${i.code}">${i.name}</option>`))
            .join('');

        portSel.disabled = items.length === 0;

        // do NOT auto-select a strategy
        currentPortfolioId = null;
        currentStrategyCode = null;
        window.currentStrategyCode = null;
        updateStrategyVisibility();
      }

      function buildPortfolioOptionsForCustomer(customerId){
        if (!customerId){
          setPortPlaceholder('Select customer first…');
          return;
        }

        const ports = (allPortfoliosCache || []).filter(p => String(p.customer_id) === String(customerId));
        if(!ports.length){
          setPortPlaceholder('No portfolios for customer');
          return;
        }

        portSel.innerHTML = ports.map(p => {
          const portLabel = (p.label || p.portfolio_label || p.portfolio_name || '').toString().trim();
          const code = p.strategy_code ? String(p.strategy_code).toUpperCase() : '';
          const stratName =
            (p.strategy_name || p.strategy_label || p.strategy_display_name || p.strategy_title || '').toString().trim();

          const text = stratName
            ? `${portLabel} — ${stratName}`
            : (code ? `${portLabel} — ${code}` : portLabel);

          const dataCode = code || '';

          // IMPORTANT: embed the strategy code on the option itself
          return `<option value="${p.portfolio_id}" data-strategy-code="${dataCode}">${text}</option>`;
        }).join('');

        portSel.disabled=false;

        // auto select first portfolio (OK for non-transactions modules)
        portSel.value = ports[0].portfolio_id;
        currentPortfolioId = ports[0].portfolio_id;
        currentStrategyCode = ports[0].strategy_code ? String(ports[0].strategy_code).toUpperCase() : null;
        window.currentStrategyCode = currentStrategyCode;
        updateStrategyVisibility();
      }

      function applyContextMode(){
        const custGroup = document.getElementById('ctxCustomerGroup');

        if (isTxModule()){
          // Customer Transactions is multi-customer → hide customer selector
          if (custGroup) custGroup.style.display = 'none';

          if (custSel){
            custSel.disabled = true;
            custSel.setAttribute('disabled', 'disabled');
          }

          buildStrategyOptionsForTransactions();
        } else {
          // All other modules → show customer selector
          if (custGroup) custGroup.style.display = '';

          if (custSel){
            custSel.disabled = false;
            custSel.removeAttribute('disabled');
          }

          const cid = custSel ? (custSel.value || '') : '';
          buildPortfolioOptionsForCustomer(cid);
        }
      }

      if(!supabaseClient){
        orgSel.innerHTML='<option value="">Supabase not ready</option>';
        portSel.innerHTML='<option value="">Supabase not ready</option>';
        orgSel.disabled=true; portSel.disabled=true;
        return;
      }

      try{
        // orgs (best-effort; portfolios do NOT depend on this)
        let orgs = [];
        try{
          const { data, error } = await supabaseClient.rpc('my_orgs');
          if (error) throw error;
          orgs = Array.isArray(data) ? data : [];
        }catch(_e){
          // fallback if my_orgs doesn't exist
          try{
            const orgRes = await supabaseClient.rpc('list_organisations');
            orgs = Array.isArray(orgRes.data) ? orgRes.data : [];
          }catch(_e2){
            orgs = [];
          }
        }

        const activeOrg =
          orgs.find(o => String(o.organisation_status||o.organisation_status_code||'Active').toLowerCase()==='active')
          || orgs[0]
          || null;

        const getOrgId   = (o) => (o ? (o.organisation_id || o.org_id || o.id) : null);
        const getOrgName = (o) => (o ? (o.organisation_name || o.org_name || o.name || String(getOrgId(o)||'')) : '');

        const activeOrgId = getOrgId(activeOrg);

        orgSel.innerHTML = orgs.length
          ? orgs.map(o=>{
              const id = getOrgId(o);
              const name = getOrgName(o);
              return `<option value="${id}" ${String(id)===String(activeOrgId)?'selected':''}>${name}</option>`;
            }).join('')
          : '<option value="">No organisations</option>';

        // keep disabled unless you truly have multiple orgs
        orgSel.disabled = !(orgs.length > 1);

        // portfolios (prefer public.v_customer_portfolios_expanded for correct strategy display names)
        const orgId = activeOrgId || null;

        let portfolios = [];
        let portErr = null;

        // 1) Try the expanded view first (includes strategy names, etc.)
        try{
          let q = supabaseClient
            .from('v_customer_portfolios_expanded')
            .select('*');

          if (orgId) q = q.eq('org_id', orgId);

          const { data, error } = await q;
          if (error) throw error;
          portfolios = Array.isArray(data) ? data : [];
        }catch(eView){
          // 2) Fallback to the base table if the view is missing / blocked by RLS
          try{
            let q = supabaseClient
              .from('customer_portfolios')
              .select('portfolio_id, org_id, customer_id, strategy_code, label, exchange, exchange_account_id, exchange_subaccount');

            if (orgId) q = q.eq('org_id', orgId);

            const { data, error } = await q.order('label', { ascending: true });
            if (error) throw error;
            portfolios = Array.isArray(data) ? data : [];
          }catch(eTable){
            portErr = eTable;
            portfolios = [];
            console.warn('Failed to load portfolios (view + table).', { eView, eTable });
          }
        }

        // normalize + client-side sort (keeps it robust if the view has different column names)
        portfolios = (portfolios || [])
          // if the row has a status column, only keep active
          .filter(p => !p.status || String(p.status).toLowerCase() === 'active')
          .map(p => ({
            ...p,
            // normalize strategy_code casing
            strategy_code: p.strategy_code ? String(p.strategy_code).toUpperCase() : p.strategy_code
          }))
          .sort((a,b) => {
            const al = String(a.label || a.portfolio_label || a.portfolio_name || '').toLowerCase();
            const bl = String(b.label || b.portfolio_label || b.portfolio_name || '').toLowerCase();
            return al.localeCompare(bl);
          });

        portfoliosCache = portfolios;
        allPortfoliosCache = portfolios.slice();

        // If nothing loaded, keep portfolio disabled but customer still usable
        if(!allPortfoliosCache.length){
          setPortPlaceholder('No portfolios');
          console.warn('No portfolios loaded for org:', orgId, portErr);
        }

        // portfolio/strategy change
        if(!portSel._bound){
          portSel.addEventListener('change', (e)=>{
            const v = e.target.value || '';

            if (isTxModule()){
              currentPortfolioId = null;
              currentStrategyCode = v ? v.toUpperCase() : null;
              window.currentStrategyCode = currentStrategyCode;
              updateStrategyVisibility();
              return;
            }

            const found = (allPortfoliosCache || []).find(p=>String(p.portfolio_id)===String(v));
            if(found){
              currentPortfolioId  = found.portfolio_id;
              currentStrategyCode = found.strategy_code ? String(found.strategy_code).toUpperCase() : null;
              window.currentStrategyCode = currentStrategyCode;

              if (custSel && String(custSel.value) !== String(found.customer_id)) {
                custSel.value = String(found.customer_id);
              }
              updateStrategyVisibility();
            } else {
              currentPortfolioId = null;
              currentStrategyCode = null;
              window.currentStrategyCode = null;
              updateStrategyVisibility();
            }
          });
          portSel._bound=true;
        }

        // customer change only matters outside Customer Transactions
        if(custSel && !custSel._ctxBound){
          custSel.addEventListener('change', (e)=>{
            if (isTxModule()) return;
            buildPortfolioOptionsForCustomer(e.target.value || '');
          });
          custSel._ctxBound = true;
        }

        // update context behaviour when switching tabs
        if(!window._ctxHashBound){
          window.addEventListener('hashchange', applyContextMode);
          window._ctxHashBound = true;
        }

        applyContextMode();

      }catch(err){
        console.error('OrgContext load failed:',err);
        orgSel.innerHTML='<option value="">Error loading</option>';
        portSel.innerHTML='<option value="">Error loading</option>';
        orgSel.disabled=true; portSel.disabled=true;
        if (custSel){ custSel.disabled = false; custSel.removeAttribute('disabled'); }
      }
    }

    function setReportTitle(first,last){const el=document.getElementById('reportTitle');el.textContent=(first&&last)?('Advanced DCA Portfolio Performance of '+first+' '+last):'';}
    function setResetZoomEnabled(en){const b=document.getElementById('resetZoomBtn');if(b)b.disabled=!en;}
    function setCanvasVisible(show){const c=document.getElementById('perfChart');if(c)c.style.display=show?'block':'none';}
    function showChartNotice(msg){const n=document.getElementById('chartNotice');n.textContent=msg;n.style.display='block';}
    function hideChartNotice(){const n=document.getElementById('chartNotice');n.textContent='';n.style.display='none';}

    function destroyChoicesInst(inst){ if(inst && typeof inst.destroy==='function'){ inst.destroy(); } }
    function setNativeOptions(sel, html){ destroyChoicesInst(sel._choices); sel.innerHTML = html; }

    async function loadCustomers(){
      const sel=document.getElementById('customerSelect');
      const btSel = document.getElementById('btCustomerSelect');
      const txSel=document.getElementById('txCustomerSelect');
      const editSel=document.getElementById('cmEditSelect');
      if(!supabaseClient){
        const msg='<option value="">Unable to load customers (no Supabase)</option>';
        if(sel) setNativeOptions(sel,msg);
        if(btSel) setNativeOptions(btSel,msg);
        if(txSel) setNativeOptions(txSel,msg);
        if(editSel) setNativeOptions(editSel,msg);
        showInlineError('reportsError','Supabase not available.');
        return;
      }
      const timeout=new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')),8000));
      try{
        const fetchPromise = window.supabaseClient.rpc('list_customers');
        const raced=await Promise.race([fetchPromise,timeout]);
        if(raced.error) throw raced.error;
        const list=raced.data||[];
        const active = list.filter(r =>
          String(r.customer_status || 'Active').toLowerCase() === 'active'
         );
        customersCache=list;

        const opts=['<option value="">Select customer…</option>'].concat(
          active.map(r=>'<option value="'+String(r.customer_id)+'">'+r.last_name+', '+r.first_names+'</option>')
        ).join('');

        if(sel){
          sel.disabled = false;
          sel.removeAttribute('disabled');
          setNativeOptions(sel, opts);
        }
        if(txSel) setNativeOptions(txSel, opts);
        if(editSel) setNativeOptions(editSel, opts);

        if(typeof window.Choices!=="undefined"){
          if(sel){
            customerChoices && customerChoices.destroy();
            customerChoices=new Choices(sel,{searchEnabled:true,searchPlaceholderValue:'Type name…',placeholder:true,placeholderValue:'Select customer…',shouldSort:false,allowHTML:false,itemSelectText:''});
            customerChoices.setChoices(active.map(r=>({value:String(r.customer_id),label:r.last_name+', '+r.first_names})), 'value','label',true);

            // IMPORTANT: keep the global customer selection blank by default
            try {
              if (typeof customerChoices.removeActiveItems === 'function') customerChoices.removeActiveItems();
            } catch (_) {}
            sel.value = '';

            sel._choices = customerChoices;
            if(!sel._bound){sel.addEventListener('change', handleCustomerChange);sel._bound=true;}
          }
          if(btSel){
            btSel._choices && btSel._choices.destroy();
            const ch=new Choices(btSel,{searchEnabled:true,searchPlaceholderValue:'Search customer…',shouldSort:false,allowHTML:false,itemSelectText:''});
            ch.setChoices(active.map(r=>({value:String(r.customer_id),label:r.last_name+', '+r.first_names})), 'value','label',true);
            btSel._choices = ch;
            if(!btSel._bound){ btSel.addEventListener('change', handleBtCustomerChange); btSel._bound=true; }  // bind change handler
          }
          if(txSel){
            txCustomerChoices && txCustomerChoices.destroy();
            txCustomerChoices=new Choices(txSel,{searchEnabled:true,searchPlaceholderValue:'Type name…',placeholder:true,placeholderValue:'Select customer…',shouldSort:false,allowHTML:false,itemSelectText:''});
            txCustomerChoices.setChoices(active.map(r=>({value:String(r.customer_id),label:r.last_name+', '+r.first_names})), 'value','label',true);
            txSel._choices = txCustomerChoices;
          }
          if(editSel){
            editSel._choices && editSel._choices.destroy();
            const ch=new Choices(editSel,{searchEnabled:true,shouldSort:false,allowHTML:false,itemSelectText:''});
            ch.setChoices(list.map(r=>({value:String(r.customer_id),label:r.last_name+', '+r.first_names})), 'value','label',true);
            editSel._choices = ch;
          }
        }else{
          if(sel && !sel._bound){sel.addEventListener('change', handleCustomerChange);sel._bound=true;}
        }

      }catch(err){
        console.error('Customer load failed:',err);
        const msg='<option value="">Unable to load customers</option>';
        if(sel) setNativeOptions(sel,msg);
        if(txSel) setNativeOptions(txSel,msg);
        if(editSel) setNativeOptions(editSel,msg);
        showInlineError('reportsError','Could not load customers (network/CORS/timeout).');
      }
    }

    async function handleCustomerChange(e){
      destroyChart(); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
      currentCustomerId = e.target.value;
      if(!currentCustomerId){
        currentFirst=''; currentLast=''; advData=null; stdData=null; renderReportForCurrentState(); return;
      }
      const found = customersCache.find(c=>String(c.customer_id)===String(currentCustomerId));
      currentFirst = found && found.first_names ? found.first_names : '';
      currentLast  = found && found.last_name ? found.last_name : '';

      const advRes = await loadAdvTransactions(currentCustomerId);
      const stdRes = await loadStdPortfolio(currentCustomerId);
      if(advRes.error){ showInlineError('reportsError', advRes.error.message); }
      if(stdRes.error){ showInlineError('reportsError', stdRes.error.message); }
      advData = advRes.data || [];
      stdData = stdRes.data || [];
      renderReportForCurrentState();
      
      // make selection + data available to the PDF exporter
      window.currentCustomerId = currentCustomerId;
      window.advData = advData;
      window.stdData = stdData;
      await renderPerformanceTable(currentCustomerId, currentReportType);
    }

    // hook the report-type dropdown to refresh everything
    (function bindReportTypeChange(){
      const sel = document.getElementById('reportTypeSelect');
      if (!sel || sel._bound) return;
      sel.addEventListener('change', async (e) => {
        // update state
        currentReportType = e.target.value || 'holdings';

        // redraw the chart for the newly selected type
        renderReportForCurrentState();

        // and refresh the yearly table + narrative underneath
        await renderPerformanceTable(currentCustomerId, currentReportType);
      });
      sel._bound = true;
    })();

    async function loadAdvTransactions(customerId){
      if(!supabaseClient) return {data:[],error:{message:'Supabase not available'}};
      const pageSize=1000; let lastDate=null; let all=[];
      while(true){
        let q=supabaseClient.from('real_customer_performance_daily')
          .select('transaction_date:tx_date, btc_closing_price_usd, total_dca_invested_usd:total_invested_usdt, portfolio_value_usd, closing_balance_usd:closing_balance_usdt, closing_balance_btc, total_roi_percent, cagr_percent')
          .eq('customer_id',customerId).order('tx_date',{ascending:true}).limit(pageSize);
        if(lastDate) q=q.gt('tx_date', lastDate);
        const res=await q;
        if(res.error) return {data:all,error:res.error};
        if(!res.data||res.data.length===0) break;
        all=all.concat(res.data);
        lastDate=res.data[res.data.length-1].transaction_date;
        if(res.data.length<pageSize)break;
      }
      return {data:all,error:null};
    }
    async function loadStdPortfolio(customerId){
      if(!supabaseClient) return {data:[],error:{message:'Supabase not available'}};
      const pageSize=1000; let lastDate=null; let all=[];
      while(true){
        let q=supabaseClient.from('real_std_compare_customer_performance_daily')
          .select('transaction_date:tx_date, portfolio_value_usd, total_roi_percent, cagr_percent')
          .eq('customer_id',customerId).order('tx_date',{ascending:true}).limit(pageSize);
        if(lastDate) q=q.gt('tx_date', lastDate);
        const res=await q;
        if(res.error) return {data:all,error:res.error};
        if(!res.data||res.data.length===0) break;
        all=all.concat(res.data);
        lastDate=res.data[res.data.length-1].transaction_date;
        if(res.data.length<pageSize)break;
      }
      return {data:all,error:null};
    }

    const hexToRGBA=(hex,a)=>{const c=hex.replace('#','');const r=parseInt(c.slice(0,2),16),g=parseInt(c.slice(2,4),16),b=parseInt(c.slice(4,6),16);return`rgba(${r},${g},${b},${a})`;};
    function legendWithFading(){
      const base=cssVar('--ink')||'#111827';
      return {
        position:'top',
        labels:{color:(ctx)=>{const ch=ctx.chart,i=ctx.datasetIndex;return ch.isDatasetVisible(i)?base:'rgba(17,24,39,0.35)';},
                boxWidth:24,boxHeight:2,useBorderRadius:true,borderRadius:2,padding:14},
        onClick:(e,item,leg)=>{const ch=leg.chart,i=item.datasetIndex;ch.setDatasetVisibility(i,!ch.isDatasetVisible(i));ch.update();rebuildFooterForChart(ch);}
      };
    }
    function destroyChart(){if(chartInstance){chartInstance.destroy();chartInstance=null;}}

    /* Holdings chart */
    function renderHoldingsChart(rows,first,last){
      if(!hasChart){showInlineError('reportsError','Chart.js is not available.');return;}
      destroyChart();
      const canvas=document.getElementById('perfChart');const ctx=canvas.getContext('2d');
      const labels=rows.map(r=>normalizeDate(r.transaction_date));
      const sBTC=rows.map(r=>numOrNull(r.btc_closing_price_usd));
      const sInvest=rows.map(r=>numOrNull(r.total_dca_invested_usd));
      const sPV=rows.map(r=>numOrNull(r.portfolio_value_usd));
      const sUSD=rows.map(r=>numOrNull(r.closing_balance_usd));
      const sBTCBal=rows.map(r=>numOrNull(r.closing_balance_btc));
      document.getElementById('reportTitle').textContent=(first&&last)?(`Advanced DCA Portfolio Performance of ${first} ${last}`):'Advanced DCA Portfolio Performance';

      const usdFmt=new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
      const btcFmt=new Intl.NumberFormat('en-US',{maximumFractionDigits:8});
      const grad=(hex,top=.18,bottom=0)=>{const g=ctx.createLinearGradient(0,0,0,canvas.height);g.addColorStop(0,hexToRGBA(hex,top));g.addColorStop(1,hexToRGBA(hex,bottom));return g;};

      let zoomReg=false;
      try{const Z=window['chartjs-plugin-zoom'];if(Z&&!Chart.registry.plugins.get('zoom'))Chart.register(Z);zoomReg=!!Chart.registry.plugins.get('zoom');}catch(e){zoomReg=false;}

      const gridColor=cssVar('--grid')||'#F2F2F2';
      const tickColor=cssVar('--muted')||'#6b7280';

      chartInstance=new Chart(ctx,{
        type:'line',
        data:{labels,datasets:[
          {label:'BTC Closing Price',data:sBTC,borderColor:cssVar('--series-btc-price'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Total Investment',data:sInvest,borderColor:cssVar('--series-invested'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Advanced DCA Portfolio Value',data:sPV,borderColor:cssVar('--series-adv-value'),backgroundColor:grad(cssVar('--series-adv-value'),.14,0),fill:true,yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'USD Balance',data:sUSD,borderColor:cssVar('--series-usd-balance'),backgroundColor:grad(cssVar('--series-usd-balance'),.12,0),fill:true,yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'BTC Balance',data:sBTCBal,borderColor:cssVar('--series-btc-balance'),backgroundColor:'transparent',yAxisID:'y1',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2}
        ]},
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{title:{display:true,text:'Transaction Date'},ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},grid:{color:gridColor},min:0,max:labels.length-1},
            y:{title:{display:true,text:'USD'},position:'left',ticks:{color:tickColor,callback:(v)=>usdFmt.format(v)},grid:{color:gridColor}},
            y1:{title:{display:true,text:'BTC'},position:'right',ticks:{color:tickColor,callback:(v)=>btcFmt.format(v)+' BTC'},grid:{drawOnChartArea:false,color:gridColor}}
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:false},
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:zoomReg,mode:'x'},zoom:{wheel:{enabled:zoomReg},pinch:{enabled:zoomReg},mode:'x'}}
          }
        }
      });

      initOrUpdateRange(labels);
      rebuildFooterForChart(chartInstance);
      setResetZoomEnabled(zoomReg&&typeof chartInstance.resetZoom==='function');
    }

    /* Comparison – Portfolio Value */
    function renderCompPortfolioValueChart(advRows,stdRows,first,last){
      if(!hasChart){showInlineError('reportsError','Chart.js is not available.');return;}
      destroyChart();
      const canvas=document.getElementById('perfChart');const ctx=canvas.getContext('2d');

      const setDates=new Set();
      advRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      stdRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      const labels=Array.from(setDates).sort();

      const advMap=Object.create(null);advRows.forEach(r=>advMap[normalizeDate(r.transaction_date)]=numOrNull(r.portfolio_value_usd));
      const stdMap=Object.create(null);stdRows.forEach(r=>stdMap[normalizeDate(r.transaction_date)]=numOrNull(r.portfolio_value_usd));
      const advSeries=labels.map(d=>advMap[d]!=null?advMap[d]:null);
      const stdSeries=labels.map(d=>stdMap[d]!=null?stdMap[d]:null);

      const usdFmt=new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
      document.getElementById('reportTitle').textContent=(first&&last)?(`Portfolio Value Comparison (Advanced DCA vs. Standard DCA) of ${first} ${last}`):'Portfolio Value Comparison (Advanced DCA vs. Standard DCA)';

      let zoomReg=false;
      try{const Z=window['chartjs-plugin-zoom'];if(Z&&!Chart.registry.plugins.get('zoom'))Chart.register(Z);zoomReg=!!Chart.registry.plugins.get('zoom');}catch(e){zoomReg=false;}

      const gridColor=cssVar('--grid')||'#F2F2F2';
      const tickColor=cssVar('--muted')||'#6b7280';

      chartInstance=new Chart(ctx,{
        type:'line',
        data:{labels,datasets:[
          {label:'Advanced DCA Portfolio Value',data:advSeries,borderColor:cssVar('--series-comp-adv'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Standard DCA Portfolio Value',data:stdSeries,borderColor:cssVar('--series-comp-std'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2}
        ]},
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{title:{display:true,text:'Transaction Date'},ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},grid:{color:gridColor},min:0,max:labels.length-1},
            y:{title:{display:true,text:'USD'},position:'left',ticks:{color:tickColor,callback:(v)=>usdFmt.format(v)},grid:{color:gridColor}}
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:false},
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:zoomReg,mode:'x'},zoom:{wheel:{enabled:zoomReg},pinch:{enabled:zoomReg},mode:'x'}}
          }
        }
      });

      initOrUpdateRange(labels);
      rebuildFooterForChart(chartInstance);
      setResetZoomEnabled(zoomReg&&typeof chartInstance.resetZoom==='function');
    }

    /* Comparison – ROI */
    function renderCompROIChart(advRows,stdRows,first,last){
      if(!hasChart){showInlineError('reportsError','Chart.js is not available.');return;}
      destroyChart();
      const canvas=document.getElementById('perfChart');const ctx=canvas.getContext('2d');

      const setDates=new Set();
      advRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      stdRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      const labels=Array.from(setDates).sort();

      const advMap=Object.create(null);advRows.forEach(r=>advMap[normalizeDate(r.transaction_date)]=numOrNull(r.total_roi_percent));
      const stdMap=Object.create(null);stdRows.forEach(r=>stdMap[normalizeDate(r.transaction_date)]=numOrNull(r.total_roi_percent));
      const advSeries=labels.map(d=>advMap[d]!=null?advMap[d]:null);
      const stdSeries=labels.map(d=>stdMap[d]!=null?stdMap[d]:null);

      document.getElementById('reportTitle').textContent=(first&&last)?(`ROI Comparison (Advanced DCA vs. Standard DCA) of ${first} ${last}`):'ROI Comparison (Advanced DCA vs. Standard DCA)';

      let zoomReg=false;
      try{const Z=window['chartjs-plugin-zoom'];if(Z&&!Chart.registry.plugins.get('zoom'))Chart.register(Z);zoomReg=!!Chart.registry.plugins.get('zoom');}catch(e){zoomReg=false;}

      const gridColor=cssVar('--grid')||'#F2F2F2';
      const tickColor=cssVar('--muted')||'#6b7280';

      chartInstance=new Chart(ctx,{
        type:'line',
        data:{labels,datasets:[
          {label:'Advanced DCA ROI %',data:advSeries,borderColor:cssVar('--series-comp-adv'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Standard DCA ROI %',data:stdSeries,borderColor:cssVar('--series-comp-std'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2}
        ]},
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{title:{display:true,text:'Transaction Date'},ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},grid:{color:gridColor},min:0,max:labels.length-1},
            y:{title:{display:true,text:'ROI %'},position:'left',ticks:{color:tickColor,callback:(v)=>pctText(v==null?0:v)},grid:{color:gridColor}}
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:false},
            tooltip:{ callbacks:{ label:(ctx)=>`${ctx.dataset.label}: ${(Number(ctx.parsed.y)*100).toFixed(2)}%` } },
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:zoomReg,mode:'x'},zoom:{wheel:{enabled:zoomReg},pinch:{enabled:zoomReg},mode:'x'}}
          }
        }
      });

      initOrUpdateRange(labels);
      rebuildFooterForChart(chartInstance);
      setResetZoomEnabled(zoomReg&&typeof chartInstance.resetZoom==='function');
    }

    /* Comparison – Annualised Growth */
    function renderCompAGRChart(advRows,stdRows,first,last){
      if(!hasChart){showInlineError('reportsError','Chart.js is not available.');return;}
      destroyChart();
      const canvas=document.getElementById('perfChart');const ctx=canvas.getContext('2d');

      const setDates=new Set();
      advRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      stdRows.forEach(r=>setDates.add(normalizeDate(r.transaction_date)));
      const labels=Array.from(setDates).sort();

      const advMap=Object.create(null);advRows.forEach(r=>advMap[normalizeDate(r.transaction_date)]=numOrNull(r.cagr_percent));
      const stdMap=Object.create(null);stdRows.forEach(r=>stdMap[normalizeDate(r.transaction_date)]=numOrNull(r.cagr_percent));
      const advSeries=labels.map(d=>advMap[d]!=null?advMap[d]:null);
      const stdSeries=labels.map(d=>stdMap[d]!=null?stdMap[d]:null);

      document.getElementById('reportTitle').textContent=(first&&last)?(`Annualised Growth Comparison (Advanced DCA vs. Standard DCA) of ${first} ${last}`):'Annualised Growth Comparison (Advanced DCA vs. Standard DCA)';

      let zoomReg=false;
      try{const Z=window['chartjs-plugin-zoom'];if(Z&&!Chart.registry.plugins.get('zoom'))Chart.register(Z);zoomReg=!!Chart.registry.plugins.get('zoom');}catch(e){zoomReg=false;}

      const gridColor=cssVar('--grid')||'#F2F2F2';
      const tickColor=cssVar('--muted')||'#6b7280';

      chartInstance=new Chart(ctx,{
        type:'line',
        data:{labels,datasets:[
          {label:'Advanced DCA Ann. Growth %',data:advSeries,borderColor:cssVar('--series-comp-adv'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2},
          {label:'Standard DCA Ann. Growth %',data:stdSeries,borderColor:cssVar('--series-comp-std'),backgroundColor:'transparent',yAxisID:'y',pointRadius:0,pointHoverRadius:3,tension:.22,borderWidth:2}
        ]},
        options:{
          responsive:true,
          layout:{padding:{top:8,right:14,bottom:8,left:12}},
          interaction:{mode:'index',intersect:false},
          animation:false,
          scales:{
            x:{title:{display:true,text:'Transaction Date'},ticks:{color:tickColor,maxRotation:0,autoSkipPadding:20},grid:{color:gridColor},min:0,max:labels.length-1},
            y:{title:{display:true,text:'Annualised Growth %'},position:'left',ticks:{color:tickColor,callback:(v)=>pctText(v==null?0:v)},grid:{color:gridColor}}
          },
          plugins:{
            legend:legendWithFading(),
            title:{display:false},
            tooltip:{ callbacks:{ label:(ctx)=>`${ctx.dataset.label}: ${(Number(ctx.parsed.y)*100).toFixed(2)}%` } },
            decimation:{enabled:true,algorithm:'lttb',samples:2000},
            zoom:{pan:{enabled:zoomReg,mode:'x'},zoom:{wheel:{enabled:zoomReg},pinch:{enabled:zoomReg},mode:'x'}}
          }
        }
      });

      initOrUpdateRange(labels);
      rebuildFooterForChart(chartInstance);
      setResetZoomEnabled(zoomReg&&typeof chartInstance.resetZoom==='function');
    }

    function rebuildFooterForChart(chart){
      const labels=chart.data.labels||[]; if(!labels.length){clearChartFooter();return;}
      const sEl=document.getElementById('rangeStart'),eEl=document.getElementById('rangeEnd'); let start=0,end=labels.length-1;
      if(sEl&&eEl&&Number(eEl.max)===labels.length-1){ start=Math.min(Number(sEl.value),Number(eEl.value)); end=Math.max(Number(sEl.value),Number(eEl.value)); }
      const entries=[];
      chart.data.datasets.forEach((d,i)=>{
        if(!chart.isDatasetVisible(i))return;
        const arr=d.data||[];
        const ii=lastIndexNonNullInRange(arr,start,end);
        if(ii<0)return;
        const val=arr[ii];
        let text;
        if(d.yAxisID==='y1'){text=btcText(val);} 
        else if(/%|ROI|Growth/i.test(d.label||'')){text=pctText(val==null?0:val);} 
        else{ text=FMT_USD.format(val==null?0:val); }
        entries.push({label:d.label,value:text,date:labels[ii]||'',color:d.borderColor});
      });
      setChartFooter(entries);
    }

    /* ---------- Balances (VALR via Edge Function) ---------- */
    async function fetchBalances(customerId){
      if(!supabaseClient) throw new Error('Supabase not initialized');
      const { data, error } = await supabaseClient.functions.invoke('valr-balances', {
        body: { customer_id: customerId }
      });
      if(error){ throw new Error(error.message || 'Function error'); }
      return data;
    }

    function renderBalances(data){
      // HTML uses <tbody id="balancesTbody"> (not #balancesTable)
      const tb = document.getElementById('balancesTbody');
      if(!tb) throw new Error('balancesTbody not found (expected <tbody id="balancesTbody"> inside #balancesCard)');

      const toVal = (v)=> (v==null || v==='') ? '—' : String(v);

      // Table columns are: Asset | Available | Reserved
      const rows = [
        ['ZAR',  toVal(data?.zar?.available),  toVal(data?.zar?.reserved)],
        ['USDT', toVal(data?.usdt?.available), toVal(data?.usdt?.reserved)],
        ['BTC',  toVal(data?.btc?.available),  toVal(data?.btc?.reserved)],
        ['Staked USDT',      toVal(data?.usdtStakedQty ?? 'N/A'), '—'],
        ['USDT Staking APR', toVal(data?.usdtApr ?? 'N/A'), '—']
      ];

      tb.innerHTML = rows
        .map(([asset, avail, reserved]) => `<tr><td>${asset}</td><td>${avail}</td><td>${reserved}</td></tr>`)
        .join('');

      // Expose for other actions
      window._lastBalances = data;

      // Enable Convert button only if ZAR ≥ 15 and balances are visible
      const cz = document.getElementById('convertZarBtn');
      if (cz) {
        const zarAvail = Number(data?.zar?.available ?? 0);
        cz.disabled = !(zarAvail >= 15);
      }

      const card = document.getElementById('balancesCard');
      if (card) card.style.display='block';
    }

    function bindBalancesUI(){
      const btn     = document.getElementById('fetchBalancesBtn');
      const refresh = document.getElementById('refreshBalancesBtn');
      const hide    = document.getElementById('hideBalancesBtn');
      const convert = document.getElementById('convertZarBtn');   // NEW
      const ctxSel  = document.getElementById('customerSelect');

      async function doFetch(){
        clearInlineError('balancesError');
        const id = ctxSel?.value || '';
        if(!id){ alert('Select a customer in the top context bar first.'); return; }
        btn.disabled=true; if (refresh) refresh.disabled=true;
        btn.textContent='Fetching…';
        try{
          const data=await fetchBalances(id);
          renderBalances(data);
        }catch(e){
          console.error(e);
          showInlineError('balancesError', e.message || 'Could not fetch balances.');
        }finally{
          btn.disabled=false; if (refresh) refresh.disabled=false;
          btn.textContent='Show exchange balances';
          // Re-evaluate Convert button state after fetch
          if (convert) {
            const zarAvail = Number(window?._lastBalances?.zar?.available ?? 0);
            convert.disabled = !(zarAvail >= 15);
          }
        }
      }

      if(btn && !btn._bound){ btn.addEventListener('click', doFetch); btn._bound=true; }
      if(refresh && !refresh._bound){ refresh.addEventListener('click', doFetch); refresh._bound=true; }
      if(hide && !hide._bound){ hide.addEventListener('click', ()=>{ document.getElementById('balancesCard').style.display='none'; }); hide._bound=true; }

      // NEW: Convert ZAR → USDT via Edge Function
      if(convert && !convert._bound){
        convert.addEventListener('click', async ()=>{
          clearInlineError('balancesError');
          const id = ctxSel?.value || '';
          if(!id){ alert('Select a customer in the top context bar first.'); return; }

          convert.disabled = true;
          const oldText = convert.textContent;
          convert.textContent = 'Placing…';

          try{
            const { data, error } = await supabaseClient.functions.invoke('valr-convert-zar', {
              body: { customer_id: Number(id) }
            });
            if (error) throw error;
            alert(`Submitted convert order\nOrder ID: ${data?.order_id || '(n/a)'}\nQty: ${data?.qty || ''}\nPrice: ${data?.price || ''}`);

            // refresh balances after placement
            const fresh = await fetchBalances(id);
            renderBalances(fresh);
          }catch(e){
            console.error(e);
            showInlineError('balancesError', e.message || 'Convert order failed.');
          }finally{
            convert.textContent = oldText;
            const zarAvail = Number(window?._lastBalances?.zar?.available ?? 0);
            convert.disabled = !(zarAvail >= 15);
          }
        });
        convert._bound = true;
      }
    }

    /* ===== Tables under the chart (by trading_year) ===== */
    // ---- formatters (as requested)
    function buildTradingYearHeaders(years){
      if(!years || !years.length) return ['Metric'];
      const maxTY = Math.max(...years);
      const h = ['Metric'];
      years.forEach((ty, i) => h.push(`${ty===maxTY ? '*' : ''}Year ${i+1}`));
      return h;
    }
    // 0-decimals USD (BTC price)
    const fmtUSD0 = v => v == null ? '-' :
      Number(v).toLocaleString('en-US',{ style:'currency', currency:'USD', minimumFractionDigits:0, maximumFractionDigits:0 });
    // 2-decimals USD (Total Investment, Portfolio Value, USD Holdings)
    const fmtUSD2 = v => v == null ? '-' :
      Number(v).toLocaleString('en-US',{ style:'currency', currency:'USD', minimumFractionDigits:2, maximumFractionDigits:2 });
    // 8-decimals BTC (BTC Holdings)
    const fmtBTC8 = v => v == null ? '-' :
      Number(v).toLocaleString('en-US',{ minimumFractionDigits:8, maximumFractionDigits:8 });
    // 1-decimal % (ROI, CAGR) – DB stores fractions, so ×100
      const fmtPct1 = v => v == null ? '-' :
      `${Number(v*100).toLocaleString('en-US',{ minimumFractionDigits:1, maximumFractionDigits:1 })}%`;

    /* ---- Portfolio module table (uses #report-tables) ---- */
    async function renderPerformanceTable(customerId, reportType){
      const root = document.getElementById('report-tables');
      if (!root) return;
      if (!customerId){ root.innerHTML = ''; return; }
      root.innerHTML = '<div style="padding:.6rem 0;color:#6b7280;">Loading…</div>';

      const [{ data: advRows, error: advErr }, { data: stdRows, error: stdErr }] = await Promise.all([
        window.supabaseClient.from('real_customer_performance_annually')
          .select('trading_year, btc_closing_price_usd:latest_btc_closing_price_usd, total_dca_invested_usd:total_invested_usdt, portfolio_value_usd, closing_balance_btc, closing_balance_usd:closing_balance_usdt, total_roi_percent, cagr_percent')
          .eq('customer_id', customerId).order('trading_year', { ascending: true }),
        window.supabaseClient.from('real_std_compare_customer_performance_annually')
          .select('trading_year, portfolio_value_usd, total_roi_percent, cagr_percent')
          .eq('customer_id', customerId).order('trading_year', { ascending: true })
      ]);

      if (advErr){ root.innerHTML = `<div style="color:#b91c1c;background:#fee2e2;border:1px solid #fecaca;border-radius:10px;padding:.6rem 1rem;">${advErr.message}</div>`; return; }
      if ((reportType !== 'holdings') && stdErr){ root.innerHTML = `<div style="color:#b91c1c;background:#fee2e2;border:1px solid #fecaca;border-radius:10px;padding:.6rem 1rem;">${stdErr.message}</div>`; return; }

      const years   = (advRows || []).map(r => Number(r.trading_year));
      const headers = buildTradingYearHeaders(years);
      const stdByTY = new Map((stdRows||[]).map(r => [Number(r.trading_year), r]));

      let rows = [];
      if (reportType === 'holdings') {
        rows = [
          ['BTC Price',         ...(advRows||[]).map(r => fmtUSD0(r.btc_closing_price_usd))],
          ['Total Investment',  ...(advRows||[]).map(r => fmtUSD2(r.total_dca_invested_usd))],
          ['Portfolio Value',   ...(advRows||[]).map(r => fmtUSD2(r.portfolio_value_usd))],
          ['BTC Holdings',     ...(advRows||[]).map(r => fmtBTC8(r.closing_balance_btc))],
          ['Cumulative ROI',    ...(advRows||[]).map(r => fmtPct1(r.total_roi_percent))],
          ['Annualised Growth', ...(advRows||[]).map(r => fmtPct1(r.cagr_percent))],
          ['USD Holdings',      ...(advRows||[]).map(r => fmtUSD2(r.closing_balance_usd))],
        ];
      } else if (reportType === 'comp_value') {
        rows = [
          ['Advanced DCA<br>Portfolio Value', ...(advRows||[]).map(r => fmtUSD2(r.portfolio_value_usd))],
          ['Standard DCA<br>Comparative<br>Portfolio Value', ...(advRows||[]).map(r => fmtUSD2(stdByTY.get(Number(r.trading_year))?.portfolio_value_usd ?? null))],
        ];
      } else if (reportType === 'comp_roi') {
        rows = [
          ['Advanced DCA<br>Portfolio Total ROI', ...(advRows||[]).map(r => fmtPct1(r.total_roi_percent))],
          ['Standard DCA<br>Portfolio Total ROI', ...(advRows||[]).map(r => fmtPct1(stdByTY.get(Number(r.trading_year))?.total_roi_percent ?? null))],
        ];
      } else if (reportType === 'comp_agr') {
        rows = [
          ['Advanced DCA<br>Portfolio<br>Annualised CAGR', ...(advRows||[]).map(r => fmtPct1(r.cagr_percent))],
          ['Standard DCA<br>Portfolio<br>Annualised CAGR', ...(advRows||[]).map(r => fmtPct1(stdByTY.get(Number(r.trading_year))?.cagr_percent ?? null))],
        ];
      }

      const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
      const tbody = rows.map((row, i) => {
        const isMuted = (reportType.startsWith('comp_') && i === 1);
        const labelTd = `<td class="${isMuted ? 'metric-cell metric-muted' : 'metric-cell'}">${row[0]}</td>`;
        const cells   = row.slice(1).map(v => `<td>${v}</td>`).join('');
        return `<tr>${labelTd}${cells}</tr>`;
      }).join('');
      const colCount = headers.length || 1;
      const colgroup = `<colgroup>${Array.from({ length: colCount }, () => `<col style="width:${(100/colCount)}%;"></col>`).join('')}</colgroup>`;

      root.innerHTML = `<table class="report-table">${colgroup}${thead}<tbody>${tbody}</tbody></table>`;
    }

    async function renderBtPerformanceTable(btRunId, type){
      const table = document.getElementById('btYearlyTable');
      if (!table) return;

      const layoutType = type || btCurrentReportType || 'holdings';

      // No run selected yet
      if (!btRunId){
        table.innerHTML = '<tr><td colspan="8">Run a back-test to see annual results.</td></tr>';
        return;
      }

      try{
        const { data, error } = await supabaseClient
          .schema('lth_pvr_bt')
          .from('v_bt_results_annual')
          .select('*')
          .eq('bt_run_id', btRunId)
          .order('trading_year', { ascending: true });

        if (error){
          console.error('v_bt_results_annual error:', error);
          table.innerHTML = `<tr><td colspan="8">Could not load annual results: ${error.message}</td></tr>`;
          return;
        }

        const rows = data || [];
        if (!rows.length){
          table.innerHTML = '<tr><td colspan="8">No annual results for this back-test run.</td></tr>';
          return;
        }

        const usdFmt = new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
          maximumFractionDigits: 0
        });
        const btcFmt = new Intl.NumberFormat('en-US', {
          minimumFractionDigits: 0,
          maximumFractionDigits: 8
        });
        const pct = (v) => (v == null ? '–' : `${Number(v).toFixed(2)}%`);

        if (layoutType === 'holdings') {
          // 1) Back-test holdings table
          const header = `
            <tr>
              <th>Year</th>
              <th>BTC Price</th>
              <th>Total Investment (USDT)</th>
              <th>BTC Holdings</th>
              <th>USD Holdings</th>
              <th>NAV (USD)</th>
              <th>Cumulative ROI %</th>
              <th>CAGR %</th>
            </tr>
          `;
          const body = rows.map(r => `
            <tr>
              <td>${r.trading_year}</td>
              <td>${r.btc_price == null ? '–' : usdFmt.format(r.btc_price)}</td>
              <td>${r.total_investment == null ? '–' : usdFmt.format(r.total_investment)}</td>
              <td>${r.btc_holdings == null ? '–' : btcFmt.format(r.btc_holdings)}</td>
              <td>${r.usd_holdings == null ? '–' : usdFmt.format(r.usd_holdings)}</td>
              <td>${r.nav_usd == null ? '–' : usdFmt.format(r.nav_usd)}</td>
              <td>${pct(r.roi_percent)}</td>
              <td>${pct(r.cagr_percent)}</td>
            </tr>
          `).join('');
          table.innerHTML = header + body;

        } else if (layoutType === 'comp_value') {
          // 2) Comparison – Portfolio Value
          const header = `
            <tr>
              <th>Year</th>
              <th>LTH PVR DCA Portfolio Value</th>
              <th>Standard DCA Portfolio Value</th>
            </tr>
          `;
          const body = rows.map(r => `
            <tr>
              <td>${r.trading_year}</td>
              <td>${r.nav_usd == null ? '–' : usdFmt.format(r.nav_usd)}</td>
              <td>${r.std_nav_usd == null ? '–' : usdFmt.format(r.std_nav_usd)}</td>
            </tr>
          `).join('');
          table.innerHTML = header + body;

        } else if (layoutType === 'comp_roi') {
          // 3) Comparison – ROI (cumulative)
          const header = `
            <tr>
              <th>Year</th>
              <th>LTH PVR DCA Cumulative ROI %</th>
              <th>Standard DCA Cumulative ROI %</th>
            </tr>
          `;
          const body = rows.map(r => `
            <tr>
              <td>${r.trading_year}</td>
              <td>${pct(r.roi_percent)}</td>
              <td>${pct(r.std_roi_percent)}</td>
            </tr>
          `).join('');
          table.innerHTML = header + body;

        } else if (layoutType === 'comp_agr') {
          // 4) Comparison – Annualised Growth (CAGR)
          const header = `
            <tr>
              <th>Year</th>
              <th>LTH PVR DCA Annualised CAGR %</th>
              <th>Standard DCA Annualised CAGR %</th>
            </tr>
          `;
          const body = rows.map(r => `
            <tr>
              <td>${r.trading_year}</td>
              <td>${pct(r.cagr_percent)}</td>
              <td>${pct(r.std_cagr_percent)}</td>
            </tr>
          `).join('');
          table.innerHTML = header + body;

        } else {
          // Fallback: default to holdings layout
          return renderBtPerformanceTable(btRunId, 'holdings');
        }

      }catch(e){
        console.error('renderBtPerformanceTable error:', e);
        table.innerHTML = `<tr><td colspan="8">Error loading annual results: ${e.message || e}</td></tr>`;
      }
    }

    function renderReportForCurrentState(){
      if(!currentCustomerId){
        destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
        showChartNotice('Select a customer to view this report.'); document.getElementById('reportTitle').textContent='';
        renderPerformanceTable('', currentReportType); // clear table
        return;
      }
      hideChartNotice(); setCanvasVisible(true);

      if(currentReportType==='holdings'){
        if(!advData||!advData.length){
          destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
          showChartNotice('No transactions found for this customer.'); setReportTitle(currentFirst,currentLast);
          renderPerformanceTable(currentCustomerId, currentReportType);
          return;
        }
        renderHoldingsChart(advData,currentFirst,currentLast);
        renderPerformanceTable(currentCustomerId, currentReportType);
      }else if(currentReportType==='comp_value'){
        if((!advData||!advData.length)&&(!stdData||!stdData.length)){
          destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
          showChartNotice('No portfolio values found for this customer.'); document.getElementById('reportTitle').textContent='';
          renderPerformanceTable(currentCustomerId, currentReportType);
          return;
        }
        renderCompPortfolioValueChart(advData||[],stdData||[],currentFirst,currentLast);
        renderPerformanceTable(currentCustomerId, currentReportType);
      }else if(currentReportType==='comp_roi'){
        if((!advData||!advData.length)&&(!stdData||!stdData.length)){
          destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
          showChartNotice('No ROI values found for this customer.'); document.getElementById('reportTitle').textContent='';
          renderPerformanceTable(currentCustomerId, currentReportType);
          return;
        }
        renderCompROIChart(advData||[],stdData||[],currentFirst,currentLast);
        renderPerformanceTable(currentCustomerId, currentReportType);
      }else if(currentReportType==='comp_agr'){
        if((!advData||!advData.length)&&(!stdData||!stdData.length)){
          destroyChart(); setCanvasVisible(false); setResetZoomEnabled(false); clearChartFooter(); showRange(false);
          showChartNotice('No annualised growth values found for this customer.'); document.getElementById('reportTitle').textContent='';
          renderPerformanceTable(currentCustomerId, currentReportType);
          return;
        }
        renderCompAGRChart(advData||[],stdData||[],currentFirst,currentLast);
        renderPerformanceTable(currentCustomerId, currentReportType);
      }
    }

    /* =================== Customer Maintenance JS =================== */
    function cmShowAlert(type, msg){
      const el = document.getElementById('cmAlert');
      el.style.display = 'block';
      el.textContent = msg;
      el.style.borderColor = type==='error' ? '#fecaca' : '#bbf7d0';
      el.style.background = type==='error' ? '#fee2e2' : '#ecfdf5';
      el.style.color = type==='error' ? '#7f1d1d' : '#065f46';
    }
    function cmHideAlert(){ const el=document.getElementById('cmAlert'); el.style.display='none'; el.textContent=''; }

    function cmNum(v, fallback=0){ const n = Number(String(v ?? '').trim()); return Number.isFinite(n) ? n : fallback; }
    function cmDate(v){ if(!v) return null; const d = new Date(v); return isNaN(d) ? null : d.toISOString(); }

    function cmBindTabs(){
      const bNew = document.getElementById('cmTabNew');
      const bEdit = document.getElementById('cmTabEdit');
      const fNew = document.getElementById('cmFormNew');
      const fEdit = document.getElementById('cmFormEdit');
      function set(active){
        cmHideAlert();
        if(active==='new'){ bNew.classList.add('cm-tab--active'); bEdit.classList.remove('cm-tab--active'); fNew.style.display='block'; fEdit.style.display='none'; }
        else{ bEdit.classList.add('cm-tab--active'); bNew.classList.remove('cm-tab--active'); fEdit.style.display='block'; fNew.style.display='none'; }
      }
      if(bNew && !bNew._bound){ bNew.addEventListener('click',()=>set('new')); bNew._bound=true; }
      if(bEdit && !bEdit._bound){ bEdit.addEventListener('click',()=>set('edit')); bEdit._bound=true; }
      set('new');
    }

    function cmWireFrequency(formEl){
      const freq = formEl.querySelector('select[name="recurring_contribution_frequency"]');
      const amt  = formEl.querySelector('input[name="recurring_contribution_zar"]');
      const star = formEl.querySelector('[data-cm-req="freq"]');
      function sync(){
        const val = freq ? String(freq.value) : '';
        if(!freq || !amt) return;
        if(val === 'None'){
          amt.value = '0';
          amt.disabled = true;
          amt.required = false;
          if(star) star.style.visibility='hidden';
        }else{
          amt.disabled = false;
          amt.required = true;
          if(star) star.style.visibility='visible';
        }
      }
      if(freq && !freq._bound){ freq.addEventListener('change', sync); freq._bound=true; }
      sync();
    }

    function cmValidateId13(val){
      return /^\d{13}$/.test(String(val||'').trim());
    }

    async function cmCreateCustomer(payload){
      const row = {
        first_names: payload.first_names.trim(),
        last_name: payload.last_name.trim(),
        email_address: payload.email_address.trim(),
        cellphone_number: payload.cellphone_number.trim(),
        id_number: payload.id_number.trim(),
        trade_start_date: cmDate(payload.trade_start_date),
        recurring_contribution_frequency: payload.recurring_contribution_frequency,
        recurring_contribution_zar: cmNum(payload.recurring_contribution_zar || 0, 0),
        upfront_contribution_zar: cmNum(payload.upfront_contribution_zar, 0),
        upfront_contribution_btc: cmNum(payload.upfront_contribution_btc, 0),
        exchange_api_name: payload.exchange_api_name || null,
        exchange_username: payload.exchange_username || null,
        exchange_password: payload.exchange_password || null,
        exchange_api_key: payload.exchange_api_key || null,
        exchange_api_secret: payload.exchange_api_secret || null,
        exchange_btc_wallet_address: payload.exchange_btc_wallet_address || null,
        customer_status: payload.customer_status || 'Active'
      };
      const { data, error } = await supabaseClient.from('customer_details').insert(row).select('customer_id').single();
      if(error) throw error;
      return data;
    }

    async function cmUpdateCustomer(id, payload){
      const row = {
        first_names: payload.first_names.trim(),
        last_name: payload.last_name.trim(),
        email_address: payload.email_address.trim(),
        cellphone_number: payload.cellphone_number.trim(),
        id_number: payload.id_number.trim(),
        trade_start_date: cmDate(payload.trade_start_date),
        recurring_contribution_frequency: payload.recurring_contribution_frequency,
        recurring_contribution_zar: cmNum(payload.recurring_contribution_zar || 0, 0),
        upfront_contribution_zar: cmNum(payload.upfront_contribution_zar, 0),
        upfront_contribution_btc: cmNum(payload.upfront_contribution_btc, 0),
        exchange_api_name: payload.exchange_api_name || null,
        exchange_username: payload.exchange_username || null,
        exchange_password: payload.exchange_password || null,
        exchange_api_key: payload.exchange_api_key || null,
        exchange_api_secret: payload.exchange_api_secret || null,
        exchange_btc_wallet_address: payload.exchange_btc_wallet_address || null,
        customer_status: payload.customer_status || 'Active'
      };
      const { error } = await supabaseClient.from('customer_details').update(row).eq('customer_id', id);
      if(error) throw error;
    }

    async function cmLoadCustomer(id){
      const { data, error } = await supabaseClient
        .from('customer_details')
        .select('customer_id, first_names, last_name, email_address, cellphone_number, id_number, trade_start_date, recurring_contribution_frequency, recurring_contribution_zar, upfront_contribution_zar, upfront_contribution_btc, exchange_api_name, exchange_username, exchange_password, exchange_api_key, exchange_api_secret, exchange_btc_wallet_address, customer_status')
        .eq('customer_id', id).single();
      if(error) throw error;
      return data;
    }

    function cmFillForm(formEl, row){
      formEl.reset();
      const set = (name, val) => { const el=formEl.querySelector(`[name="${name}"]`); if(!el) return; if(el.type==='date' && val){ el.value = String(val).slice(0,10); } else { el.value = (val ?? ''); } };
      ['first_names','last_name','email_address','cellphone_number','id_number','recurring_contribution_frequency','recurring_contribution_zar','upfront_contribution_zar','upfront_contribution_btc','exchange_api_name','exchange_username','exchange_password','exchange_api_key','exchange_api_secret','exchange_btc_wallet_address','customer_status'].forEach(k=>set(k,row[k]));
      set('trade_start_date', row.trade_start_date);
      cmWireFrequency(formEl);
    }

    function cmSerialize(formEl){
      const data = Object.fromEntries(new FormData(formEl).entries());

      // Required basics (includes frequency)
      const must = ['first_names','last_name','email_address','cellphone_number','id_number','recurring_contribution_frequency','customer_status'];
      for(const k of must){ if(!String(data[k]||'').trim()) throw new Error(`Please complete the "${k.replaceAll('_',' ')}" field.`); }

      // ID number 13-digit check
      if(!cmValidateId13(data.id_number)){ throw new Error('ID number must be a 13-digit number.'); }

      // Frequency logic
      const freq = String(data.recurring_contribution_frequency).trim();
      if(freq === 'None'){
        data.recurring_contribution_zar = '0';
      }else{
        if(!data.recurring_contribution_zar || Number(data.recurring_contribution_zar)<=0){
          throw new Error('Recurring contribution (ZAR) is required and must be > 0 when Recurrence is not None.');
        }
      }

      // Optional amounts default to 0
      if(!data.upfront_contribution_zar) data.upfront_contribution_zar = '0';
      if(!data.upfront_contribution_btc) data.upfront_contribution_btc = '0';

      return data;
    }

    function cmSetNewDefaults(formEl){
      // Set default selections/values when the form is reset or after create
      const freq = formEl.querySelector('select[name="recurring_contribution_frequency"]');
      const upZ  = formEl.querySelector('input[name="upfront_contribution_zar"]');
      const upB  = formEl.querySelector('input[name="upfront_contribution_btc"]');
      if(freq) freq.value = 'Monthly';
      if(upZ) upZ.value = '0';
      if(upB) upB.value = '0';
      cmWireFrequency(formEl);
    }

    function cmBindForms(){
      // New
      const fNew = document.getElementById('cmFormNew');
      if(fNew && !fNew._bound){
        cmWireFrequency(fNew);
        fNew.addEventListener('submit', async (e)=>{
          e.preventDefault(); cmHideAlert();
          try{
            const payload = cmSerialize(fNew);
            const res = await cmCreateCustomer(payload);
            cmShowAlert('success', `Client created (ID ${res.customer_id}).`);
            fNew.reset();
            cmSetNewDefaults(fNew);
            await loadCustomers();
            const editSel = document.getElementById('cmEditSelect');
            if(editSel){ editSel.value = String(res.customer_id); editSel.dispatchEvent(new Event('change')); }
          }catch(err){ cmShowAlert('error', err.message || 'Could not create client.'); }
        });
        // Ensure defaults after manual reset
        fNew.addEventListener('reset', ()=>setTimeout(()=>cmSetNewDefaults(fNew)));
        fNew._bound = true;
      }

      // Edit
      const fEdit = document.getElementById('cmFormEdit');
      const sel = document.getElementById('cmEditSelect');
      if(sel && !sel._bound){
        sel.addEventListener('change', async (e)=>{
          cmHideAlert();
          const id = e.target.value;
          if(!id){ fEdit.reset(); return; }
          try{
            const row = await cmLoadCustomer(id);
            cmFillForm(fEdit, row);
            fEdit.dataset.customerId = String(id);
          }catch(err){ cmShowAlert('error', err.message || 'Failed to load client.'); }
        });
        sel._bound = true;
      }
      if(fEdit && !fEdit._bound){
        cmWireFrequency(fEdit);
        fEdit.addEventListener('submit', async (e)=>{
          e.preventDefault(); cmHideAlert();
          const id = e.currentTarget.dataset.customerId;
          if(!id) return cmShowAlert('error','Please select a client to edit.');
          try{
            const payload = cmSerialize(fEdit);
            await cmUpdateCustomer(id, payload);
            cmShowAlert('success', 'Changes saved.');
            await loadCustomers();
          }catch(err){ cmShowAlert('error', err.message || 'Could not save changes.'); }
        });
        const delBtn = document.getElementById('cmDeleteBtn');
        if(delBtn && !delBtn._bound){
          delBtn.addEventListener('click', async ()=>{
            cmHideAlert();
            const id = fEdit.dataset.customerId;
            if(!id) return cmShowAlert('error','Select a client first.');
            if(!confirm('Delete this client? This cannot be undone.')) return;
            try{
              const { error } = await supabaseClient.from('customer_details').delete().eq('customer_id', id);
              if(error) throw error;
              cmShowAlert('success','Client deleted.');
              fEdit.reset(); document.getElementById('cmEditSelect').value='';
              await loadCustomers();
            }catch(err){ cmShowAlert('error', err.message || 'Delete failed.'); }
          });
          delBtn._bound=true;
        }
        fEdit._bound = true;
      }
    }

    // Hook into init when customers are loaded
    (function cmInitAfterLoad(){
      const ready = () => typeof supabaseClient!=='undefined' && supabaseClient && Array.isArray(customersCache);
      const interval = setInterval(()=>{
        if(!ready()) return;
        clearInterval(interval);
        cmBindTabs();
        cmBindForms();
      }, 200);
    })();

    /* ------------------ INIT ------------------ */
    (async function init(){
      if(!location.hash) location.hash = '#import-module';

      await loadExistingDates();

      const previewBtn=document.getElementById('previewBtn');
      if(previewBtn){
        previewBtn.addEventListener('click',function(){
          if(!hasPapa){showInlineError('inlineError','CSV parser is unavailable.');return;}
          clearInlineError('inlineError');
          const file=document.getElementById('csvFileInput').files[0]; if(!file) return alert('Please select a CSV file.');
          Papa.parse(file,{header:true,skipEmptyLines:true,complete:function(results){
            const seen=new Set();
            previewRows=results.data.map((row,i)=>{
              const d=normalizeDate(row.date_closing);
              const dupDb=existingDates.has(d);
              const dupFile=seen.has(d);
              if(!dupFile)seen.add(d);
              return{
                index:i+1,
                date_closing:d,
                btc_closing_price_usd:row.btc_closing_price_usd,
                smoothed_risk_score:row.smoothed_risk_score,
                omega_score:row.omega_score,
                omega_on_off:row.omega_on_off,
                sab_below_neg_1sd:row.sab_below_neg_1sd,
                sab_below_neg_2sd:row.sab_below_neg_2sd,
                isDuplicate:dupDb||dupFile
              };
            });
            renderPreview();
          },error:function(err){showInlineError('inlineError','Error parsing CSV: '+err.message);console.error(err);}});
        });
        document.getElementById('importBtn').addEventListener('click',importRows);
      }

      await loadCustomers();
      await loadOrgContext();

      // Initialise the LTH PVR Back-Testing form (strategy selector + inputs + Run button)
      initBtRunForm();

      /* Initialize Choices for Report Type too (search disabled) so both boxes match exactly */
      const rtSel=document.getElementById('reportTypeSelect');

      if(window.Choices){
        reportTypeChoices=new Choices(rtSel,{searchEnabled:false,shouldSort:false,allowHTML:false,itemSelectText:''});
      }

      const resetBtn=document.getElementById('resetZoomBtn');
      if(resetBtn){resetBtn.addEventListener('click',function(){if(chartInstance&&typeof chartInstance.resetZoom==='function'){chartInstance.resetZoom();resetRangeToFull();}});}

      const showAllBtn=document.getElementById('showAllBtn');
      const hideAllBtn=document.getElementById('hideAllBtn');
      if(showAllBtn){showAllBtn.addEventListener('click',function(){if(!chartInstance)return;let changed=false;chartInstance.data.datasets.forEach((ds,i)=>{if(!chartInstance.isDatasetVisible(i)){chartInstance.setDatasetVisibility(i,true);changed=true;}});if(changed)chartInstance.update();rebuildFooterForChart(chartInstance);});}
      if(hideAllBtn){hideAllBtn.addEventListener('click',function(){if(!chartInstance)return;let changed=false;chartInstance.data.datasets.forEach((ds,i)=>{if(chartInstance.isDatasetVisible(i)){chartInstance.setDatasetVisibility(i,false);changed=true;}});if(changed)chartInstance.update();rebuildFooterForChart(chartInstance);});}

//      const repSel=document.getElementById('reportTypeSelect');
//      if(repSel){repSel.addEventListener('change',function(e){clearChartFooter();currentReportType=e.target.value;renderReportForCurrentState();});}
//      renderReportForCurrentState();

      // Ensure default values for New form on first load
      const fNew = document.getElementById('cmFormNew');
      if(fNew){ cmSetNewDefaults(fNew); }

      // Bind balances UI handlers
      bindBalancesUI();
    })();
  </script>

  <script>
  /* ===== ADMIN MODULE (drop-in, robust) ===== */
  (function(){
    const ADMIN_EMAIL = 'davin.gaier@gmail.com';

    function isAdmin(email){ return !!email && email.toLowerCase() === ADMIN_EMAIL.toLowerCase(); }

    // ---- UI flip helpers ----
    function flipUI(email){
      const authCard = document.getElementById('adminAuthCard');
      const appCard  = document.getElementById('adminApp');
      const signed   = document.getElementById('adminSignedInAs');
      const allowed  = isAdmin(email);

      if (authCard) authCard.style.display = allowed ? 'none'  : 'block';
      if (appCard)  appCard.style.display  = allowed ? 'block' : 'none';
      if (signed)   signed.textContent     = allowed ? `Signed in as ${email}` : '';

      if (allowed) {
        const init = (window.adminInitApp || adminInitApp);
        if (typeof init === 'function') init();
      }
    }

    async function waitForSb(timeoutMs = 8000){
      const start = Date.now();
      while(!window.supabaseClient){
        await new Promise(r => setTimeout(r, 50));
        if(Date.now() - start > timeoutMs) return null;
      }
      return window.supabaseClient;
    }

    async function paintFromSession(){
      try{
        const sb = await waitForSb();
        if(!sb?.auth) return;
        const { data: { session } } = await sb.auth.getSession();
        flipUI(session?.user?.email || null);
      }catch(e){ console.warn('[ADMIN] getSession failed', e); }
    }

    // ---- Data loaders ----
    async function adminLoadOrgs(){
      const sel = document.getElementById('adminOrgSelect');
      if(!sel) return;
      const { data, error } = await window.supabaseClient.rpc('my_orgs');
      if(error){ console.error('[ADMIN] my_orgs error:', error); sel.innerHTML = '<option value="">No orgs</option>'; return; }

      const list = data || [];
      sel.innerHTML = list.length
        ? list.map(o=>`<option value="${o.id}">${o.name} (${o.role})</option>`).join('')
        : '<option value="">No orgs</option>';

      if (!sel._bound){
        sel.addEventListener('change', adminLoadMembers);
        sel._bound = true;
      }
    }

    async function adminLoadMembers(){
      const orgSel = document.getElementById('adminOrgSelect');
      const tb = document.querySelector('#adminMembersTable tbody');
      if(!orgSel || !tb) return;

      const orgId = orgSel.value;
      if(!orgId){ tb.innerHTML = '<tr><td colspan="4">Select an organisation.</td></tr>'; return; }

      const { data, error } = await window.supabaseClient.rpc('org_member_list', { p_org_id: orgId });
      if(error){ console.error('[ADMIN] org_member_list error:', error); tb.innerHTML = `<tr><td colspan="4">${error.message}</td></tr>`; return; }

      const rows = (data || []).map(r=>{
        const dt = new Date(r.created_at).toISOString().slice(0,19).replace('T',' ');
        return `<tr>
          <td>${r.email}</td>
          <td>${r.role}</td>
          <td>${dt}</td>
          <td><button data-email="${r.email}" class="btn-remove">Remove</button></td>
        </tr>`;
      });
      tb.innerHTML = rows.join('') || '<tr><td colspan="4">No members.</td></tr>';

      tb.querySelectorAll('.btn-remove').forEach(b=>{
        if(!b._bound){
          b.addEventListener('click', async ()=>{
            const email = b.getAttribute('data-email');
            if(!confirm(`Remove ${email}?`)) return;
            const { error } = await window.supabaseClient.rpc('org_member_remove', { p_org_id: orgSel.value, p_email: email });
            if(error){ alert(error.message || 'Remove failed'); return; }
            await adminLoadMembers();
          });
          b._bound = true;
        }
      });
    }

    // ---- Handlers ----
    function bindAdminHandlers(){
      const loginForm = document.getElementById('adminLoginForm');
      const signInBtn = document.getElementById('adminSignInBtn');
      const signOutBtn = document.getElementById('adminSignOut');
      const refreshBtn = document.getElementById('adminRefresh');
      const addForm = document.getElementById('adminAddForm');

      if (loginForm && !loginForm._cancel){
        loginForm.addEventListener('submit', (e)=>{ e.preventDefault(); e.stopPropagation(); return false; });
        loginForm._cancel = true;
      }

      const doLogin = async (e)=>{
        if (e){ e.preventDefault(); e.stopPropagation(); }
        console.log('[ADMIN] Sign-in clicked');
        if (!window.supabaseClient?.auth){ alert('Supabase not ready'); return; }

        const email = document.getElementById('adminEmail').value.trim();
        const password = document.getElementById('adminPassword').value;

        const { data, error } = await window.supabaseClient.auth.signInWithPassword({ email, password });
        console.log('[ADMIN] signInWithPassword result:', { hasUser: !!data?.user, error });
        if (error){ alert(error.message || 'Sign-in failed'); return; }

        if (data?.user?.email) flipUI(data.user.email);
        await paintFromSession();
        setTimeout(paintFromSession, 300);
      };

      if (signInBtn && !signInBtn._bound){ signInBtn.addEventListener('click', doLogin); signInBtn._bound = true; }
      if (signOutBtn && !signOutBtn._bound){
        signOutBtn.addEventListener('click', async ()=>{
          await window.supabaseClient.auth.signOut();
          flipUI(null);
        });
        signOutBtn._bound = true;
      }

      if (refreshBtn && !refreshBtn._bound){
        refreshBtn.addEventListener('click', adminLoadMembers);
        refreshBtn._bound = true;
      }

      if (addForm && !addForm._bound) {
        addForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          e.stopPropagation();

          // ✅ Read values from the DOM
          const orgId = (document.getElementById('adminOrgSelect') || {}).value || '';
          const email = (document.getElementById('adminAddEmail') || {}).value.trim();
          const role  = (document.getElementById('adminAddRole') || {}).value || 'viewer';
          const pw    = (document.getElementById('adminAddPassword') || {}).value.trim();

          if (!orgId) return alert('Select an organisation first.');
          if (!email) return alert('Enter an email address.');

          // Optional: simple busy state
          const btn = addForm.querySelector('button[type="submit"]');
          if (btn) { btn.disabled = true; btn.textContent = 'Working…'; }

          try {
            // Call your Edge Function (it creates the user and adds org membership)
            const { data, error } = await window.supabaseClient.functions.invoke('admin-create-user', {
              body: { org_id: orgId, email, role, ...(pw ? { password: pw } : {}) }
            });

            if (error || data?.error) {
              const msg = data?.error || error?.message || 'Edge Function error';
              throw new Error(msg);
            }

            if (!pw) alert('User created. A secure temporary password was generated and emailed to them.');
            // Refresh the table
            await adminLoadMembers();

            // Clear inputs
            (document.getElementById('adminAddEmail') || {}).value = '';
            (document.getElementById('adminAddPassword') || {}).value = '';
          } catch (err) {
            console.error('[ADMIN] create-user failed:', err);
            alert(err.message || 'Create user failed');
          } finally {
            if (btn) { btn.disabled = false; btn.textContent = 'Add / Update'; }
          }
        });
        addForm._bound = true;
      }
    }

    async function adminInitApp(){
      try { await adminLoadOrgs(); }    catch(e){ console.warn('[ADMIN] load orgs:', e); }
      try { await adminLoadMembers(); } catch(e){ console.warn('[ADMIN] load members:', e); }
      try { bindAdminHandlers(); }      catch(_){ /* already bound */ }
    }

    // Expose to avoid scope issues from other scripts
    window.adminLoadOrgs     = adminLoadOrgs;
    window.adminLoadMembers  = adminLoadMembers;
    window.adminInitApp      = adminInitApp;
    window.bindAdminHandlers = bindAdminHandlers;

    // ---- BOOT ----
    bindAdminHandlers();

    // paint on auth changes
    if (window.supabaseClient?.auth?.onAuthStateChange){
      window.supabaseClient.auth.onAuthStateChange((_evt, session)=>{
        console.log('[ADMIN] auth event:', _evt, session?.user?.email);
        flipUI(session?.user?.email || null);
      });
    }

    // first paint
    paintFromSession();
  })();
  </script>


  <!-- Final CSS overrides to guarantee alignment (left text, centered block) -->
  <style>
    .reports-controls-outer{display:flex !important;justify-content:center !important;align-items:center !important;width:100% !important;}
    .reports-controls{display:grid !important;grid-template-columns:max-content var(--control-width) max-content var(--control-width) !important;column-gap:1rem !important;row-gap:.75rem !important;width:auto !important;align-items:center !important;}
    .reports-controls label{justify-self:end !important;}
    .reports-controls select{text-align:left !important;}
    .reports-controls .choices,
    .reports-controls .choices__inner,
    .reports-controls .choices__list--single,
    .reports-controls .choices__item,
    .reports-controls .choices__input{text-align:left !important;}
    .reports-controls .choices__list--single{justify-content:flex-start !important;}
    @media (max-width:760px){
      .reports-controls{grid-template-columns:1fr !important;justify-items:center !important;}
      .reports-controls label{justify-self:center !important;}
    }

    /* === Performance tables under the chart === */
    .report-table{ table-layout: fixed; width:96%; max-width:1280px; }
    .report-table th, .report-table td{ word-wrap: break-word; white-space: normal; }
    
    .report-tables-wrapper{
      display:flex;
      justify-content:center;
      margin-top:16px;
    }
    .report-table{
      width:96%;
      max-width:1280px;
      border-collapse:collapse;
      font-family: 'Aptos', system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      font-size:13px;
      text-align:left;
    }
    .report-table th,.report-table td{
      padding:10px 12px;
      border:1px solid #d7d7d7;
      white-space:nowrap;
    }
    .report-table thead th{
      background:#e5e7eb;     /* header grey like screenshots */
      font-weight:700;
      text-align:center;
    }
    .report-table tbody tr:nth-child(odd) td{ background:#f3f4f6; } /* zebra */
    .report-table td.metric-cell{ font-weight:700; color:#0f172a; }
    .report-table td.metric-muted{ color:#9ca3af; font-weight:600; } /* “comparison” second row */
    .report-table{ table-layout: fixed; width:96%; max-width:1280px; }
    .report-table th, .report-table td{ word-wrap: break-word; white-space: normal; }

    /* Hide old CBM Allocate + Convert controls, but keep Scan visible */
    #balance-maintenance-module #bmAllocBtn,
    #balance-maintenance-module #bmConvertBtn,
    #balance-maintenance-module #bmConvertMode {
      display: none !important;
    }

    /* Back-test form extras */
    .bt-form-actions {
      grid-column: 1 / -1;          /* span full width of the grid */
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.35rem;
      margin-top: 0.5rem;
    }

    #btRunBtn {
      min-width: 9rem;
    }

    #btInlineError.inline-error {
      color: #b91c1c;
      font-size: 0.85rem;
    }

    .bt-note {
      font-size: 0.85rem;
      color: #6b7280;
      max-width: 480px;
    }

    /* Executed-orders collapsible */
    .executed-collapsible summary{cursor:pointer;font-weight:600;margin:.5rem 0}
    .executed-list table{width:100%;border-collapse:collapse}
    .executed-list th, .executed-list td { border:1px solid #eee; padding:.4rem; font-size:.9rem }
    .executed-list .muted{opacity:.7}

    /* Hide global Customer selector ONLY on the multi-customer Customer Transactions module */
    body[data-active-module="transactions-module"] #ctxCustomerGroup{
      display: none !important;
    }

    </style>


  <noscript>
    <div style="padding:1em;margin:1em;border:1px solid var(--border);border-radius:10px;background:#fff3cd;color:#7a5a00;">
      This page needs JavaScript enabled.
    </div>
  </noscript>

  <script>
    /* =========================
       Export Customer Charts to PDF (improved)
       - Robust logo capture
       - True landscape pages
       - Smart chart/table scaling
       - AI narrative fetch (fallback to DOM)
       ========================= */
    (function(){
      const exportBtn = document.getElementById('exportPdfBtn');
      if (!exportBtn) return;

      // ---- Configuration you can tweak ----
      const EDGE_FUNCTION_NARRATIVE = 'chart-narrative'; // <-- set to your actual EF name
      const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';

      // ---- Small helpers ----
      function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
      function normalizeDate(val){
        if (val == null) return '';
        const s = String(val).trim();

        // Already a plain calendar date (YYYY-MM-DD or YYYY/MM/DD)
        if (/^\d{4}[-/]\d{2}[-/]\d{2}$/.test(s)) return s.slice(0, 10);

        // Compact yyyymmdd
        const m = s.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (m) return `${m[1]}-${m[2]}-${m[3]}`;

        // Fallback: parse and render as local date (no UTC shift)
        const t = Date.parse(s);
        if (!Number.isNaN(t)) {
          const d = new Date(t);
          const y = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          const dd = String(d.getDate()).padStart(2, '0');
          return `${y}-${mm}-${dd}`;
        }

        return s;
      }
      
      function disclaimer(){ return 'This report is for information only and is not financial advice. Past performance is not indicative of future results.'; }

      async function elementToPng(el, widthPx){
        const scale = Math.min(2, (widthPx || 1400) / Math.max(1200, el.offsetWidth || 1200));
        const canvas = await html2canvas(el, { scale });
        return canvas.toDataURL('image/png', 1.0);
      }

      // Try several ways to get a logo image as a dataURL
      async function getLogoDataUrl(){
        const img = document.getElementById('pdfLogo');
        if (!img) return null;

        // ensure image is loaded
        if (!img.complete || !img.naturalWidth) {
          await new Promise((res, rej) => {
            img.addEventListener('load', res, { once:true });
            img.addEventListener('error', () => rej(new Error('Logo failed to load')), { once:true });
          });
        }
        // draw it to a canvas → dataURL (works for relative paths without CORS headaches)
        const can = document.createElement('canvas');
        can.width = img.naturalWidth;
        can.height = img.naturalHeight;
        const ctx = can.getContext('2d');
        ctx.drawImage(img, 0, 0);
        return can.toDataURL('image/png', 1.0);
      }

      // Build offscreen chart PNG so we don’t disturb your on-screen chart
      async function buildChartImage({ type, advRows, stdRows }){
        const c = document.createElement('canvas'); c.width = 1400; c.height = 650;
        const ctx = c.getContext('2d');
        const labelsFrom = (rows)=> (rows||[]).map(r=> normalizeDate(r.transaction_date));
        const mergeLabels = (a,b)=> Array.from(new Set([...(a||[]), ...(b||[])])).sort();
        const col = {
          btc: cssVar('--series-btc-price') || '#ff8c00',
          inv: cssVar('--series-invested') || '#000000',
          adv: cssVar('--series-adv-value') || '#22c55e',
          usd: cssVar('--series-usd-balance') || '#60a5fa',
          btcBal: cssVar('--series-btc-balance') || '#ef4444',
          compAdv: cssVar('--series-comp-adv') || '#032C48',
          compStd: cssVar('--series-comp-std') || '#BEBEBE'
        };

        let chart;
        if(type === 'holdings'){
          const labels = labelsFrom(window.advData||[]);
          chart = new Chart(ctx, {
            type:'line',
            data:{labels,
              datasets:[
                { label:'BTC Closing Price', data:(window.advData||[]).map(r=>r.btc_closing_price_usd), borderColor:col.btc, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label:'Total Investment',  data:(window.advData||[]).map(r=>r.total_dca_invested_usd), borderColor:col.inv, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label:'Advanced DCA Portfolio Value', data:(window.advData||[]).map(r=>r.portfolio_value_usd), borderColor:col.adv, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label:'USD Balance',       data:(window.advData||[]).map(r=>r.closing_balance_usd), borderColor:col.usd, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label:'BTC Balance',       data:(window.advData||[]).map(r=>r.closing_balance_btc), borderColor:col.btcBal, fill:false, pointRadius:0, tension:.22, borderWidth:2 }
              ]},
            options:{ responsive:false, animation:false, plugins:{legend:{position:'top'}} }
          });
        } else {
          const L1 = labelsFrom(window.advData||[]), L2 = labelsFrom(window.stdData||[]), labels = mergeLabels(L1,L2);
          const key = type==='comp_value' ? 'portfolio_value_usd' : (type==='comp_roi' ? 'total_roi_percent' : 'cagr_percent');
          const toMap = (rows)=> { const m={}; (rows||[]).forEach(r=> m[normalizeDate(r.transaction_date)] = r[key]); return labels.map(d=> m[d] ?? null); };
          chart = new Chart(ctx, {
            type:'line',
            data:{labels,
              datasets:[
                { label: type==='comp_value' ? 'Advanced DCA Portfolio Value' : (type==='comp_roi' ? 'Advanced DCA ROI %' : 'Advanced DCA Ann. Growth %'),
                  data: toMap(window.advData), borderColor:col.compAdv, fill:false, pointRadius:0, tension:.22, borderWidth:2 },
                { label: type==='comp_value' ? 'Standard DCA Portfolio Value' : (type==='comp_roi' ? 'Standard DCA ROI %' : 'Standard DCA Ann. Growth %'),
                  data: toMap(window.stdData), borderColor:col.compStd, fill:false, pointRadius:0, tension:.22, borderWidth:2 }
              ]},
            options:{ responsive:false, animation:false, plugins:{legend:{position:'top'}} }
          });
        }
        await new Promise(r=>setTimeout(r,10));
        const dataUrl = c.toDataURL('image/png', 1.0);
        chart.destroy();
        return dataUrl;
      }

      // Yearly table builders (use your snapshots views)
      function fmtUSD(v){ return v==null ? '-' : Number(v).toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0}); }
      function fmtBTC(v){ return v==null ? '-' : Number(v).toLocaleString('en-US',{minimumFractionDigits:3,maximumFractionDigits:3}); }
      function fmtPct(v){ 
        if (v==null) return '-'; 
        const n = Number(v)*100; 
        return `${n.toLocaleString('en-US',{maximumFractionDigits:0})}%`; 
      }
      function headersByYears(advRows){
        const years = (advRows||[]).map(r => Number(r.trading_year));
        if(!years.length) return ['Metric'];
        const maxTY = Math.max(...years);
        const h = ['Metric']; years.forEach((ty,i) => h.push(`${ty===maxTY ? '*' : ''}Year ${i+1}`));
        return h;
      }

      function buildYearTableHTML(reportType, advRows, stdRows){
        const fmtUSD = (v)=> v==null ? '-' : Number(v).toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0});
        const fmtBTC = (v)=> v==null ? '-' : Number(v).toLocaleString('en-US',{minimumFractionDigits:3,maximumFractionDigits:3});
        const fmtPct = (v)=> v==null ? '-' : `${Number(v).toLocaleString('en-US',{maximumFractionDigits:0})}%`;

        const headers = headersByYears(advRows);
        const stdByTY = new Map((stdRows||[]).map(r => [Number(r.trading_year), r]));

        let rows = [];
        if (reportType === 'holdings'){
          rows = [
            ['BTC Price',           ...(advRows||[]).map(r => fmtUSD(r.btc_closing_price_usd))],
            ['Total Investment',    ...(advRows||[]).map(r => fmtUSD(r.total_dca_invested_usd))],
            ['Portfolio Value',     ...(advRows||[]).map(r => fmtUSD2(r.portfolio_value_usd))],
            ['BTC Holdings',       ...(advRows||[]).map(r => fmtBTC(r.closing_balance_btc))],
            ['Cumulative ROI',      ...(advRows||[]).map(r => fmtPct1(r.total_roi_percent))],
            ['Annualised Growth',   ...(advRows||[]).map(r => fmtPct1(r.cagr_percent))],
            ['USD Holdings',        ...(advRows||[]).map(r => fmtUSD(r.closing_balance_usd))],
          ];
        } else if (reportType === 'comp_value'){
          rows = [
            ['Advanced DCA<br>Portfolio Value', ...(advRows||[]).map(r => fmtUSD2(r.portfolio_value_usd))],
            ['Standard DCA<br>Comparative<br>Portfolio Value', ...(advRows||[]).map(r => {
              const s = stdByTY.get(Number(r.trading_year));
              return fmtUSD2(s?.portfolio_value_usd ?? null);
            })],
          ];
        } else if (reportType === 'comp_roi'){
          rows = [
            ['Advanced DCA<br>Portfolio Total ROI', ...(advRows||[]).map(r => fmtPct1(r.total_roi_percent))],
            ['Standard DCA<br>Portfolio Total ROI',  ...(advRows||[]).map(r => {
              const s = stdByTY.get(Number(r.trading_year));
              return fmtPct1(s?.total_roi_percent ?? null);
            })],
          ];
        } else if (reportType === 'comp_agr'){
          rows = [
            ['Advanced DCA<br>Portfolio<br>Annualised CAGR', ...(advRows||[]).map(r => fmtPct1(r.cagr_percent))],
            ['Standard DCA<br>Portfolio<br>Annualised CAGR',  ...(advRows||[]).map(r => {
              const s = stdByTY.get(Number(r.trading_year));
              return fmtPct1(s?.cagr_percent ?? null);
            })],
          ];
        }

        const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
        const tbody = rows.map((row, i) => {
          const isMuted = (reportType.startsWith('comp_') && i === 1);
          const labelTd = `<td class="${isMuted ? 'metric-cell metric-muted' : 'metric-cell'}">${row[0]}</td>`;
          const cells = row.slice(1).map(v => `<td>${v}</td>`).join('');
          return `<tr>${labelTd}${cells}</tr>`;
        }).join('');

        // equal-width columns via <colgroup> (declare ONCE)
        const colCount = headers?.length ? headers.length : 1;
        const colgroup = `<colgroup>${
          Array.from({ length: colCount }, () => `<col style="width:${(100/colCount)}%;"></col>`).join('')
        }</colgroup>`;

        return `<table class="report-table">${colgroup}${thead}<tbody>${tbody}</tbody></table>`;
      }

      async function fetchYearlySnapshots(customerId){
        const [{ data: advRows, error: advErr }, { data: stdRows }] = await Promise.all([
          window.supabaseClient.from('real_customer_performance_annually')
            .select('trading_year, btc_closing_price_usd:latest_btc_closing_price_usd, total_dca_invested_usd:total_invested_usdt, portfolio_value_usd, closing_balance_btc, closing_balance_usd:closing_balance_usdt, total_roi_percent, cagr_percent')
            .eq('customer_id', customerId).order('trading_year', { ascending: true }),

          window.supabaseClient.from('real_std_compare_customer_performance_annually')
            .select('trading_year, portfolio_value_usd, total_roi_percent, cagr_percent')
            .eq('customer_id', customerId).order('trading_year', { ascending: true })
        ]);
        if (advErr) throw advErr;
        return { advRows: advRows||[], stdRows: stdRows||[] };
      }
      async function fetchCustomerName(customerId){
        const { data } = await window.supabaseClient
          .from('customer_details').select('first_names, last_name')
          .eq('customer_id', customerId).single();
        return { first: data?.first_names || '', last: data?.last_name || '' };
      }
      async function fetchNarrativeFor(type, customerId){
        const SUPABASE_URL = 'https://wqnmxpooabmedvtackji.supabase.co';
        const EDGE_FUNCTION_NARRATIVE = 'chart-narrative';
        try{
          const res = await fetch(`${SUPABASE_URL}/functions/v1/${EDGE_FUNCTION_NARRATIVE}`, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ customer_id: customerId, report_type: type })
          });
          if (!res.ok) throw new Error(await res.text());
          const out = await res.json(); // expect { text } or { html }
          return (out.text || out.html || 'Narrative unavailable for this chart.');
        }catch(_){
          return 'Narrative unavailable for this chart.';
        }
      }

      function addFooter(doc, text){
        const W = doc.internal.pageSize.getWidth();
        const H = doc.internal.pageSize.getHeight();
        doc.setFont('helvetica','italic'); doc.setFontSize(9);
        doc.setTextColor(120);
        doc.text(text, W/2, H - 18, { align:'center' });
      }

      async function exportPDF(){
        if(!window.jspdf){ alert('PDF library not loaded'); return; }
        // resolve the selected customer ID from global or the dropdown
        const selectedId =
          (typeof window.currentCustomerId !== 'undefined' && window.currentCustomerId) ||
          document.getElementById('customerSelect')?.value || '';

        if (!selectedId) { alert('Please select a customer first.'); return; }

        exportBtn.disabled = true;
        exportBtn.textContent = 'Preparing PDF…';

        try{
          const { jsPDF } = window.jspdf;

          // --- Cover (portrait) ---
          const doc = new jsPDF({ unit:'pt', format:'a4', orientation:'portrait' });
          const Wp = doc.internal.pageSize.getWidth();

          const logoData = await getLogoDataUrl();
          if(logoData){
            doc.addImage(logoData, 'PNG', (Wp-160)/2, 80, 160, 80, undefined, 'FAST');
          }
          const { first, last } = await fetchCustomerName(selectedId);
          const today = new Date().toISOString().slice(0,10);
          doc.setFont('helvetica','bold'); doc.setFontSize(18);
          doc.text(`Portfolio Performance Report of ${first} ${last} as at ${today}`, Wp/2, 220, { align:'center' });
          doc.setFont('helvetica','normal'); doc.setFontSize(11);
          doc.text('Advanced DCA Strategy — BitWealth', Wp/2, 245, { align:'center' });
          addFooter(doc, disclaimer());

          // --- Data we reuse on all sections ---
          const { advRows, stdRows } = await fetchYearlySnapshots(selectedId);
          const sections = [
            { key:'holdings',   title:'Portfolio Holdings' },
            { key:'comp_value', title:'Comparison — Portfolio Value' },
            { key:'comp_roi',   title:'Comparison — ROI' },
            { key:'comp_agr',   title:'Comparison — Annualised Growth' },
          ];

          // Hidden container for screenshotting the year-table
          const tmp = document.createElement('div');
          tmp.style.position='fixed'; tmp.style.left='-99999px'; tmp.style.top='-99999px';
          document.body.appendChild(tmp);

          for(const s of sections){
            // force reliable landscape page
            doc.addPage('a4', 'l'); // force landscape

            // page dims + margins
            const W = doc.internal.pageSize.getWidth();
            const H = doc.internal.pageSize.getHeight();
            const margin = 36;
            const topTitle = 50;

            // available space calculation (to prevent overflow)
            const footerSpace = 28;
            const titleSpace = 20;
            const gap = 12; // gap between blocks

            // 1) Title
            doc.setFont('helvetica','bold'); doc.setFontSize(14); doc.setTextColor(20);
            doc.text(s.title, margin, topTitle);

            // 2) Chart (scale to fit half the page height)
            const chartPng = await buildChartImage({ type:s.key });
            // reserve roughly 45% height for chart, 30% for table, rest for narrative
            const maxChartH = (H - topTitle - footerSpace - gap*3) * 0.45;
            const chartW = W - margin*2;
            const chartH = Math.min(maxChartH, chartW * (650/1400));
            doc.addImage(chartPng, 'PNG', margin, topTitle + gap, chartW, chartH, undefined, 'FAST');

            // 3) Table under chart (render off-screen HTML to PNG)
            tmp.innerHTML = `<section class="report-tables-wrapper">${buildYearTableHTML(s.key, advRows, stdRows)}</section>`;
            const tableEl = tmp.querySelector('.report-tables-wrapper');
            const tablePng = await elementToPng(tableEl, 1400);

            const tableTop = topTitle + gap + chartH + gap;
            const maxTableH = (H - tableTop - footerSpace - gap*2) * 0.35;
            const tableW = chartW;
            const tableH = Math.min(maxTableH, tableW * 0.26); // safe default ratio
            doc.addImage(tablePng, 'PNG', margin, tableTop, tableW, tableH, undefined, 'FAST');

            // 4) Narrative
            const narrativeText = await fetchNarrativeFor(s.key, selectedId);
            doc.setFont('helvetica','normal'); doc.setFontSize(11); doc.setTextColor(40);
            const textTop = tableTop + tableH + gap;
            const maxTextWidth = W - margin*2;
            const lines = doc.splitTextToSize(narrativeText, maxTextWidth);
            // ensure narrative doesn't collide with footer; trim if needed
            const lineHeight = 14;
            const maxLines = Math.floor((H - textTop - footerSpace - gap) / lineHeight);
            const safeLines = lines.slice(0, Math.max(0, maxLines));
            doc.text(safeLines, margin, textTop, { maxWidth: maxTextWidth });

            addFooter(doc, disclaimer());
          }

          document.body.removeChild(tmp);
          doc.save(`BitWealth_Portfolio_Performance_${first}_${last}_${today}.pdf`);
        }catch(err){
          console.error(err);
          alert('Could not build PDF. See console for details.');
        }finally{
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export Customer Charts to PDF';
        }
      }

      if (!exportBtn._bound) {
        exportBtn.addEventListener('click', exportPDF);
        exportBtn._bound = true;
      }
    })();
  </script>
  <script>
  (() => {
    const SB = () => {
      const c = window.supabaseClient;
      if (!c) throw new Error('Supabase not ready');
      return c;
    };
    const wrap = document.getElementById('executedDetails');
    const list = document.getElementById('executedList');

    async function loadExecutedLast7Days(){
      const now = new Date();
      const start7 = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - 7, 0, 0, 0)).toISOString();

      list.textContent = 'Loading…';
      const { data, error } = await SB()
        .from('exchange_order_intents')
        .select('intent_id, status, source_signal, intent_usdt, intent_btc, intent_price, avg_price, min_notional, exchange_order_id, notes, created_at, symbol, side')
        .in('status', ['filled','cancelled','error'])
        .gte('created_at', start7)
        .order('created_at', { ascending: false });

      if (error) {
        console.error(error);
        list.textContent = 'Error loading executed orders.';
        return;
      }

      const cnt = wrap.querySelector('.count');
      if (cnt) cnt.textContent = `(${data?.length || 0})`;

      if (!data || !data.length) {
        list.textContent = 'No executed orders in the last 7 days.';
        return;
      }

      const rows = data.map(r => {
        const when = r.created_at ? new Date(r.created_at) : null;
        const d = when ? when.toISOString().slice(0,10) : '—';
        const t = when ? when.toLocaleTimeString([], { hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' }) : '—';
        const px = r.avg_price ?? r.intent_price ?? '—';
        const usdt = r.intent_usdt ?? '—';
        const btc  = r.intent_btc  ?? '—';
        const sig  = r.source_signal || '—';
        const exid = r.exchange_order_id || '—';
        const st   = (r.status || '').toLowerCase();

        return `<tr>
          <td class="muted">${d} ${t}</td>
          <td>${(r.symbol||'').toUpperCase()} ${(r.side||'').toUpperCase()}</td>
          <td><span class="status-pill ${st}">${st}</span></td>
          <td>${sig}</td>
          <td>${usdt}</td>
          <td>${btc}</td>
          <td>${px}</td>
          <td class="muted">${exid}</td>
        </tr>`;
      }).join('');

      list.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>When</th><th>Pair/Side</th><th>Status</th><th>Signal</th>
              <th>USDT</th><th>BTC</th><th>Price</th><th>Exchange ID</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    // Expose a stable name so other code can call it after preview/execute
    window.loadExecutedOrders = loadExecutedLast7Days;

    // Load once on page open
    loadExecutedLast7Days();
  })();
  </script>
</body>
</html>
